---  
title: "Task 1: Velocity Control"
---  

Develop a working ROS application to making *a real TurtleBot3 Waffle* follow a prescribed motion profile, whilst printing key information to the terminal.

!!! success "Course Checkpoints"
    
    You should aim to have completed the following *additional* parts of the COM2009 ROS Course to support your work on this task: 

    * **Assignment #1**: Part 2, up to (and including) [Exercise 5](../../assignment1/part2.md#ex5).
    * **Real Waffle Essential Exercises**: [Exercise 1 (Publishing Velocity Commands)](../../../waffles/essentials.md#ex1).

## Summary

The main objective of this task is to create a ROS node (or multiple nodes) that make your robot follow a **figure-of-eight** pattern on the robot arena floor. The figure-of-eight trajectory should be generated by following two loops, both 1 meter in diameter, as shown below. <a name="fig-eight"></a>

<figure markdown>
  ![](../figures/task1_motion_path.png){width=400px}
  <figcaption>The figure-of-eight path for Task 1.</figcaption>
</figure>

Whilst doing this, you will also need to print some robot odometry data to the terminal at regular intervals ([see below for the specifics](#details)). In order to get the terminal message formatting right, you might want to have a look at the documentation on [Python String Formatting](https://docs.python.org/3/tutorial/inputoutput.html){target="_blank"}, and refer to any of the code examples that involve printing messages to the terminal in Assignment #1.

## Details

1. The robot must start by moving **anti-clockwise**, following a circular motion path of 1 m diameter ("**Loop 1**," as shown in [the figure above](#fig-eight)).
1. Once complete, the robot must then turn **clockwise** to follow a second circular path, again of 1 m diameter ("**Loop 2**").
1. After Loop 2 the robot must stop, at which point it *should* be located back at its starting point.
1. The velocity of the robot should be defined to ensure that the whole sequence takes **60 seconds** to complete (:material-plus-minus:5 seconds).

    **Note**: *The timer will start as soon as the robot starts moving*.

1. The robot's real-time pose should be printed to the terminal throughout, where messages should be of the following format (**exactly**): <a name="msg-format"></a>
	
    ``` { .txt .no-copy }
    x={x} [m], y={y} [m], yaw={yaw} [degrees].
	```

	Where `{x}`, `{y}` and `{yaw}` should be replaced with the correct real-time odometry data as follows:
	
	1. `{x}`: the robot's linear position in the X axis, quoted in meters to **two decimal places**.
    1. `{y}`: the robot's linear position in the Y axis, quoted in meters to **two decimal places**.
	1. `{yaw}`: the robot's orientation about the Z axis, quoted in degrees to **one decimal place**.
	
	The data should be quoted relative to its starting position at the beginning of the task, e.g. at the start of the task (before the robot has moved) the terminal messages should read:

    ``` { .txt .no-copy }
    x=0.00 [m], y=0.00 [m], yaw=0.0 [degrees].
    ```
	
	These message should be printed to the terminal **at a rate of 1Hz**. It doesn't matter if the messages continue to be printed to the terminal after the robot has stopped (i.e. after the figure-of-eight has been completed).

    !!! warning "Important"
        You should use `#!py get_logger().info()` method calls within your node to print these terminal messages.

### A note on Odometry

When the robot is placed in the arena at the start of the task its odometry may not necessarily read zero, so you will need to compensate for this. You'll therefore need to grab the robot pose from the `/odom` topic before your robot starts moving, and then use that as the zero-reference to convert all the subsequent odometry readings that you obtain throughout the task.

Odometry and keeping track of the robot's *pose* is discussed in detail in [Assignment #1 Part 2](../../assignment1/part2.md).

## Executing Your Code {#launch}

Your ROS package must contain a launch file called `task1.launch.py`. When assessing your team's package, the teaching team will use the following command to execute all the necessary functionality from within your package:
	 
``` { .bash .no-copy }
ros2 launch com2009_teamXX_2025 task1.launch.py
```

... where `XX` will be replaced with *your team number*.
    
!!! note
    ROS will already be running on the robot before we attempt to execute your launch file, and [a bridge between the robot and laptop will have already been established](../../../waffles/launching-ros.md#step-4-robot-laptop-bridging).

## Simulation Resources

You might find it helpful to develop your node(s) basic functionality in simulation before testing things out on a real robot. You can use the standard "Empty World" environment to do this, which can be launched in using the following command:

```bash
ros2 launch turtlebot3_gazebo empty_world.launch.py
```

For the real task, there will be cylindrical objects placed at the centre of each of the figure-of-eight loops, so your robot will need to move around these as it completes the task. We have therefore also created a simulation environment that is representative of the real world environment during the assessment. This is available in a package called `com2009_simulations`, which is part of [the `tuos_ros` Course Repo](https://github.com/tom-howard/tuos_ros/tree/humble){target="_blank"}. The instructions for downloading and installing this within your own local ROS installation are [available here](../../extras/course-repo.md).

If you've already installed this (as part of Assignment #1 perhaps), then it's worth making sure that you have the most up-to-date version ([as discussed here](../../extras/course-repo.md#updating)).

Once you've done all this, then you should be able to launch the Task 1 development arena with the following `ros2 launch` command:

```bash
ros2 launch com2009_simulations task1.launch.py
```

<figure markdown>
  ![](../figures/task1.jpg)
  <figcaption>The Task 1 development arena.</figcaption>
</figure>

!!! note
    There won't be any loop markers on the real robot arena floor during the assessment.

## Marking

This task will be assessed by the teaching team as part of Part A (i.e. along with [Task 2](./task2.md)). This will be assessed during the Easter Holiday period, with feedback returned to you before the semester resumes.

There are **20 marks** available for this task in total, summarised as follows:

<center>

| Criteria | Marks | Details |
| :--- | :---: | :--- |
| **A**: The Motion Path | 10/20 | How closely the real robot follows *a true figure-of-eight* path in the robot arena, based on [the criteria table below](#criterion-a-the-motion-path). |
| **B**: Terminal Messages | 10/20 | The correct formatting of your odometry messages, and the validity of the data that is presented in the terminal as the robot performs the task, based on [the criteria table below](#criterion-b-terminal-messages). |

</center>

### Criterion A: The Motion Path

**Marks:** 10/20

<center>

| Criteria | Details | Marks|
| :--- | :--- | :--- |
| **A1**: Direction of travel | The robot must move anticlockwise for the first loop ("Loop 1") and then clockwise for the second ("Loop 2"). | 2 |
| **A2**: Loop 1 | The loop must be ~1 m in diameter, centred about the red beacon. | 2 |
| **A3**: Loop 2 | The loop must be ~1 m in diameter, centred about the blue beacon. | 2 |
| **A4**: Stopping | Once the robot completes its figure of eight, it must stop with both wheels **within 10 cm** of the start line. | 2 |
| **A5**: Timing | The robot must complete the full figure of eight and stop in 55-65 seconds. | 2 |

</center>

### Criterion B: Terminal Messages

**Marks:** 10/20

<center>

| Criteria | Details | Marks|
| :--- | :--- | :--- |
| **B1**: Rate | Messages should be printed to the terminal at **a rate of 1 Hz**. | 2 |
| **B2**: Format | The messages printed to the terminal should be formatted **exactly** [as detailed above](#msg-format), and must be printed using `#!py get_logger().info()` method calls. | 2 |
| **B3**: Data | Each message value (`x`, `y` and `yaw`) should be plausible, that is: they represent the actual pose of the robot, based on all readings being set to zero at the start/finish point ([as illustrated above](#fig-eight)). In addition, each value must be quoted in the correct units (meters or degrees, as appropriate). | 6 |

</center>

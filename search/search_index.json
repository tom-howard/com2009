{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>"},{"location":"#com2009-ros-labs","title":"COM2009 ROS Labs","text":"<p>ROS Labs for the COM2009-3009 Robotics Course at The University of Sheffield (and more) </p> <p> </p> <p>By Tom Howard Department of Multidisciplinary Engineering Education  </p> <p>(Image courtesy of Andy Brown)</p> <p>Find out more...</p> <p></p>"},{"location":"about/","title":"Welcome","text":"<p>This section might include: </p> <ul> <li>About</li> <li>The Robots</li> <li>License</li> <li>Acknowledgements</li> <li>Version History</li> </ul> <p>See here for reference</p>"},{"location":"extras/","title":"ROS Extras","text":"<p>Extra ROS2 tutorials etc that aren't part of the main Assignment #1 Course, but that might be helpful for Assignment #2...</p> <p>A bit like this from 2023/24</p>"},{"location":"labs/","title":"The COM2009 Lab Course","text":"<p>For the COM2009 Robotics course you must complete two lab assignments:</p> <ul> <li> <p>Assignment #1: \"An Introduction to ROS (the Robot Operating System)\".</p> <p>Here you will learn what ROS is and how to use it. You will complete this assignment individually, and in your own time.</p> <p>Weighting: 25% of the overall COM2009 module mark.</p> </li> <li> <p>Assignment #2: \"Team Robotics Project\".</p> <p>Here you will work in teams of 3-4 to complete a series of real-world robotics tasks using our Tutlebot3 Waffle Robots in the Lab (Diamond Computer Room 5).</p> <p>Weighting: 30% of the overall COM2009 module mark</p> </li> </ul>"},{"location":"labs/assignment1/","title":"Assignment #1: An Introduction to ROS","text":""},{"location":"labs/assignment1/#overview","title":"Overview","text":"<p>Assignment #1 is an X-part course, which you should complete in full and in order. The course is designed to be completed in simulation, so you will therefore need access to a ROS installation which can either be installed on your own machine, or accessed on a range of managed computers across the University of Sheffield campus. See here for more information on how to install ROS (TODO).</p> <p>Each part of the course comprises a series of step-by-step instructions and exercises to teach you how ROS works, and introduces you to the core principles of the framework. The exercises give you the opportunity to see how to apply these principles to practical robotic applications. Completing this course is essential for obtaining all the necessary skills for Assignment #2: the Team Robotics Project, where you will work in teams to program our real TurtleBot3 Waffle robots (TODO).  </p>"},{"location":"labs/assignment1/#the-course","title":"The Course","text":"<ul> <li> <p>Part 1: Getting Started with ROS2</p> <p>In this first part you will learn the basics of ROS and become familiar with some key tools and principles of this framework, allowing you to program robots and work with ROS applications effectively.</p> </li> <li> <p>Part 2: Odometry &amp; Navigation</p> <p>In this session you'll learn about Odometry data, which informs us of a robot's position in an environment. You'll also learn how to control a ROS robot's velocity (and thus its position) using both open and closed-loop control methods.</p> </li> <li> <p>Part 3: SLAM &amp; Autonomous Navigation</p> <p>Here you'll take your first look at the LiDAR sensor, the data that it generates, and how this can be of huge benefit for robotics applications. You'll see this in practice by leveraging the mapping and autonomous navigation tools within ROS.</p> </li> <li> <p>Part 4: ROS Services</p> <p>In this part of the course you'll learn about ROS Services, which offer an alternative way for nodes to communicate in ROS. You will see how this framework can be used to control a robot or invoke certain behaviours more effectively for certain tasks.</p> </li> <li> <p>Part 5: ROS Actions</p> <p>Building on what you learnt about ROS Services in Part 4, here you will look at ROS Actions, which are similar to Services, but with a few key differences.</p> </li> <li> <p>Part 6: Cameras, Machine Vision &amp; OpenCV</p> <p>Here you'll learn how to work with images from an on-board camera. You will look at techniques to detect features within these images, and use this to inform robot decision-making.</p> </li> </ul>"},{"location":"labs/assignment1/#assessment","title":"Assessment","text":"<p>This assignment is worth 25% of the overall mark for COM2009, and is assessed via an on-campus Blackboard-based test taking place in week 7 or 8 of the Spring Semester. </p>"},{"location":"labs/assignment1/part1/","title":"Part 1: Getting Started with ROS2","text":""},{"location":"labs/assignment1/part1/#introduction","title":"Introduction","text":"<p> Exercises: X Estimated Completion Time: Y hours</p>"},{"location":"labs/assignment1/part1/#aims","title":"Aims","text":"<p>In the first part of this lab course you will learn the basics of ROS and become familiar with some key tools and principles of the framework which will allow you to program robots and work with ROS applications effectively.  For the most part, you will interact with ROS using the Linux command line and so you will also become familiar with some key Linux command line tools that will help you.  Finally, you will learn how to create some basic ROS Nodes using Python and get a taste of how ROS topics and messages work.</p>"},{"location":"labs/assignment1/part1/#intended-learning-outcomes","title":"Intended Learning Outcomes","text":"<p>By the end of this session you will be able to:  </p> <ol> <li>Control a TurtleBot3 Robot, in simulation, using ROS.</li> <li>Launch ROS applications using <code>roslaunch</code> and <code>rosrun</code>.</li> <li>Interrogate running ROS applications using key ROS command line tools.</li> <li>Create a ROS package comprised of multiple nodes and program these nodes (in Python) to communicate with one another using ROS Communication Methods.</li> <li>Navigate a Linux filesystem and learn how to do various filesystem operations from within a Linux Terminal.</li> </ol>"},{"location":"labs/assignment1/part1/#first-steps","title":"First Steps","text":"<p>Step 1: Accessing a ROS2 Environment for this Course</p> <p>If you haven't done so already, see here for all the details on how to install or access a ROS environment for this course (TODO).</p> <p>Step 2: Launch ROS</p> <p>Launch your ROS environment.</p> <ol> <li>OPTION 1</li> <li>OPTION 2</li> <li>etc...</li> </ol> <p>Either way, you should now have access to ROS via a Linux terminal instance, and we'll refer to this terminal instance as TERMINAL 1.</p> <p>Step 3: Download The Course Repo</p> <p></p> <p>We've put together a few ROS packages specifically for this course. These all live within this GitHub repo, and you'll need to download and install this into your ROS environment now, before going any further.</p> <ol> <li> <p>In TERMINAL 1, Navigate into the \"ROS2 Workspace\" using the <code>cd</code> command<sup>1</sup>:</p> <pre><code>cd ~/ros2_ws/src/\n</code></pre> </li> <li> <p>Then, run the following command to clone the Course Repo from GitHub:</p> <p>TERMINAL 1: <pre><code>git clone https://github.com/tom-howard/tuos_ros.git -b humble\n</code></pre></p> </li> <li> <p>Once this is done, you'll need to build this using a tool called \"Colcon\"<sup>2</sup>:</p> <p>TERMINAL 1: <pre><code>cd ~/ros2_ws/ &amp;&amp; colcon build --packages-up-to tuos_ros &amp;&amp; source ~/.bashrc\n</code></pre></p> </li> </ol> <p>Don't worry too much about what you just did, for now. We'll cover this in more detail throughout the course. That's it for now though, we'll start using some of the packages that we've just installed a bit later on..</p>"},{"location":"labs/assignment1/part1/#creating-your-first-ros-applications","title":"Creating Your First ROS Applications","text":"<p>Shortly you will create some simple publisher and subscriber nodes in Python and send simple ROS messages between them. As we learnt earlier though, ROS applications must be contained within packages, and so we need to create a package first in order to start creating our own ROS nodes. </p> <p>It's important to work in a specific filesystem location when we create and work on our own ROS packages. These are called \"Workspaces\" and you should already have one ready to go within your local ROS environment<sup>3</sup>:</p> <pre><code>~/ros2_ws/src/\n</code></pre> <p>Note</p> <p><code>~</code> is an alias for your home directory. So <code>cd ~/ros2_ws/src/</code> is the same as typing <code>cd /home/{your username}/ros2_ws/src/</code>.</p> <p>Important</p> <p>All new packages must be located in the <code>src</code> folder of the workspace!!</p>"},{"location":"labs/assignment1/part1/#exx","title":"Exercise XX: Creating your own ROS Package","text":"<p>The <code>ros2</code> Command Line Interface (CLI) includes a tool to create a new ROS packages: <code>ros2 pkg create</code>. This tool supports two different \"build types:\"</p> <ol> <li> <p>CMake (for packages containing nodes written in C++):</p> <p><code>ros2 pkg create --build-type ament_cmake</code></p> </li> <li> <p>Python (for packages containing nodes written in well, er, Python!):</p> <p><code>ros2 pkg create --build-type ament_python</code></p> <p>Packages are structured slightly differently in each case.</p> </li> </ol> <p>You can learn more about all this from the Official ROS2 Tutorials (if you're interested).</p> <p>We'll be using Python throughout this course, but we'll actually take a slightly different approach to package creation that will provide us with a little more flexibility and ease of use (particularly for things we'll do later on in the Assignment #1 course and in Assignment #2). We've therefore created a helper script (inside the <code>tuos_ros</code> Course Repo) to help you create packages without using either of the above two commands. The approach we'll take is based on this tutorial (courtesy of the Robotics Backend), so feel free to look at this if you'd like to find out more. Then, simply follow the steps below to create your first ROS package for this course, using the <code>create_pkg.sh</code> helper tool.</p> <ol> <li> <p>Navigate into the <code>tuos_ros</code> Course Repo that you downloaded earlier by using the Linux <code>cd</code> command (change directory). In TERMINAL 1 enter the following:</p> <p>TERMINAL 1: <pre><code>cd ~/ros2_ws/src/tuos_ros/\n</code></pre></p> </li> <li> <p>Here you'll find the <code>create_pkg.sh</code> helper script. Run this now using the following command to create a new package called <code>part1_pubsub</code>:</p> <p>TERMINAL 1: <pre><code>./create_pkg.sh part1_pubsub\n</code></pre></p> </li> <li> <p>Navigate into this new package directory (using <code>cd</code>):</p> <p>TERMINAL 1: <pre><code>cd ../part1_pubsub/\n</code></pre></p> <p>Info</p> <p><code>..</code> means \"go back one directory,\" so that command above is telling <code>cd</code> to navigate out of the <code>tuos_ros</code> directory (and therefore back to <code>~/ros2_ws/src/</code>), and then go into the <code>part1_pubsub</code> directory from there.</p> </li> <li> <p><code>tree</code> is a Linux command which shows us the content of the current directory in a nice tree-like format. Use <code>tree</code> now to show the current content of the <code>part1_pubsub</code> directory:</p> <pre><code>~/ros2_ws/src/part1_pubsub$ tree\n.\n\u251c\u2500\u2500 CMakeLists.txt\n\u251c\u2500\u2500 include\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 part1_pubsub\n\u2502\u00a0\u00a0     \u2514\u2500\u2500 minimal_header.hpp\n\u251c\u2500\u2500 package.xml\n\u251c\u2500\u2500 part1_pubsub\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 __init__.py\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 minimal_module.py\n\u251c\u2500\u2500 scripts\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 minimal_node.py\n\u2514\u2500\u2500 src\n    \u2514\u2500\u2500 minimal_node.cpp\n\n5 directories, 7 files\n</code></pre> <ul> <li><code>scripts</code>: is a directory that will contain all the Python Nodes that we'll create (you'll notice a <code>minimal_node.py</code> already exists in there).</li> <li> <p><code>part1_pubsub</code>: is a directory that we can use to store Python modules, that we can then import into our main Python nodes</p> <p>(<code>from part1_pubsub.minimal_module import ...</code>, for example)</p> </li> <li> <p><code>package.xml</code> and <code>CMakeLists.txt</code>: are both files that define our package, and how it must be built (using <code>colcon build</code>). We'll explore these more shortly... </p> </li> </ul> </li> </ol>"},{"location":"labs/assignment1/part1/#exy","title":"Exercise Y: Creating a publisher node","text":"<ol> <li>From the root of your <code>part1_pubsub</code> package, navigate to the <code>scripts</code> folder using the <code>cd</code> command.</li> <li> <p><code>touch</code> is a Linux command that we can use to create an empty file. Use this to create an empty file called <code>publisher.py</code>, which we will add content to shortly:</p> <p>TERMINAL 1: <pre><code>touch publisher.py\n</code></pre></p> </li> <li> <p>Use <code>ls</code> to verify that the file has been created, but use the <code>-l</code> option with this, so that the command provides its output in \"a long listing format\":</p> <p>TERMINAL 1: <pre><code>ls -l\n</code></pre></p> <p>This should output something similar to the following:</p> <pre><code>~/ros2_ws/src/part1_pubsub/scripts$ ls -l\ntotal 4\n-rwxr-xr-x 1 student student 339 MMM DD HH:MM minimal_node.py\n-rw-r--r-- 1 student student   0 MMM DD HH:MM publisher.py\n</code></pre> <p>This confirms that the file exists, and the <code>0</code> in the middle of the bottom line there indicates that the file is empty (i.e. its current size is 0 bytes), which is what we'd expect.</p> </li> <li> <p>We therefore now need to open the file and add content to it. We'd recommend using Visual Studio Code (VS Code) as an IDE for this course, which can be launched with the following command in TERMINAL 1:</p> <p>TERMINAL 1: <pre><code>code ~\n</code></pre></p> <p>[TODO: does this work for Docker??]</p> </li> <li> <p>Using the VS Code File Explorer, locate the <code>publisher.py</code> file that you have just created (<code>ros2_ws/src/part1_pubsub/scripts/</code>) and click on the file to open it in the main editor. </p> </li> <li> <p>Once opened, copy the code provided here into the empty file and save it. </p> <p>Note</p> <p>It's important that you understand how this code works, so make sure that you read the annotations!</p> </li> <li> <p>Next, we need to add our <code>publisher.py</code> file as an executable to our package's <code>CMakeLists.txt</code>. This will ensure that it then gets built when we run <code>colcon build</code> (in the next step).</p> <p>In VS Code, open the <code>CMakeLists.txt</code> file that is at the root of your <code>part1_pubsub</code> package directory (<code>ros2_ws/src/part1_pubsub/CMakeLists.txt</code>). Locate the lines (near the bottom of the file) that read:</p> <pre><code># Install Python executables\ninstall(PROGRAMS\n  scripts/minimal_node.py\n  DESTINATION lib/${PROJECT_NAME}\n)\n</code></pre> <p>Replace <code>minimal_node.py</code> with <code>publisher.py</code> to define this as a Python executable in your package:</p> <pre><code># Install Python executables\ninstall(PROGRAMS\n  scripts/publisher.py\n  DESTINATION lib/${PROJECT_NAME}\n)\n</code></pre> </li> <li> <p>Now, use <code>colcon</code> to build your package.</p> <ol> <li> <p>You MUST run this from the root of your Colcon Workspace (i.e.: <code>~/ros2_ws/</code>), NOT the <code>src</code> directory (<code>~/ros2_ws/src/</code>), so navigate there now using <code>cd</code>:</p> <pre><code>cd ~/ros2_ws/\n</code></pre> </li> <li> <p>Then, use the following <code>colcon</code> command to build your package:</p> <pre><code>colcon build --packages-select part1_pubsub --symlink-install\n</code></pre> <p>What do the additional arguments above do?</p> <ul> <li><code>--packages-select</code>: Build only the <code>part1_pubsub</code> package, nothing else (without this <code>colcon</code> would attempt to build every package in the workspace).</li> <li><code>--symlink-install</code>: Ensures that you don't have to re-run <code>colcon build</code> every time you make a change to your package's executables (i.e. your Python files in the <code>scripts</code> directory).</li> </ul> </li> <li> <p>Finally, \"re-source\" your <code>bashrc</code><sup>4</sup>:</p> <pre><code>source ~/.bashrc\n</code></pre> </li> </ol> </li> <li> <p>We should now be able to run this node using the <code>ros2 run</code> command.</p> <p>Remember: <code>ros2 run {package name} {script name}</code>, so:</p> <p>TERMINAL 1: <pre><code>ros2 run part1_pubsub publisher.py\n</code></pre></p> <p>... Hmm, something not quite right? If you typed the command exactly as above and then tried to run it, you probably just received the following error:</p> <pre><code>$ ros2 run part1_pubsub publisher.py\nNo executable found\n</code></pre> <p>When we create a file using <code>touch</code> it is given certain permissions by default. Run <code>ls -l</code> again (making sure that your terminal is in the right location: <code>~/ros2_ws/src/part1_pubsub/scripts/</code>).</p> <p>The first bit tells us about the permissions that are currently set: <code>-rw-r--r--</code>. This tells us who has permission to do what with this file and (currently) the first bit: <code>-rw-</code>, tells us that we have permission to read or write to it. There is a third option we can set too though, which is the execute permission, and we can set this using the <code>chmod</code> Linux command...</p> </li> <li> <p>Run the <code>chmod</code> command as follows:</p> <p>TERMINAL 1: <pre><code>chmod +x publisher.py\n</code></pre></p> </li> <li> <p>Now, run <code>ls -l</code> again to see what has changed:</p> <p>TERMINAL 1: <pre><code>ls -l\n</code></pre></p> <p>We have now granted permission for the file to be executed too:</p> <pre><code>-rwxr-xr-x 1 student student 1125 MMM DD HH:MM publisher.py\n</code></pre> </li> <li> <p>OK, now use <code>ros2 run</code> again to (hopefully!) run the <code>publisher.py</code> node (remember: <code>ros2 run {package name} {script name}</code>).</p> <p>If you see a message in the terminal similar to the following then the node has been launched successfully:</p> <pre><code>[INFO] [#####] [simple_publisher]: The 'simple_publisher' node is inisialised.\n</code></pre> <p>Phew!</p> </li> <li> <p>We can further verify that our publisher node is running using a number of different tools. Try running the following commands in TERMINAL 2:</p> <ol> <li><code>ros2 node list</code>: This will provide a list of all the nodes that are currently active on the system. Verify that the name of our publisher node is visible in this list (it's probably the only item in the list at the moment!)</li> <li><code>ros2 topic list</code>: This will provide a list of the topics that are currently being used by nodes on the system. Verify that the name of the topic that our publisher is publishing messages to (<code>/my_topic</code>) is present within this list.</li> </ol> </li> </ol>"},{"location":"labs/assignment1/part1/#rostopic","title":"Interrogating ROS Topics","text":"<p>So far we have used the <code>ros2 topic</code> ROS command with two additional arguments: [TODO: check this!]</p> <ul> <li><code>list</code>: to provide us with a list of all the topics that are active on our ROS system, and</li> <li><code>info</code>: to provide us with information on a particular topic of interest.</li> </ul> <p>We can use the autocomplete functionality of the Linux terminal to provide us with a list of all the available options that we can use with the <code>ros2 topic</code> command.  To do this type <code>ros2 topic</code> followed by a Space and then press the Tab key twice:</p> <pre><code>rostopic[SPACE][TAB][TAB]\n</code></pre> <p>You should then be presented with a list of all options:</p> <p>[TODO: a gif]</p> <ul> <li> <p><code>ros2 topic hz {topic name}</code> provides information on the frequency (in Hz) at which messages are being published to a topic:</p> <pre><code>ros2 topic hz /my_topic\n</code></pre> <p>This should tell us that our publisher node is publishing messages to the <code>/my_topic</code> topic at (or close to) 1 Hz, which is exactly what we ask for in the <code>publisher.py</code> file (in the <code>__init__</code> part of our <code>Publisher</code> class). Enter Ctrl+C to stop this command.</p> </li> <li> <p><code>ros2 topic echo {topic name}</code> shows the messages being published to a topic:</p> <pre><code>ros2 topic echo /my_topic\n</code></pre> <p>This will provide a live stream of the messages that our <code>publisher.py</code> node is publishing to the <code>/my_topic</code> topic. Enter Ctrl+C to stop this.</p> </li> <li> <p>We can see some additional options for the <code>echo</code> command by viewing the help documentation for this too:</p> <pre><code>ros2 topic echo --help\n</code></pre> <p>From here, for instance, we can learn that if we just wanted to print the first message that was received we could use the <code>-once</code> option, for example:</p> <pre><code>ros2 topic echo /my_topic --once\n</code></pre> </li> </ul>"},{"location":"labs/assignment1/part1/#exZ","title":"Exercise Z: Creating a subscriber node","text":"<p>To illustrate how information can be passed from one node to another (via topics and messages) we'll now create another node to subscribe to the topic that our publisher node is broadcasting messages to.</p> <ol> <li> <p>In TERMINAL 2 use the filesystem commands that were introduced earlier (<code>cd</code>, <code>ls</code>, etc.) to navigate to the <code>scripts</code> folder of your <code>part1_pubsub</code> package.</p> </li> <li> <p>Use the same procedure as before to create a new empty Python file called <code>subscriber.py</code> and remember to make it executable! </p> </li> <li> <p>Then, open the newly created <code>subscriber.py</code> file in VS Code, paste in the code here and save it. </p> <p>Once again, it's important that you understand how this code works, so make sure you read the code annotations! </p> </li> <li> <p>Next, we need to add this as an additional executable for our package. </p> <p>Open up the <code>CMakeLists.txt</code> file at the root of your <code>part1_pubsub</code> package directory again, head back to the <code># Install Python executables</code> section and add the <code>subscriber.py</code> file:</p> <pre><code># Install Python executables\ninstall(PROGRAMS\n  scripts/publisher.py\n  scripts/subscriber.py\n  DESTINATION lib/${PROJECT_NAME}\n)\n</code></pre> </li> <li> <p>Now we need to <code>colcon build</code> again.</p> <ol> <li> <p>Make sure you're at the root of the Colcon Workspace:</p> <pre><code>cd ~/ros2_ws/\n</code></pre> </li> <li> <p>Run <code>colcon build</code> on only the <code>part1_pubsub</code> package:</p> <pre><code>colcon build --packages-select part1_pubsub --symlink-install\n</code></pre> </li> <li> <p>And then re-source the <code>bashrc</code>:</p> <pre><code>source ~/.bashrc\n</code></pre> </li> </ol> </li> <li> <p>Use <code>ros2 run</code> to execute your newly created <code>subscriber.py</code> node (remember: <code>ros2 run {package name} {script name}</code>). If your publisher and subscriber nodes are working correctly you should see an output like this:</p> <p>[TODO: another gif]</p> </li> <li> <p>As before, we can find out what nodes are running on our system by using the <code>ros2 node list</code> command. Run this in TERMINAL 3, you should see both your publisher and subscriber nodes listed there.</p> </li> <li> <p>Finally, close down your publisher and subscriber nodes by entering Ctrl+C in the terminals where they are running (should be 1 &amp; 2).</p> </li> </ol> <p>Advanced:  </p> <p>You've now created a publisher and subscriber, both of which were able to communicate with one another over the <code>/chatter</code> topic, using the <code>String</code> standard ROS message type. This message is provided, by ROS, as part of the <code>std_msgs</code> package, but there are other simple message types within this package that we can use too to pass data around a ROS network too, one of which is <code>Float64</code>.</p> <ul> <li>How could you adapt your publisher and subscriber nodes to use the <code>Float64</code> message type, instead of <code>String</code>?</li> </ul> <ol> <li> <p>What is a ROS2 Workspace? You can find out more here.\u00a0\u21a9</p> </li> <li> <p>What is Colcon? Find out more here.\u00a0\u21a9</p> </li> <li> <p>You can learn more about ROS2 Workspaces here.\u00a0\u21a9</p> </li> <li> <p>What does <code>source ~/.bashrc</code> do? See here for an explanation.\u00a0\u21a9</p> </li> </ol>"},{"location":"labs/assignment1/part2/","title":"Part 2: Odometry & Navigation","text":""},{"location":"labs/assignment1/part2/#introduction","title":"Introduction","text":"<p> Exercises: X Estimated Completion Time: Y hours</p>"},{"location":"labs/assignment1/part2/#aims","title":"Aims","text":"<p>In Part 2 you will learn how to control a ROS robot's position and velocity from both the command line and through ROS Nodes. You will also learn how to interpret the data that allows us to monitor a robot's position in its physical environment (odometry).  The things you will learn here form the basis for all robot navigation in ROS, from simple open-loop methods to more advanced closed-loop control (both of which you will explore).</p>"},{"location":"labs/assignment1/part2/#intended-learning-outcomes","title":"Intended Learning Outcomes","text":"<p>By the end of this session you will be able to:</p> <ol> <li>Interpret the Odometry data published by a ROS Robot and identify the parts of these messages that are relevant to a 2-wheeled differential drive robot (such as the TurtleBot3).</li> <li>Develop Python nodes to obtain Odometry messages from an active ROS network and translate them to provide useful information about a robot's pose in a convenient, human-readable way.</li> <li>Implement open-loop velocity control of a robot using ROS command-line tools.</li> <li>Develop Python nodes that use open-loop velocity control methods to make a robot follow a pre-defined motion path.</li> <li>Combine both publisher &amp; subscriber communication methods into a single Python node to implement closed-loop (odometry-based) velocity control of a robot.</li> <li>Explain the limitations of Odometry-based motion control methods. </li> </ol>"},{"location":"labs/assignment1/part2/#getting-started","title":"Getting Started","text":"<p>TODO:</p> <p>Step 1: Launch your ROS Environment</p> <p>If you haven't done so already, launch your ROS environment now:</p> <ol> <li>OPTION 1</li> <li>OPTION 2</li> <li>etc...</li> </ol> <p>You should now have access to ROS via a Linux terminal instance. We'll refer to this terminal instance as TERMINAL 1.</p> <p>Step 2: Make Sure The Course Repo is Up-To-Date</p> <p></p> <p>In Part 1 you should have downloaded and installed The Course Repo into your ROS environment. If you haven't done this yet then go back and do it now. If you have already done it, then it's worth just making sure it's all up-to-date, so run the following command now to do so:</p> <p>TERMINAL 1: <pre><code>cd ~/ros2_ws/src/tuos_ros/ &amp;&amp; git pull\n</code></pre></p> <p>Then build with Colcon: </p> <pre><code>cd ~/ros2_ws/ &amp;&amp; colcon build\n</code></pre> <p>And finally, re-source your environment:</p> <pre><code>source ~/.bashrc\n</code></pre> <p>Warning</p> <p>If you have any other terminal instances open, then you'll need run <code>source ~/.bashrc</code> in these too, in order for any changes made by the Colcon build process to propagate through to these as well.</p> <p>Step 3: Launch a Waffle Simulation</p> <p>In TERMINAL 1 enter the following command to launch a simulation of a TurtleBot3 Waffle in an empty world:  </p> <p>TERMINAL 1: <pre><code>ros2 launch turtlebot3_gazebo empty_world.launch.py\n</code></pre></p> <p>A Gazebo simulation window should open and within this you should see a TurtleBot3 Waffle in empty space:</p> <p></p> <p>You're all set up and ready to go!</p>"},{"location":"labs/assignment1/part2/#position-and-velocity","title":"Position and Velocity","text":"<p>Two types of Velocity Command can be issued to any ROS Robot to make it move (and thus change its position):</p> <ul> <li>Linear Velocity: The velocity at which the robot moves forwards or backwards in one of its principal axes.</li> <li>Angular Velocity: The velocity at which the robot rotates about one of its principal axes.</li> </ul>"},{"location":"labs/assignment1/part2/#principal-axes","title":"Principal Axes","text":"<p>The motion (i.e. the velocity) of any mobile robot can be defined in terms of three principal axes: <code>X</code>, <code>Y</code> and <code>Z</code>. In the context of our TurtleBot3 Waffle, these axes (and the motion about them) are as follows:</p> <p></p> <p>In theory then, a robot can move linearly or angularly about any of these three axes, as shown by the arrows in the figure. That's six Degrees of Freedom (DOFs) in total, achieved based on a robot's design and the actuators it is equipped with. </p> <p>Our TurtleBot3 Waffles, however, only have two motors, so they don't actually have six DOFs! These two motors can be controlled independently, which is known as a \"differential drive\" configuration, and ultimately provides it with a total of two degrees of freedom in total, as illustrated below.</p> <p></p> <p>It can therefore only move linearly in the x-axis (Forwards/Backwards) and angularly in the z-axis (Yaw).</p> <p>It's also worth noting (while we're on the subject of motion) that our TurtleBot3 Waffles have maximum velocity limits:</p> <p> Velocity Component Upper Limit Units Linear 0.26 m/s Angular 1.82 rad/s <p></p>"},{"location":"labs/assignment1/part2/#ros-velocity-commands","title":"ROS Velocity Commands","text":"<p>In Part 1 you learnt about ROS Topics, and about how the <code>teleop_keyboard</code> node could be used to publish messages to a particular topic in order to control the velocity of the robot (and thus make it move around).</p> <p>Questions</p> <ol> <li>Which topic is used to control the velocity of the robot?</li> <li>What message type does this topic use?</li> </ol> <p>Return here if you need a reminder on how to find the answers to these questions (TODO: link to part 1).</p> <p>In Part 1 you also learnt how to find out more about this particular message type, using the <code>ros2 interface show</code> command: </p> <pre><code>$ ros2 interface show geometry_msgs/msg/Twist\n# This expresses velocity in free space broken into its linear and angular parts.\n\nVector3  linear\n        float64 x\n        float64 y\n        float64 z\nVector3  angular\n        float64 x\n        float64 y\n        float64 z\n</code></pre> <p>There are six \"fields\" that we can assign values to here: </p> <ol> <li><code>linear</code>: <code>x</code>, <code>y</code> &amp; <code>z</code></li> <li><code>angular</code>: <code>x</code>, <code>y</code> &amp; <code>z</code></li> </ol> <p>These relate to a robot's six degrees of freedom (about its three principal axes), as we discussed above. These topic messages are therefore formatted to give a ROS Programmer the ability to ask a robot to move in any one of its six DOFs. </p> <pre><code>Vector3  linear\n        float64 x  &lt;-- Forwards (or Backwards)\n        float64 y  &lt;-- Left (or Right)\n        float64 z  &lt;-- Up (or Down)\nVector3  angular\n        float64 x  &lt;-- Roll\n        float64 y  &lt;-- Pitch\n        float64 z  &lt;-- Yaw\n</code></pre> <p>As we also learnt above though, our Waffle Robots can only actually move with linear velocity in the x-axis and angular velocity in the z-axis. As a result then, only velocity commands issued to the <code>linear.x</code> (Forwards/Backwards) or <code>angular.z</code> (Yaw) parts of this message will have any effect.</p>"},{"location":"labs/assignment1/part2/#robot-odometry","title":"Robot Odometry","text":"<p>Let's take another look at all the topics that can be used to communicate with our robot:</p> <pre><code>ros2 topic list\n</code></pre> <p>Another topic of interest here is <code>/odom</code>. This topic contains Odometry data, which is also essential for robot navigation, giving us an approximation of a robot's location in its environment.</p>"},{"location":"labs/assignment1/part2/#odometry","title":"What is Odometry?","text":"<p>We can learn more about Odometry data in ROS by using some of the same key ROS command line tools that we have already used previously (just applied to a different topic or message):</p> <p>TERMINAL 2: <pre><code>ros2 topic info /odom\n</code></pre></p> <p>This provides information about the type of message used by this topic:</p> <pre><code>Type: nav_msgs/msg/Odometry\n</code></pre> <p>We can find out more about this message using the <code>ros2 interface show</code> command:</p> <p>TERMINAL 2: <pre><code>ros2 interface show nav_msgs/msg/Odometry\n</code></pre></p> <p>The output of this is quite complicated, but - to start with - we can look down the far left-hand side to identify the four base fields of the message (i.e. the fields that are not indented):</p> <p> # Field Name Field Type 1 <code>header</code> <code>std_msgs/Header</code> 2 <code>child_frame_id</code> <code>string</code> 3 <code>pose</code> <code>geometry_msgs/PoseWithCovariance</code> 4 <code>twist</code> <code>geometry_msgs/TwistWithCovariance</code> <p></p> <p>We won't worry to much about the first two, it's Items 3 and 4 that are of most interest to us...</p>"},{"location":"labs/assignment1/part2/#pose","title":"Pose","text":"<pre><code># Estimated pose that is typically relative to a fixed world frame.\ngeometry_msgs/PoseWithCovariance pose\n        Pose pose\n                Point position\n                        float64 x\n                        float64 y\n                        float64 z\n                Quaternion orientation\n                        float64 x\n                        float64 y\n                        float64 z\n                        float64 w\n        float64[36] covariance\n</code></pre> <p>Pose tells us the position and orientation of our robot relative to an arbitrary reference point (typically where the robot was when it was turned on). The pose is determined from:</p> <ul> <li>Data from the Inertial Measurement Unit (IMU) on the OpenCR board</li> <li>Data from both the left and right wheel encoders</li> <li>A kinematic model of the robot</li> </ul> <p>All the above information can then be used to calculate (and keep track of) the distance travelled by the robot from its pre-defined reference point (using a process called dead-reckoning).</p> <p>Position data is important for determining the movement of our robot, and from this we can estimate its location in 3-dimensional space. This is expressed in units of meters.</p> <p></p> <p>Orientation is expressed in units of Quaternions, which is a mathematically convenient way to store data related to a robot's orientation, but it's a bit hard for us humans to understand and visualise<sup>1</sup>.</p> <p>Quaternions use four values to represent the orientation of something in 3 dimensional space, as we can observe from the structure of the <code>nav_msgs/msg/Odometry</code> ROS message:</p> <pre><code>Quaternion orientation\n        float64 x\n        float64 y\n        float64 z\n        float64 w\n</code></pre> <p>For us, it's easier to think about the orientation of our robot in a Euler Angle representation, which tell us the degree of rotation about the three principal axes (as discussed above):</p> <ul> <li><code>\u03b8<sub>x</sub></code>, aka: \"Roll\"</li> <li><code>\u03b8<sub>y</sub></code>, aka: \"Pitch\"</li> <li><code>\u03b8<sub>z</sub></code>, aka: \"Yaw\"</li> </ul> <p>Fortunately, the maths involved in converting between these two orientation formats is fairly straight forward.</p> <p>Recall from earlier however, that our TurtleBot3 can only move in a 2D plane and so, actually, its pose can be fully represented by just 3 terms: <code>x</code>, <code>y</code> &amp; <code>\u03b8<sub>z</sub></code>, where <code>x</code> and <code>y</code> are the 2D coordinates of the robot in the <code>X-Y</code> plane, and <code>\u03b8<sub>z</sub></code> is the angle of the robot about the <code>z</code> (yaw) axis.</p>"},{"location":"labs/assignment1/part2/#twist","title":"Twist","text":"<p>Twist tells us the current linear and angular velocities of the robot, and this data comes directly from the wheel encoders.</p> <p>Once again, all of this data is defined in terms of the principal axes, as illustrated in the figure above.</p>"},{"location":"labs/assignment1/part2/#ex1","title":"Exercise 1: Exploring Odometry Data","text":"<ol> <li> <p>In TERMINAL 2 launch <code>rqt</code>:</p> <p>TERMINAL 2: <pre><code>rqt\n</code></pre></p> </li> <li> <p>From the top menu select <code>Plugins</code> &gt; <code>Topics</code> &gt; <code>Topic Monitor</code></p> <p>Topic Monitor should then present you with a list of active topics which matches the topic list from the <code>ros2 topic list</code> command that you ran earlier.</p> </li> <li> <p>Check the box next to <code>/odom</code> and click the arrow next to it to expand the topic and reveal the four base fields that we talked about earlier.</p> </li> <li> <p>Next, expand the <code>pose</code> &gt; <code>pose</code> &gt; <code>position</code> and <code>orientation</code> fields to reveal the data being published to the three position and four orientation values of this message.</p> </li> <li> <p>Also expand the <code>twist</code> &gt; <code>twist</code>, <code>linear</code> and <code>angular</code> fields to reveal the six values being published here too.</p> <p> </p> </li> <li> <p>Next, launch a new terminal instance, we'll call this one TERMINAL 3. Arrange this next to the <code>rqt</code> window, so that you can see them both simultaneously.</p> </li> <li> <p>In TERMINAL 3 launch the <code>teleop_keyboard</code> node as you did last time (TODO: link to part 1): </p> <p>TERMINAL 3: <pre><code>ros2 run turtlebot3_teleop teleop_keyboard\n</code></pre></p> </li> <li> <p>Enter A a couple of times to make the robot rotate on the spot. Observe how the odometry data changes in the Topic Monitor.</p> <p>Questions</p> <ol> <li>Which <code>pose</code> fields are changing?</li> <li>Is there anything in the <code>twist</code> part of the message that corresponds to the <code>angular velocity</code> that is being published by the <code>teleop_keyboard</code> node in TERMINAL 3? </li> </ol> </li> <li> <p>Now press the S key to halt the robot, then press W a couple of times to make the robot drive forwards.</p> <p>Questions</p> <ol> <li>Which <code>pose</code> fields are changing now? How does this relate to the position of the robot in the simulated world?</li> <li>How does the <code>twist</code> part of the message now correspond to the <code>linear velocity</code> setting in TERMINAL 3?</li> </ol> </li> <li> <p>Now press D a couple of times and your robot should start to move in a circle.</p> <p>Questions</p> <ol> <li>What linear and angular velocities are you requesting in TERMINAL 3, and how are these represented in the <code>twist</code> part of the <code>/odom</code> message?</li> <li>What about the <code>pose</code> part of the message? How is this data changing as your robot moves in a circular path.</li> <li>What are <code>twist</code> and <code>pose</code> actually telling us?</li> </ol> </li> <li> <p>Press S in TERMINAL 3 to stop the robot (but leave the <code>teleop_keyboard</code> node running).  Then, press Ctrl+C in TERMINAL 2 to close down <code>rqt</code>. </p> </li> <li> <p>Let's look at the Odometry data in a different way now. With the robot stationary, use <code>ros2 run</code> to run a Python node that we have created to illustrate just the <code>pose</code> data, and how it relates to the robot's position and orientation in its environment: </p> <p>TERMINAL 2: <pre><code>ros2 run tuos_examples robot_pose\n</code></pre></p> </li> <li> <p>Now (using the <code>teleop_keyboard</code> node in TERMINAL 3) drive your robot around again, keeping an eye on the outputs that are being printed by the <code>robot_pose</code> node in TERMINAL 2 as you do so.</p> <p>The output of the <code>robot_pose</code> node shows you how the robot's position and orientation (i.e. \"pose\") are changing in real-time as you move the robot around. The <code>\"initial\"</code> column tells us the robot's pose when the node was first launched, and the <code>\"current\"</code> column show us what its pose currently is. The <code>\"delta\"</code> column then shows the difference between the two.</p> <p>Question</p> <p>Which pose parameters haven't changed, and is this what you would expect (considering the robot's principal axes, as illustrated above)?</p> </li> <li> <p>Press Ctrl+C in TERMINAL 2 and TERMINAL 3, to stop the <code>robot_pose</code> and <code>teleop_keyboard</code> nodes. </p> </li> </ol>"},{"location":"labs/assignment1/part2/#ex2","title":"Exercise 2: Creating a Python node to process Odometry data","text":"<p>In Part 1 you learnt how to create a package and build simple nodes in Python to publish and subscribe to messages on a topic. In this exercise you will build a new subscriber node, much like you did in the previous session, but this one will subscribe to the <code>/odom</code> topic that we've been talking about above. You'll also create a new package called <code>part2_navigation</code> for this node to live in!</p> <ol> <li> <p>First, make sure you are in the <code>src</code> folder of the <code>ros2_ws</code> in your terminal:</p> <pre><code>cd ~/ros2_ws/src/\n</code></pre> </li> <li> <p>Next, use the <code>ros2 pkg</code> tool to create your package:</p> <pre><code>ros2 pkg create --build-type ament_python part2_navigation\n</code></pre> </li> <li> <p>Then navigate into the <code>ros2_ws/src/part2_navigation/part2_navigation</code> folder using the <code>cd</code> command again. For Python packages, this is where all executables (i.e. Python files) should be located.</p> <p>The subscriber that we will build here will be structured in much the same way as the subscriber that we built in Part 1. The difference now though is that this one will subscribe to the <code>/odom</code> topic (instead of <code>/chatter</code> (TODO: confirm topic message in Part 1)), and its callback function will therefore receive <code>Odometry</code> type messages (instead of <code>String</code> (TODO: confirm)), so we'll have to deal with those a bit differently. We've created a template for this to help you to get started. Download this from GitHub using the <code>wget</code> command:</p> <p><pre><code>wget -O odom_subscriber.py \\\nhttps://raw.githubusercontent.com/tom-howard/tuos_ros/humble/tuos_examples/tuos_examples/odom_subscriber_template.py\n</code></pre> (TODO: update to \"main\" once available)</p> </li> <li> <p>Next, add some dependencies to your package's <code>package.xml</code> file, above the <code>&lt;test_depend&gt;</code> lines that should already be there:</p> <pre><code>&lt;exec_depend&gt;rclpy&lt;/exec_depend&gt;\n&lt;exec_depend&gt;nav_msgs&lt;/exec_depend&gt;\n\n&lt;test_depend&gt;ament_copyright&lt;/test_depend&gt;\n&lt;test_depend&gt;ament_flake8&lt;/test_depend&gt;\n&lt;test_depend&gt;ament_pep257&lt;/test_depend&gt;\n&lt;test_depend&gt;python3-pytest&lt;/test_depend&gt;\n</code></pre> </li> <li> <p>Then open up the <code>setup.py</code> file and add an entry point for the <code>odom_subscriber</code> node:</p> <pre><code>entry_points={\n    'console_scripts': [\n        'odom_subscriber = part2_navigation.odom_subscriber:main',\n    ]\n}\n</code></pre> </li> <li> <p>Finally, head back to the terminal and use Colon to build your new package and it's executable:</p> <pre><code>cd ~/ros2_ws/ &amp;&amp; colcon build --packages-select part2_navigation --symlink-install\n</code></pre> </li> <li> <p>Now we're ready to run this! Do so using <code>ros2 run</code> and see what it does:</p> <pre><code>ros2 run part2_navigation odom_subscriber\n</code></pre> </li> <li> <p>Have a think about what's different between this and the subscriber from last time...</p> <p>In the Subscriber from Part 1 we were working with a <code>String</code> type message from the <code>std_msgs</code> package, whereas this time we're using an <code>Odometry</code> message from the <code>nav_msgs</code> package instead - notice how the imports and the callback function have changed as a result of this.</p> </li> <li> <p>You need to add some additional code to the callback function now: </p> <ol> <li>The node needs to print the robot's real-time odometry data to the terminal in the form: <code>(x,y,\u03b8<sub>z</sub>)</code>.</li> <li>The format of the message has already been structured for you, but you need to add in the relevant variables that represent the correct elements of the robot's real-time pose.</li> <li>You'll need to use the <code>euler_from_quaternion</code> function (defined within the script) to convert the raw orientation values from Quaternions into Radians. If you need a hint, why not have a look back at this bit from earlier, or at the source code for the <code>robot_pose.py</code> node that we launched from the <code>tuos_examples</code> package in the previous exercise. </li> </ol> </li> <li> <p>Observe how the output (the formatted odometry data) changes whilst you move the robot around using the <code>teleop_keyboard</code> node in a new terminal instance (TERMINAL 3).</p> </li> <li>Stop your <code>odom_subscriber.py</code> node in TERMINAL 2 and the <code>teleop_keyboard</code> node in TERMINAL 3 by entering Ctrl+C in each of the terminals.</li> </ol>"},{"location":"labs/assignment1/part2/#basic-navigation-open-loop-velocity-control","title":"Basic Navigation: Open-loop Velocity Control","text":""},{"location":"labs/assignment1/part2/#ex3","title":"Exercise 3: Velocity Control from a Terminal","text":"<p>Warning</p> <p>Make sure that you've stopped the <code>teleop_keyboard</code> node before starting this exercise!</p> <p>We can use the <code>ros2 topic pub</code> command to publish data to a topic from a terminal by using the command in the following way:</p> <pre><code>ros2 topic pub {topic_name} {message_type} {message_data}\n</code></pre> <p>As we discovered earlier, the <code>/cmd_vel</code> topic is expecting messages containing linear and angular velocity data, each with an <code>x</code>, <code>y</code> and <code>z</code> component. When publishing topic messages in a terminal the commands can get quite long and complicated, but we can use autocomplete functionality to help us format the full command correctly. In TERMINAL 3 type the following, using the Tab key where indicated to invoke autocompletion...</p> <p>TERMINAL 3:</p> <p>First, press Tab to complete the topic name for you:</p> <pre><code>ros2 topic pub /cmd_[TAB]\n</code></pre> <p>Then, press Tab to format the message type correctly: </p> <pre><code>ros2 topic pub /cmd_vel g[TAB]\n</code></pre> <p>Finally, press Tab again to obtain the format of the message data:</p> <pre><code>ros2 topic pub /cmd_vel geometry_msgs/msg/Twist \"l[TAB]\n</code></pre> <p>The full command will then be presented:</p> <pre><code>ros2 topic pub /cmd_vel geometry_msgs/msg/Twist \"linear:\n  x: 0.0\n  y: 0.0\n  z: 0.0\nangular:\n  x: 0.0\n  y: 0.0\n  z: 0.0\"\n</code></pre> <p>Tip</p> <p>You can use Tab to autocomplete lots of terminal commands, experiment with it - it'll save you lots of time! </p> <ol> <li> <p>Scroll back through the message using the Left key on your keyboard and then edit the values of the various parameters, as appropriate. First, define some values that would make the robot rotate on the spot.  </p> </li> <li> <p>Enter Ctrl+C in TERMINAL 3 to stop the message from being published.</p> <p>Warning</p> <p>What happens to the robot when you stop the <code>ros2 topic pub</code> command?</p> <p>... it keeps on moving at the requested velocity!</p> <p>In order to make the robot actually stop, we need to publish a new message containing alternative velocity commands.</p> </li> <li> <p>In TERMINAL 3 press the Up key on your keyboard to recall the previous command, but don't press Enter just yet! Now press the Left key to track back through the message and change the velocity values in order to now make the robot stop.</p> </li> <li> <p>Once again, enter Ctrl+C in TERMINAL 3 to stop the publisher from actively publishing new messages, and then follow the same steps as above to compose another new message to now make the robot move in a circle.</p> </li> <li> <p>Enter Ctrl+C to again stop the message from being published, publish a further new message to stop the robot, and then compose (and publish) a message that would make the robot drive in a straight line.</p> </li> <li> <p>Finally, stop the robot again!</p> </li> </ol>"},{"location":"labs/assignment1/part2/#ex4","title":"Exercise 4: Creating a Python node to make the robot move in a circle","text":"<p>You will now learn how to control the velocity of the robot through a Python Node. In Pat 1 you built a simple publisher node, and this one will effectively be the same thing, this time however, we need to publish <code>Twist</code> type messages to the <code>/cmd_vel</code> topic instead... </p> <p>In TERMINAL 2, ensure that you're located within the <code>scripts</code> folder of your <code>part2_navigation</code> package (you could use <code>pwd</code> to check your current working directory).</p> <p>If you aren't located here then navigate to this directory using <code>cd</code>.</p> <ol> <li> <p>Create a new file called <code>move_circle.py</code>:</p> <p>TERMINAL 2: <pre><code>touch move_circle.py\n</code></pre> ... and make this file executable using the <code>chmod</code> command.</p> </li> <li> <p>Open up this file in VS Code. </p> <p>Use this code template to get you started:</p> A template for the move_circle.py node<pre><code>#!/usr/bin/env python3\n\nimport rclpy # (1)\nfrom rclpy.node import Node\n\n# (2)\n\nclass Circle(Node):\n\n    def __init__(self):\n        super().__init__(\"\") # (3)\n\n        self.publisher = self.create_publisher() # (4)\n        rate = # (5)\n        self.timer = self.create_timer(1/rate, self.timer_callback)\n\n        self.shutdown = False\n\n    def on_shutdown(self):\n        # (6)\n\n        self.shutdown = True\n\n    def timer_callback(self):\n        # (7)\n\ndef main(args=None):\n    rclpy.init(\n        args=args,\n        signal_handler_options=rclpy.signals.SignalHandlerOptions.NO\n    )\n\n    move_circle = # (8)\n\n    try: # (9)\n        rclpy.spin(move_circle)\n    except KeyboardInterrupt:\n        print(\"Shutdown requested with Ctrl+C\")\n    finally:\n        move_circle.on_shutdown()\n\n        while not move_circle.shutdown:\n            continue\n\n        move_circle.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n</code></pre> <ol> <li>This is important, we always need to import the ROS Client Library for Python (<code>rclpy</code>), plus a <code>Node</code> class (to use as the basis for you own ROS node).</li> <li>What other imports might we need here in order to create and publish a message to make the robot move?</li> <li>Give your node a descriptive name - this is the name that it will be given when it is registered on the ROS network, and the one that you would see if you used the <code>ros2 node list</code> command.</li> <li>What do you need to add here in order to set up an appropriate publisher to the <code>/cmd_vel</code> topic?</li> <li>Define an appropriate rate at which to publish velocity messages, and use this to set up a timer.</li> <li> <p>We'll use this to perform some important shutdown operations after a user has requested for the node to stop (using Ctrl+C), but before it actually does so. </p> <p>Question</p> <p>What actions would be important to take here to make sure the node shuts down safely and the robot actually stops moving?</p> <p>We'll call this method from <code>main()</code> before ultimately terminating the node (see later on in the code).</p> </li> <li> <p>You're going to need to create a message here containing appropriate velocities for the robot to move at. Then you'll need to actually publish that message to <code>/cmd_vel</code> (via your <code>self.publisher</code>). Running this inside a timer callback means that it will execute the rate that we specified in the <code>__init__</code></p> </li> <li> <p>What will you need to do here to instantiate your <code>Circle()</code> class?</p> </li> <li> <p>We call <code>rclpy.spin()</code> inside a Try - Except block, so that we can catch a <code>KeyboardInterrupt</code> (i.e. a Ctrl+C input from the user) during execution of the node. All shutdown procedures are executed from within a <code>finally</code> block, which ensures that all of these vital steps take place when an exception is raised (whether that's a <code>KeyboardInterrupt</code> or otherwise).</p> </li> </ol> </li> </ol> <ol> <li> <p>Quaternions are explained very nicely here, if you'd like to learn more.\u00a0\u21a9</p> </li> </ol>"},{"location":"labs/assignment1/part3/","title":"Part 3: SLAM and Autonomous Navigation","text":""},{"location":"labs/assignment1/part3/#introduction","title":"Introduction","text":"<p> Exercises: X</p> <p> Estimated Completion Time: Y</p>"},{"location":"labs/assignment1/part3/#aims","title":"Aims","text":"<p>From the work you did in Part 2 you may have started to appreciate the limitations associated with using odometry data alone as a feedback signal when trying to control a robot's position in its environment. In this next part you will explore an alternative data-stream that could be used to aid navigation further. You will leverage some existing ROS 2 libraries and TurtleBot3 packages to explore some really powerful mapping and autonomous navigation methods that are available within ROS.</p>"},{"location":"labs/assignment1/part3/#intended-learning-outcomes","title":"Intended Learning Outcomes","text":"<p>By the end of this session you will be able to:</p> <p>//add to the ILOs// </p> <ol> <li>Interpret the data that is published to the <code>/scan</code> topic and use existing ROS tools to visualise this.</li> <li>Use existing ROS tools to implement SLAM and build a map of an environment. </li> <li>Leverage existing ROS libraries to make a robot navigate an environment autonomously, using the map that you have generated.</li> <li>Explain how these SLAM and Navigation tools are implemented and what information is required in order to make them work.</li> </ol>"},{"location":"labs/assignment1/part3/#quick-links","title":"Quick Links","text":"<ul> <li>Exercise 1: Using RViz to Visualise Robot Data</li> <li>Exercise 2: Building a map of an environment with SLAM</li> <li>Exercise 3: Navigating an Environment Autonomously</li> </ul>"},{"location":"labs/assignment1/part3/#getting-started","title":"Getting Started","text":"<p>Step 1: Launch your ROS Environment</p> <p>If you haven't done so already, launch your ROS environment now:</p> <ol> <li>Option 1 </li> <li>Option 2</li> <li>Option 3</li> </ol> <p>Step 2: Make Sure The Course Repo is Up-To-Date</p> <p>In Part 1 you should have downloaded and installed The Course Repo into your ROS environment. Hopefully you've done this by now, but if you haven't then go back and do it now (you'll need it for some exercises here). If you have already done it, then (once again) it's worth just making sure it's all up-to-date, so run the following command now to do so:</p> <p>TERMINAL 1: <pre><code>cd ~/ros2_ws/src/tuos_ros/ &amp;&amp; git pull\n</code></pre></p> <p>Then build with Colcon: </p> <pre><code>cd ~/ros2_ws/ &amp;&amp; colcon build\n</code></pre> <p>And finally, re-source your environment:</p> <pre><code>source ~/.bashrc\n</code></pre> <p>Warning</p> <p>If you have any other terminal instances open, then you'll need run <code>source ~/.bashrc</code> in these too, in order for any changes made by the Colcon build process to propagate through to these as well.</p>"},{"location":"labs/assignment1/part3/#lidar","title":"Laser Displacement Data and The LiDAR Sensor","text":"<p>As you'll know from Part 2, odometry is really important for robot navigation, but it can be subject to drift and accumulated error over time.</p>"},{"location":"labs/assignment1/part3/#ex1","title":"Exercise 1: Using RViz to Visualise Robot Data","text":"<p>We're now going to place the robot in a more interesting environment than the \"empty world\" we've used in the previous parts of this course so far...</p> <ol> <li> <p>In TERMINAL 1 enter the following command to launch this:</p> <p>//need to check// <pre><code>ros2 launch turtlebot3_gazebo x.launch.py\n</code></pre> A Gazebo simulation should now be launched with a TurtleBot3 Waffle in a new environment:</p> </li> <li> <p>Open a new terminal instance (TERMINAL 2) and enter the following:</p> <p>TERMINAL 2: <pre><code>ros2 launch tuos_simulations rviz.launch launch\n</code></pre></p> <p>On running the command a new window should open:</p> <p>This is RViz, which is a ROS tool that allows us to visualise the data being measured by a robot in real-time. The red dots scattered around the robot represent laser displacement data which is measured by the LiDAR sensor located on the top of the robot.  This data allows the robot to measure the distance to any obstacles in its immediate surroundings. The LiDAR sensor spins continuously, sending out laser pulses as it does so. These laser pulses then bounce off any objects and are reflected back to the sensor. Distance can then be determined based on the time it takes for the pulses to complete the full journey (from the sensor, to the object, and back again), by a process called \"time of flight\". Because the LiDAR sensor spins and performs this process continuously, a full 360\u00b0 scan of the environment can be generated.  In this case (because we are working in simulation here) the data represents the objects surrounding the robot in its simulated environment, so you should notice that the red dots produce an outline that resembles the objects in the world that is being simulated in Gazebo (or partially at least).</p> </li> </ol>"},{"location":"labs/assignment1/part4/","title":"Part 4: ROS 2 Services","text":""},{"location":"labs/assignment1/part4/#introduction","title":"Introduction","text":"<p> Exercises: X</p> <p> Estimated Completion Time: Y hours</p>"},{"location":"labs/assignment1/part4/#aims","title":"Aims","text":"<p>In this part you will learn about ROS Services, a communication method that facilitates request-response interactions between nodes. You will understand how to use ROS services in combination with standard publisher/subscriber principles to enhance control for specific operations. Additionally, you'll create custom messages and services for tailored communication.</p>"},{"location":"labs/assignment1/part4/#intended-learning-outcomes","title":"Intended Learning Outcomes","text":"<p>By the end of this session you will be able to:</p> <ol> <li>Recognise how ROS Services differ from the standard topic-based publisher-subscriber approach, and identify appropriate use-cases for this type of messaging system.</li> <li>Implement Python node pairs to observe services in action, and understand how they work.</li> <li>Invoke different services using a range of service message types.</li> <li>Develop Python Service nodes of your own to perform specific robotic tasks.</li> <li>Harness Services, in combination with LiDAR data, to implement a basic obstacle avoidance behaviour </li> <li>Develop custom ROS messages and services (still need to think about the task for this) </li> <li>Demonstrate your understanding of ROS2 so far by developing a Python node which incorporates elements from this and previous parts of this course.</li> </ol>"},{"location":"labs/assignment1/part4/#quick-links","title":"Quick Links","text":"<ul> <li>Exercise 1: </li> </ul>"},{"location":"labs/assignment1/part4/#additional-resources","title":"Additional Resources","text":""},{"location":"labs/assignment1/part4/#prerequisites","title":"Prerequisites","text":"<p>Before we begin, ensure that you have the following:</p> <ol> <li>ROS2 Humble installed on your system</li> <li>Cloned the tuos package from github</li> <li>Basic understanding of ROS2 concepts like nodes and topics</li> </ol>"},{"location":"labs/assignment1/part4/#getting-started","title":"Getting Started","text":"<p>Step 1: Launch your ROS Environment</p> <p>If you haven't done so already, launch your ROS environment now:</p> <p>Step 2: Restore your work (todo)</p> <p>Step 3: Launch VS Code (todo) </p> <p>Step 4: Make Sure The Course Repo is Up-To-Date</p> <p>Once again, it's worth quickly checking that the Course Repo is up-to-date before you start on the Part 4 exercises. Go back to Part 1 if you haven't installed it yet (really?!). For the rest of us, see here for how to update.</p> <p>Step 5: Launch the Robot Simulation</p> <p>In TERMINAL 1 enter the following command to launch a simulation of a TurtleBot3 Waffle in an empty world:  </p> <p>TERMINAL 1: <pre><code>ros2 launch turtlebot3_gazebo empty_world.launch.py\n</code></pre> ...and then wait for the Gazebo window to open:</p> <p>have to add an image here</p>"},{"location":"labs/assignment1/part4/#an-introduction-to-services","title":"An Introduction to Services","text":"<p>So far, we've learnt about ROS topics and messages, and how individual nodes can access data on a robot by simply subscribing to topics that are being published by any other node on the system.  In addition to this, we also learnt how any node can publish messages to any topic: this essentially broadcasts the data contained in the message across the ROS Network, making it available to any other node on the network that may wish to access it.</p> <p>Another way to pass data between ROS Nodes is by using Services.  These are different to messages in that \"Service calls\" (that is, the process of requesting a service) occur only between one node and another:</p> <ul> <li>One node (a Service Client) sends a Request to another node.</li> <li>Another node (a Service Server) processes that request, performs an action and then sends back a Response.</li> </ul> <p></p> <p>Services are Synchronous (or sequential): When a ROS node sends a request to a service (as a Service Client) it can't do anything else until the service has been completed and the Service Server has sent a response back. This can be useful for a few reasons:</p> <ol> <li> <p>Discrete, short-duration actions: A robot might need to do something before it can move on to something else, e.g.:</p> <ul> <li>A robot needs to see something before it can move towards it.</li> <li>High definition cameras generate large amounts of data and consume battery power, so you may wish to turn a camera on for a specific amount of time (e.g. until an image has been captured) and then turn it off again.</li> </ul> </li> <li> <p>Computations: Remember that ROS is network-based, so you might want to offload some computations to a remote computer or a different device on a robot, e.g.:</p> <ul> <li>A client might send some data and then wait for another process (the server) to process it and send back the result.</li> </ul> </li> </ol> <p>It's also worth noting that any number of ROS Client nodes can call a service, but you can only have a single Server providing that particular service at any one time.</p> <p></p> <p>Question</p> <p>Can you think of any other scenarios where this type of communication protocol might be useful?</p>"},{"location":"labs/assignment1/part4/#ex1","title":"Exercise 1: Creating a Service Server in Python and calling it from the command-line","text":"<p>To start with, let's set up a service and learn how to make a call to it from the command-line to give you an idea of how this all works and why it might be useful.</p> <ol> <li> <p>First open up a new terminal instance (TERMINAL 2) and source your ROS2 environment as you did in part 1.</p> </li> <li> <p>Now navigate into the <code>ros2_ws/src</code> directory created in part 1 and create the <code>part4_services</code> package. Define <code>python</code> as a build type and <code>rclpy</code>, <code>geometry_msgs</code> and <code>tuos_msgs</code> as dependencies.</p> <p>TERMINAL 2: <pre><code>ros2 pkg create --build-type ament_cmake \n</code></pre></p> <p>Your terminal will return a message verifying the creation of your package.</p> <p>The <code>--dependencies</code> argument adds the necessary dependency lines to the <code>package.xml</code> file</p> <p>Info</p> <p><code>rclpy</code> is the Python library that provides the core functionality for interacting with ROS 2. It's the Python counterpart to the C++ client library, <code>rclcpp</code>.</p> </li> <li> <p>Then navigate into the <code>ros2_ws/src/part4_services/part4_services</code> and create an empty file called <code>move_server.py</code> using <code>touch</code> command.     <pre><code>touch move_server.py\n</code></pre></p> </li> <li> <p>Then, open the file in VS Code, copy and paste this code and then save it.  (todo: need to add the template)</p> <p>Note</p> <p>It's really important that you understand how the code above works, so that you know how to build your own service Servers in Python.</p> </li> <li> <p>Updating the package.xml file (todo)</p> </li> <li> <p>Next, open the setup.py file in your package directory and add an entry point for the <code>move_server</code> node:</p> <pre><code>entry_points={\n    'console_scripts': [\n        'move_server = part4_services.move_server:main',\n    ]\n}\n</code></pre> <p>Build and run:</p> </li> <li> <p>It's a good practice to run <code>rosdep</code> in the root of your workspace (<code>ros2_ws</code>) to check for missing dependencies before building:</p> <pre><code>rosdep install -i --from-path src --rosdistro humble -y\n</code></pre> </li> <li> <p>Finally, use Colcon to build your new package and its contents </p> <pre><code>cd ~/ros2_ws/ &amp;&amp; colcon build --packages-select part4_services --symlink-install\n</code></pre> </li> <li> <p>Now, we are ready to run the node. Use <code>ros2 run</code> and observe what is displayed on the terminal </p> <pre><code>ros2 run part4_services move_server\n</code></pre> </li> <li> <p>Then open another terminal window (TERMINAL 3) and source the setup files from inside the root directory again. </p> </li> <li> <p>While the node is running, use <code>ros2 service</code> command to view all the currently active services on the system:</p> <p>TERMINAL 3: <pre><code>ros2 service list\n</code></pre></p> <p>You should be able to see the service (todo)</p> </li> </ol>"},{"location":"labs/assignment1/part4/#ex2","title":"Exercise 2: Creating a Python Service Client Node","text":"<p>As well as calling a service from the command-line we can also build Python nodes to do the same thing (i.e. we can build Python Service Client Nodes). In this exercise you will learn how this is done.</p> <ol> <li> <p>TERMINAL 3 should be idle, so from here navigate to the <code>part4_service/</code> folder within the <code>part4_services</code> package that we created earlier:</p> <p>TERMINAL 3: <pre><code>cd ~/ros2_ws/src/part4_service/part4_services\n</code></pre></p> <ol> <li>Create a new file called <code>move_client.py</code></li> <li>Now as you did in the previous exercise, open the VS Code, copy and paste this code and then save it.  (todo: need to add the template)</li> </ol> <p>Note</p> <p>Once again, be sure to read the code and understand how this Python Service Client Node works too!</p> </li> <li> <p>Next, open the setup.py file (in VS Code) in your package directory and add another entry point for the <code>move_client</code> under the line where you added <code>move_server</code> previously:</p> <pre><code>entry_points={\n    'console_scripts': [\n        'move_server = part4_services.move_server:main',\n        'move_client = part4_services.move_client:main',\n    ]\n}\n</code></pre> </li> <li> <p>Return to TERMINAL 3 and launch the node using <code>ros2 run</code>:</p> <pre><code>ros2 run part4_services move_client\n</code></pre> </li> </ol> <p>TODO : ROS2 service call and creating a custom .msg and .srv</p> <p>Understanding key features  todo: ros2 service type     ros2 service find     ros2 interface show     ros2 service call</p>"},{"location":"labs/assignment1/part4/#ex3","title":"Exercise 3: Learn to create custom messages and service","text":""},{"location":"labs/assignment1/part4/#ex4","title":"Exercise 4: Creating your own Service","text":"<p>In this exercise you will create your own service Server to make the Waffle perform a specific movement for a given amount of time and then stop.</p>"},{"location":"labs/assignment1/part1/publisher/","title":"A Simple Publisher Node","text":""},{"location":"labs/assignment1/part1/publisher/#the-code","title":"The Code","text":"<p>Copy all the code below into your <code>publisher.py</code> file and review the annotations to understand how it all works.</p> <p>Tip</p> <p>Don't forget the Shebang! See below for further details...</p> publisher.py<pre><code>#!/usr/bin/env python3\n# A simple ROS2 Publisher\n\nimport rclpy # (1)!\nfrom rclpy.node import Node\n\nfrom std_msgs.msg import String # (2)!\n\nclass SimplePublisher(Node): # (3)!\n\n    def __init__(self):\n        super().__init__(\"simple_publisher\") # (4)!\n\n        self.my_publisher = self.create_publisher(\n            msg_type=String,\n            topic=\"my_topic\",\n            qos_profile=10,\n        ) # (5)!\n\n        publish_rate = 1 # Hz\n        self.timer = self.create_timer(\n            timer_period_sec=1/publish_rate, \n            callback=self.timer_callback\n        ) # (6)!\n\n        self.get_logger().info(\n            f\"The '{self.get_name()}' node is initialised.\" # (7)!\n        )\n\n    def timer_callback(self): # (8)!\n        ros_time = self.get_clock().now().seconds_nanoseconds()\n\n        topic_msg = String()\n        topic_msg.data = f\"The ROS time is {ros_time[0]} (seconds).\"\n        self.my_publisher.publish(topic_msg)\n        self.get_logger().info(f\"Publishing: '{topic_msg.data}'\")\n\ndef main(args=None): # (9)!\n    rclpy.init(args=args)\n    my_simple_publisher = SimplePublisher()\n    rclpy.spin(my_simple_publisher)\n    my_simple_publisher.destroy_node()\n    rclpy.shutdown()\n\nif __name__ == '__main__': # (10)!\n    main()\n</code></pre> <ol> <li> <p><code>rclpy</code> is the ROS Client Library for Python. </p> <p>This is a vital import that allows us to create ROS nodes and initialise them on the ROS network.</p> <p>We also import the <code>Node</code> class from the <code>rclpy.node</code> library. This is a ready-made Python Class that contains all the necessary functionality that a Python ROS Node might need, so we'll use this as the basis for our own node (which we'll create shortly).</p> </li> <li> <p>We also need to import the <code>String</code> message type from the <code>std_msgs.msg</code> library for publishing our messages.</p> </li> <li> <p>We create a Python class called <code>SimplePublisher()</code>, which we'll use to encapsulate all the functionality of our node.</p> <p>The vast majority of the functionality of this node is inherited from the <code>rclpy.node</code>, <code>Node()</code> Class which we imported above. </p> </li> <li> <p>Using the <code>super()</code> method we call the <code>__init__()</code> method from the parent Node class that our <code>SimplePublisher</code> class is derived from.</p> <p>We provide a name here, which is the name that will be used to register our node on the ROS network (we can call the node anything that we want, but it's a good idea to call it something meaningful).</p> </li> <li> <p>We then use the <code>create_publisher()</code> method (inherited from the <code>Node</code> class) in order to provide our node with the ability to publish messages to a ROS Topic. When calling this we provide 3 key bits of information:</p> <ol> <li> <p><code>msg_type</code>: The type of message that we want to publish.</p> <p>In our case, a <code>String</code> message from the <code>std_msgs.msg</code> module.</p> </li> <li> <p><code>topic</code>: The name of the topic that we want to publish these messages to.</p> <p>This could be an existing topic (in which case, we'd need to make sure we used the correct message type), or a new topic (in which case, the name can be anything we want it to be).</p> <p>In our case, we want to create a new topic on the ROS network called <code>\"my_topic\"</code>.</p> </li> <li> <p><code>qos_profile</code>: A queue size, which is a \"Quality of Service\" (QoS) setting which limits the amount of messages that are queued in a buffer. </p> <p>In our case, we're setting this to <code>10</code>, which is generally appropriate for most of the applications that we'll be working on.</p> </li> </ol> </li> <li> <p>Here, we're calling the <code>create_timer()</code> method, which we'll use to control the rate at which messages are published to our topic. Here we define 2 things:</p> <ol> <li> <p><code>timer_period_sec</code>: The rate at which we want the timer to run. This must be provided as a period, in seconds. In the line above, we have specified a publishing frequency (in Hz):</p> <p><code>publish_rate = 1 # Hz</code></p> <p>So the associated time period (in seconds) is: </p> <p>\\(T = \\frac{1}{f}\\)</p> </li> <li> <p><code>callback</code>: This is a function that will be executed every time the timer elapses at the desired rate (1 Hz). We're specifying a function called <code>timer_callback</code>, which we'll define later on in the code...</p> </li> </ol> </li> <li> <p>Finally, we use the <code>get_logger().info()</code> method to send a Log message to the terminal to inform us that the initialisation of our node is complete.</p> </li> <li> <p>Here we define the timer callback function. Anything in here will execute at the rate that we specified when we created the <code>create_timer()</code> instance before. In our case:</p> <ol> <li>Use the <code>get_clock()</code> method to get the current ROS Time.</li> <li>Instantiate a <code>String()</code> message (defined as <code>topic_msg</code>).</li> <li>Populate this message with data. In our case, a statement that includes the ROS Time, as obtained above.</li> <li>Call the <code>publish()</code> method of our <code>my_publisher</code> object, to actually publish this message to the <code>\"my_topic\"</code> topic.</li> <li>Send the message data to the terminal as a log message as well, so that we can see what it is when our Node is actually running.</li> </ol> </li> <li> <p>With the functionality of our <code>SimplePublisher</code> class now established, we define a <code>main()</code> function for the Node. This will be fairly common to most Python Nodes that we create, with the following 5 key processes:</p> <ol> <li>Initialise the <code>rclpy</code> library.</li> <li>Create an instance of our <code>SimplePublisher()</code> node.</li> <li>\"Spin\" the node to keep it alive so that any callbacks can execute as required (in our case here, just the <code>timer_callback()</code>). </li> <li>Destroy the node once termination is requested (triggered by entering Ctrl+C in the terminal).</li> <li>Shutdown the <code>rclpy</code> library.</li> </ol> </li> <li> <p>Finally we call the <code>main()</code> function to set everything going. We do this inside an <code>if</code> statement, to ensure that our node is the main executable (i.e. it has been executed directly (via <code>ros2 run</code>), and hasn't been called by another script)</p> </li> </ol>"},{"location":"labs/assignment1/part1/publisher/#defining-package-dependencies","title":"Defining Package Dependencies","text":"<p>We're importing a couple of Python libraries into our node here, which means that our package has two dependencies: <code>rclpy</code> and <code>std_msgs</code>:</p> <pre><code>import rclpy \nfrom rclpy.node import Node\n\nfrom std_msgs.msg import String\n</code></pre> <p>Its good practice to add these dependencies to your <code>package.xml</code> file. Locate this file (<code>ros2_ws/src/part1_pubsub/package.xml</code>), open it up and find the following lines:</p> <pre><code>&lt;description&gt;TODO: Package description&lt;/description&gt;\n&lt;maintainer email=\"your.name@sheffield.ac.uk\"&gt;Name&lt;/maintainer&gt;\n&lt;license&gt;TODO: License declaration&lt;/license&gt;\n</code></pre> <p>Below this, add the following two execution dependencies (to declare that the package needs these two libraries when your code is run):</p> <pre><code>&lt;exec_depend&gt;rclpy&lt;/exec_depend&gt;\n&lt;exec_depend&gt;std_msgs&lt;/exec_depend&gt;\n</code></pre> <p>Job done. Save the file and close it.</p>"},{"location":"labs/assignment1/part1/publisher/#shebang","title":"The Shebang","text":"<p>The very first line of code looks like a comment, but it is actually a very crucial part of the script:</p> <pre><code>#!/usr/bin/env python3\n</code></pre> <p>This is called the Shebang, and it tells the operating system which interpreter to use to execute the code. In our case here, it tells the operating system where to find the right Python interpreter that should be used to actually run the code.</p> <p> \u2190 Back to Part 1 </p>"},{"location":"labs/assignment1/part1/subscriber/","title":"A Simple Subscriber Node","text":""},{"location":"labs/assignment1/part1/subscriber/#the-code","title":"The Code","text":"<p>Copy all the code below into your <code>subscriber.py</code> file and (again) make sure you read the annotations to understand how it all works!</p> subscriber.py<pre><code>#!/usr/bin/env python3\n# A simple ROS2 Subscriber\n\nimport rclpy # (1)!\nfrom rclpy.node import Node\n\nfrom std_msgs.msg import String\n\nclass SimpleSubscriber(Node): # (2)! \n\n    def __init__(self): \n        super().__init__(\"simple_subscriber\") # (3)!\n\n        self.my_subscriber = self.create_subscription(\n            msg_type=String,\n            topic=\"{BLANK}\",\n            callback=self.msg_callback,\n            qos_profile=10,\n        ) # (4)!\n\n        self.get_logger().info(\n            f\"The '{self.get_name()}' node is initialised.\"\n        ) # (5)!\n\n    def msg_callback(self, topic_message: String): # (6)!\n        # (7)!\n        self.get_logger().info(f\"The '{self.get_name()}' node heard:\") \n        self.get_logger().info(f\"'{topic_message.data}'\")\n\ndef main(args=None): # (8)!\n    rclpy.init(args=args)\n    my_simple_subscriber = SimpleSubscriber()\n    rclpy.spin(my_simple_subscriber)\n    my_simple_subscriber.destroy_node()\n    rclpy.shutdown() \n\nif __name__ == '__main__':\n    main()\n</code></pre> <ol> <li> <p>As with our publisher node, we need to import the <code>rclpy</code> client library and the <code>String</code> message type from the <code>std_msgs.msg</code> library in order to write a Python ROS Node and use the relevant ROS messages:</p> </li> <li> <p>This time, we create a Python Class called <code>SimpleSubscriber()</code> instead, but which still inherits the <code>Node</code> class from <code>rclpy</code> as we did with the Publisher before.</p> </li> <li> <p>Once again, using the <code>super()</code> method we call the <code>__init__()</code> method from the parent Node class that our <code>SimpleSubscriber</code> class is derived from, and provide a name to use to register in on the network.</p> </li> <li> <p>We're now using the <code>create_subscription()</code> method here, which will allow this node to subscribe to messages on a ROS Topic. When calling this we provide 4 key bits of information:</p> <ol> <li> <p><code>msg_type</code>: The type of message that the topic uses (which we could obtain by running the <code>ros2 topic info</code> command).</p> <p>We know (having just created the publisher), that our topic uses <code>String</code> messages (from <code>std_msgs</code>).</p> </li> <li> <p><code>topic</code>: The name of the topic that we want to listen (or subscribe) to.</p> <p>Fill in the Blank!</p> <p>Replace the <code>{BLANK}</code> in the code above with the name of the topic that our <code>publisher.py</code> node was set up to publish to!</p> </li> <li> <p><code>callback</code>: When building a subscriber, we need a callback function, which is a function that will execute every time a new message is received from the topic.</p> <p>At this stage, we define what this callback function is called (<code>self.msg_callback</code>), and we'll actually define the function itself further down within the Class.</p> </li> <li> <p><code>qos_profile</code>: As before, a queue size to limit the amount of messages that are queued in a buffer. </p> </li> </ol> </li> <li> <p>Print a Log message to the terminal to indicate that the initialisation process has taken place.</p> </li> <li> <p>Here we're defining what will happen each time our subscriber receives a new message. This callback function must have only one argument (other than <code>self</code>), which will contain the message data that has been received:</p> <p>We're also using a Python Type Annotation here too, which informs the interpreter that the <code>topic_message</code> that is received by the <code>msg_callback</code> function will be of the <code>String</code> data type.</p> <p>(All this really does is allow autocomplete functionality to work within our text editor, so that whenever we want to pull an attribute from the <code>toic_message</code> object it will tell us what attributes actually exist within the object.)</p> </li> <li> <p>In this simple example, all we're going to do on receipt of a message is to print a couple of log messages to the terminal, to include: </p> <ol> <li> <p>The name of this node (using the <code>self.get_name()</code> method)</p> </li> <li> <p>The message that has been received (<code>topic_mesage.data</code>)</p> </li> </ol> </li> <li> <p>The rest of this is exactly the same as before with our publisher.</p> </li> </ol>"},{"location":"labs/assignment1/part1/subscriber/#dfts","title":"Don't Forget the Shebang!","text":"<p>Remember: don't forget the shebang, it's very important!</p> <pre><code>#!/usr/bin/env python3\n</code></pre> <p> \u2190 Back to Part 1 </p>"},{"location":"labs/assignment2/","title":"Assignment #2: Team Robotics Project","text":""},{"location":"labs/assignment2/#overview","title":"Overview","text":"<p>In Assignment #2 you will put into practice everything that you learn about ROS in Assignment #1, and explore the capabilities of the framework further.</p> <p>You will attend a 2-hour lab session per week in Diamond Computer Room 5 for the full 12-week semester. You will work in teams to develop ROS Nodes for our TurtleBot3 Waffles that allow them to successfully complete a series of robotics tasks, most of which in a real-world environment. There are XXX tasks to complete in total, all of which will be assessed as part of Assignment #2.</p> <p>TODO...</p>"},{"location":"ros/","title":"Installing ROS","text":"<p>Details on the ROS2 Simulation environment (TODO)</p>"},{"location":"waffles/","title":"The Waffles","text":"<p>Details on the robot's and how to work with them.</p> <p>Based on this from 2023/24</p>"}]}
{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>"},{"location":"#com2009-ros-labs","title":"COM2009 ROS Labs","text":"<p>ROS Labs for the COM2009-3009 Robotics Course at The University of Sheffield (and more) </p> <p> </p> <p>By Tom Howard Department of Multidisciplinary Engineering Education  </p> <p>(Image courtesy of Andy Brown)</p> <p>Find out more...</p> <p></p>"},{"location":"about/","title":"Welcome","text":"<p>This section might include: </p> <ul> <li>About</li> <li>The Robots</li> <li>License</li> <li>Acknowledgements</li> <li>Version History</li> </ul> <p>See here for reference</p>"},{"location":"extras/","title":"ROS Extras","text":"<p>Extra ROS2 tutorials etc that aren't part of the main Assignment #1 Course, but that might be helpful for Assignment #2...</p> <p>A bit like this from 2023/24</p>"},{"location":"labs/","title":"The COM2009 Lab Course","text":"<p>For the COM2009 Robotics course you must complete two lab assignments:</p> <ul> <li> <p>Assignment #1: \"An Introduction to ROS (the Robot Operating System)\".</p> <p>Here you will learn what ROS is and how to use it. You will complete this assignment individually, and in your own time.</p> <p>Weighting: 25% of the overall COM2009 module mark.</p> </li> <li> <p>Assignment #2: \"Team Robotics Project\".</p> <p>Here you will work in teams of 3-4 to complete a series of real-world robotics tasks using our Tutlebot3 Waffle Robots in the Lab (Diamond Computer Room 5).</p> <p>Weighting: 30% of the overall COM2009 module mark</p> </li> </ul>"},{"location":"labs/assignment1/","title":"Assignment #1: An Introduction to ROS","text":""},{"location":"labs/assignment1/#overview","title":"Overview","text":"<p>Assignment #1 is an X-part course, which you should complete in full and in order. The course is designed to be completed in simulation, so you will therefore need access to a ROS installation which can either be installed on your own machine, or accessed on a range of managed computers across the University of Sheffield campus. See here for more information on how to install ROS (TODO).</p> <p>Each part of the course comprises a series of step-by-step instructions and exercises to teach you how ROS works, and introduces you to the core principles of the framework. The exercises give you the opportunity to see how to apply these principles to practical robotic applications. Completing this course is essential for obtaining all the necessary skills for Assignment #2: the Team Robotics Project, where you will work in teams to program our real TurtleBot3 Waffle robots (TODO).  </p>"},{"location":"labs/assignment1/#the-course","title":"The Course","text":"<ul> <li> <p>Part 1: Getting Started with ROS2</p> <p>In this first part you will learn the basics of ROS and become familiar with some key tools and principles of this framework, allowing you to program robots and work with ROS applications effectively.</p> </li> <li> <p>Part 2: Odometry &amp; Navigation</p> <p>In this session you'll learn about Odometry data, which informs us of a robot's position in an environment. You'll also learn how to control a ROS robot's velocity (and thus its position) using both open and closed-loop control methods.</p> </li> <li> <p>Part 3: SLAM &amp; Autonomous Navigation</p> <p>Here you'll take your first look at the LiDAR sensor, the data that it generates, and how this can be of huge benefit for robotics applications. You'll see this in practice by leveraging the mapping and autonomous navigation tools within ROS.</p> </li> <li> <p>Part 4: ROS Services</p> <p>In this part of the course you'll learn about ROS Services, which offer an alternative way for nodes to communicate in ROS. You will see how this framework can be used to control a robot or invoke certain behaviours more effectively for certain tasks.</p> </li> <li> <p>Part 5: ROS Actions</p> <p>Building on what you learnt about ROS Services in Part 4, here you will look at ROS Actions, which are similar to Services, but with a few key differences.</p> </li> <li> <p>Part 6: Cameras, Machine Vision &amp; OpenCV</p> <p>Here you'll learn how to work with images from an on-board camera. You will look at techniques to detect features within these images, and use this to inform robot decision-making.</p> </li> </ul>"},{"location":"labs/assignment1/#assessment","title":"Assessment","text":"<p>This assignment is worth 25% of the overall mark for COM2009, and is assessed via an on-campus Blackboard-based test taking place in week 7 or 8 of the Spring Semester. </p>"},{"location":"labs/assignment1/part1/","title":"Part 1: Getting Started with ROS2","text":""},{"location":"labs/assignment1/part1/#introduction","title":"Introduction","text":"<p> Exercises: 8 Estimated Completion Time: 2 hours</p>"},{"location":"labs/assignment1/part1/#aims","title":"Aims","text":"<p>In the first part of this lab course you will learn the basics of ROS and become familiar with some key tools and principles of the framework which will allow you to program robots and work with ROS applications effectively.  For the most part, you will interact with ROS using the Linux command line and so you will also become familiar with some key Linux command line tools that will help you.  Finally, you will learn how to create some basic ROS Nodes using Python and get a taste of how ROS topics and messages work.</p>"},{"location":"labs/assignment1/part1/#intended-learning-outcomes","title":"Intended Learning Outcomes","text":"<p>By the end of this session you will be able to:  </p> <ol> <li>Control a TurtleBot3 Robot, in simulation, using ROS.</li> <li>Launch ROS applications using <code>ros2 launch</code> and <code>ros2 run</code>.</li> <li>Interrogate running ROS applications using key ROS command line tools.</li> <li>Create a ROS package comprised of multiple nodes and program these nodes (in Python) to communicate with one another using ROS Communication Methods.</li> <li>Create a custom ROS message interface and create Python Nodes to use this.</li> <li>Navigate a Linux filesystem and learn how to do various filesystem operations from within a Linux Terminal.</li> </ol>"},{"location":"labs/assignment1/part1/#quick-links","title":"Quick Links","text":""},{"location":"labs/assignment1/part1/#exercises","title":"Exercises","text":"<ul> <li>Exercise 1: Launching a simulation and making a robot move</li> <li>Exercise 2: Visualising the ROS Network</li> <li>Exercise 3: Exploring ROS Topics and Messages</li> <li>Exercise 4: Creating your own ROS Package</li> <li>Exercise 5: Creating a publisher node</li> <li>Exercise 6: Creating a subscriber node</li> <li>Exercise 7: Defining our own message</li> <li>Exercise 8: Using a custom ROS Message</li> </ul>"},{"location":"labs/assignment1/part1/#additional-resources","title":"Additional Resources","text":"<ul> <li>A Simple Python Publisher</li> <li>A Simple Python Subscriber</li> </ul>"},{"location":"labs/assignment1/part1/#first-steps","title":"First Steps","text":"<p>Step 1: Accessing a ROS2 Environment for this Course</p> <p>If you haven't done so already, see here for all the details on how to install or access a ROS environment for this course (TODO).</p> <p>Step 2: Launch ROS</p> <p>Launch your ROS environment.</p> <ol> <li>OPTION 1</li> <li>OPTION 2</li> <li>etc...</li> </ol> <p>Either way, you should now have access to ROS via a Linux terminal instance, and we'll refer to this terminal instance as TERMINAL 1.</p> <p>Step 3: Download The Course Repo</p> <p></p> <p>We've put together a few ROS packages specifically for this course. These all live within this GitHub repo, and you'll need to download and install this into your ROS environment now, before going any further.</p> <p>[TODO: Create a ROS2 Workspace first??]</p> <ol> <li> <p>In TERMINAL 1, Navigate into the \"ROS2 Workspace\" using the <code>cd</code> command<sup>1</sup>:</p> <pre><code>cd ~/ros2_ws/src/\n</code></pre> </li> <li> <p>Then, run the following command to clone the Course Repo from GitHub:</p> <p>TERMINAL 1: <pre><code>git clone https://github.com/tom-howard/tuos_ros.git -b humble\n</code></pre></p> </li> <li> <p>Once this is done, you'll need to build this using a tool called \"Colcon\"<sup>2</sup>:</p> <p>TERMINAL 1: <pre><code>cd ~/ros2_ws/ &amp;&amp; colcon build --packages-up-to tuos_ros &amp;&amp; source ~/.bashrc\n</code></pre></p> </li> </ol> <p>Don't worry too much about what you just did, for now. We'll cover this in more detail throughout the course. That's it for now though, we'll start using some of the packages that we've just installed a bit later on.</p>"},{"location":"labs/assignment1/part1/#ex1","title":"Exercise 1: Launching a simulation and making a robot move","text":"<p>Now that you're all up and running, let's launch ROS and fire up a simulation of our TurtleBot3 Waffle robot... </p> <ol> <li> <p>In the terminal enter the following command to launch a simulation of a TurtleBot3 Waffle in an empty world:  </p> <p>TERMINAL 1: <pre><code>ros2 launch turtlebot3_gazebo empty_world.launch.py\n</code></pre></p> </li> <li> <p>A Gazebo simulation window should open and within this you should see a basic representation of the robot's that you'll work with in the lab (TODO):</p> </li> </ol> <p>[FIGURE]     </p> <ol> <li> <p>With the Gazebo simulation up and running, return to your terminal and open up a second terminal instance (TERMINAL 2)</p> <p>[TODO: use tmux??]</p> </li> <li> <p>In this new terminal instance enter the following command:</p> <p>TERMINAL 2: <pre><code>ros2 run turtlebot3_teleop teleop_keyboard\n</code></pre></p> </li> <li> <p>Follow the instructions provided in the terminal to drive the robot around using specific buttons on your keyboard:</p> <p> </p> </li> </ol>"},{"location":"labs/assignment1/part1/#summary","title":"Summary","text":"<p>You have just launched a number of different applications on a ROS Network using two different ROS commands - <code>ros2 launch</code> and <code>ros2 run</code>: </p> <ol> <li><code>ros2 launch turtlebot3_gazebo empty_world.launch.py</code></li> <li><code>ros2 run turtlebot3_teleop teleop_keyboard</code></li> </ol> <p>These two commands have a similar structure, but work slightly differently. </p> <p>The first command you used was a <code>launch</code> command, which has the following two parts to it (after the <code>launch</code> bit):</p> <pre><code>ros2 launch {[1] Package name} {[2] Launch file}\n</code></pre> <p>Part [1] specifies the name of the ROS package containing the functionality that we want to execute. Part [2] is a file within that package that tells ROS exactly what scripts ('nodes') that we want to launch. We can launch multiple nodes at the same time from a single launch file.</p> <p>The second command was a <code>run</code> command, which has a structure similar to <code>launch</code>:</p> <pre><code>ros2 run {[1] Package name} {[2] Node name}\n</code></pre> <p>Here, Part [1] is the same as the <code>launch</code> command, but Part [2] is slightly different: <code>{[2] Node name}</code>. Here we are directly specifying a single script that we want to execute. We therefore use <code>ros2 run</code> if we only want to launch a single node on the ROS network: the <code>teleop_keyboard</code> node (a Python script), in this case.</p>"},{"location":"labs/assignment1/part1/#ros-packages-nodes","title":"ROS Packages &amp; Nodes","text":""},{"location":"labs/assignment1/part1/#packages","title":"Packages","text":"<p>ROS applications are organised into packages. Packages are basically folders containing scripts, configurations and launch files (ways to launch those scripts and configurations), all of which relate to some common robot functionality. ROS uses packages as a way to organise all the programs running on a robot. </p> <p>Info</p> <p>The package system is a fundamental concept in ROS and all ROS programs are organised in this way.</p> <p>You will create a number of packages throughout this course, each containing different nodes, launch files and other things too. We'll start to explore this later on in this part of the course.</p>"},{"location":"labs/assignment1/part1/#nodes","title":"Nodes","text":"<p>ROS Nodes are executables that perform specific robot tasks and operations. Earlier on we used <code>ros2 run</code> to execute a node called <code>teleop_keyboard</code>, which allowed us to remotely control (or \"teleoperate\") the robot, for example. </p> <p>Question</p> <p>What was the name of the ROS package that contained the <code>teleop_keyboard</code> node? (Remember: <code>ros2 run {[1] Package name} {[2] Node name}</code>)</p> <p>A ROS robot might have hundreds of individual nodes running simultaneously to carry out all its necessary operations and actions. Each node runs independently, but uses ROS communication methods to share data with the other nodes on the ROS Network.</p>"},{"location":"labs/assignment1/part1/#the-ros-network","title":"The ROS Network","text":"<p>We can use the <code>ros2 node</code> command to view all the nodes that are currently active on a ROS Network.</p>"},{"location":"labs/assignment1/part1/#ex2","title":"Exercise 2: Visualising the ROS Network","text":"<p>You should currently have two terminal instances active: the first in which you launched the Gazebo simulation (TERMINAL 1) and the second with your <code>teleop_keyboard</code> node active (TERMINAL 2).</p> <ol> <li>Open up a new terminal instance now (TERMINAL 3).</li> <li> <p>Use the following command to have a look at which nodes are currently active on the network:</p> <p>TERMINAL 3: <pre><code>ros2 node list\n</code></pre></p> <p>Only a handful of nodes should be listed:</p> <pre><code>/camera_driver\n/gazebo\n/teleop_keyboard\n/turtlebot3_diff_drive\n/turtlebot3_imu\n/turtlebot3_joint_state\n/turtlebot3_laserscan\n</code></pre> </li> <li> <p>We can visualise the connections between the active nodes by using an application called RQT. RQT is a collection of graphical tools that allow us to interact with and interrogate the ROS network. Launch the main RQT application by entering <code>rqt</code> in TERMINAL 3 (you might see some warnings in the terminal when you do this, but don't worry about them):</p> <p>TERMINAL 3: <pre><code>rqt\n</code></pre></p> <p>A window should then open:</p> <p> </p> </li> <li> <p>From here, we then want to load the Node Graph plugin. From the top menu select <code>Plugins</code> &gt; <code>Introspection</code> &gt; <code>Node Graph</code>.</p> </li> <li> <p>Select <code>Nodes/Topics (all)</code> from the top-left most dropdown, and in the <code>Hide</code> section uncheck everything except <code>Debug</code> and <code>Params</code> (you may then need to hit the refresh button):</p> <p> </p> <p>Here, nodes are represented by rectangles and topics by ellipses (hover over a region of the graph to enable colour highlighting).</p> <p>This tool shows us that (amongst other things) the <code>/teleop_keyboard</code> and <code>/turtlebot3_diff_drive</code> nodes are communicating with one another. The direction of the arrow tells us that <code>/teleop_keyboard</code> is a Publisher and <code>/turtlebot3_diff_drive</code> is a Subscriber. The two nodes communicate via a ROS Topic called <code>/cmd_vel</code>. </p> </li> </ol>"},{"location":"labs/assignment1/part1/#publishers-and-subscribers-a-ros-communication-method","title":"Publishers and Subscribers: A ROS Communication Method","text":"<p>ROS Topics are key to making things happen on a robot. Nodes can publish (write) and/or subscribe to (read) ROS Topics in order to share data around the ROS network. Data is published to topics using ROS Messages. As we've just learnt, the <code>teleop_keyboard</code> node was publishing messages to a topic (<code>/cmd_vel</code>) to make the robot move earlier.</p> <p>Let's have a look at this in a bit more detail...</p>"},{"location":"labs/assignment1/part1/#ex3","title":"Exercise 3: Exploring ROS Topics and Messages","text":"<p>We can find out more about the <code>/cmd_vel</code> topic by using the <code>ros2 topic</code> command.</p> <ol> <li> <p>Open up yet another new terminal instance (TERMINAL 4) and type the following:</p> <p>TERMINAL 4: <pre><code>ros2 topic list\n</code></pre></p> <p>This shows us all the topics that are currently available on the ROS network (a lot of which we saw in the RQT Node Graph above):</p> <pre><code>/camera/camera_info\n/camera/image_raw\n/clock\n/cmd_vel\n/imu\n/joint_states\n/odom\n/parameter_events\n/performance_metrics\n/robot_description\n/rosout\n/scan\n/tf\n/tf_static\n</code></pre> <p>Let's find out a bit more about <code>/cmd_vel</code>...</p> </li> <li> <p>Use the <code>topic info</code> command now:</p> <p>TERMINAL 4: <pre><code>ros2 topic info /cmd_vel\n</code></pre></p> <p>This should provide the following output:</p> <pre><code>Type: geometry_msgs/msg/Twist\nPublisher count: 1\nSubscription count: 1\n</code></pre> <p>We've now established the following information about <code>/cmd_vel</code>:</p> <ol> <li>The topic has 1 publisher writing data to it</li> <li>The topic also has 1 subscriber reading this data</li> <li>From RQT Node Graph we know that the <code>/teleop_keyboard</code> node is the publisher (i.e. the node writing data to the topic)</li> <li>The <code>/turtlebot3_diff_drive</code> node is receiving this data (and acting upon it). This node therefore monitors (i.e. subscribes to) the <code>/cmd_vel</code> topic and makes the robot move in the simulator whenever a velocity command is published.</li> <li> <p>Data is transmitted on the <code>/cmd_vel</code> topic using an Interface. This particular interface type is: <code>geometry_msgs/msg/Twist</code>. </p> <p>The type field has three parts to it:</p> <ol> <li><code>geometry_msgs</code>: the name of the ROS package that this interface belongs to.</li> <li><code>msg</code>: that this is a topic message rather than another type of interface (there are three types of interface, and we'll learn about the other two later in this course).</li> <li><code>Twist</code>: the actual message type (i.e., the way the data is structured)</li> </ol> <p>In summary then, we've established that if we want to make the robot move we need to publish <code>Twist</code> messages to the <code>/cmd_vel</code> topic.</p> </li> </ol> </li> <li> <p>We can use the <code>ros2 interface</code> command to provide further information about the message structure:</p> <p>TERMINAL 4: <pre><code>ros2 interface show geometry_msgs/msg/Twist\n</code></pre></p> <p>From this, we obtain the following:</p> <pre><code># This expresses velocity in free space broken into its linear and angular parts.\n\nVector3  linear\n        float64 x\n        float64 y\n        float64 z\nVector3  angular\n        float64 x\n        float64 y\n        float64 z\n</code></pre> <p>We'll learn more about what this means in Part 2.</p> </li> <li> <p>To finish, enter Ctrl+C in each of the three terminals that should currently have ROS processes running (Terminals 1, 2 and 3). The associated Gazebo and RQT Node Graph windows should close as a result of this too.</p> </li> </ol> <p>Tip</p> <p>Whenever you need to stop any ROS process use Ctrl+C in the terminal it's running in.</p>"},{"location":"labs/assignment1/part1/#creating-your-first-ros-applications","title":"Creating Your First ROS Applications","text":"<p>Shortly you will create some simple publisher and subscriber nodes in Python and send simple ROS messages between them. As we learnt earlier though, ROS applications must be contained within packages, and so we need to create a package first in order to start creating our own ROS nodes. </p> <p>It's important to work in a specific filesystem location when we create and work on our own ROS packages. These are called \"Workspaces\" and you should already have one ready to go within your local ROS environment<sup>3</sup>:</p> <pre><code>~/ros2_ws/src/\n</code></pre> <p>Note</p> <p><code>~</code> is an alias for your home directory. So <code>cd ~/ros2_ws/src/</code> is the same as typing <code>cd /home/{your username}/ros2_ws/src/</code>.</p> <p>Important</p> <p>All new packages must be located in the <code>src</code> folder of the workspace!!</p>"},{"location":"labs/assignment1/part1/#ex4","title":"Exercise 4: Creating your own ROS Package","text":"<p>The <code>ros2</code> Command Line Interface (CLI) includes a tool to create a new ROS packages: <code>ros2 pkg create</code>. This tool supports two different \"build types:\"</p> <ol> <li> <p>CMake (for packages containing nodes written in C++):</p> <p><code>ros2 pkg create --build-type ament_cmake</code></p> </li> <li> <p>Python (for packages containing nodes written in well, er, Python!):</p> <p><code>ros2 pkg create --build-type ament_python</code></p> <p>Packages are structured slightly differently in each case.</p> </li> </ol> <p>You can learn more about all this from the Official ROS2 Tutorials (if you're interested).</p> <p>We'll be using Python throughout this course, but we'll actually take a slightly different approach to package creation that will provide us with a little more flexibility and ease of use (particularly for things we'll do later on in the Assignment #1 course and in Assignment #2). We've therefore created a helper script (inside the <code>tuos_ros</code> Course Repo) to help you create packages without using either of the above two commands. The approach we'll take is based on this tutorial (courtesy of the Robotics Backend), so feel free to look at this if you'd like to find out more. Then, simply follow the steps below to create your first ROS package for this course, using the <code>create_pkg.sh</code> helper tool.</p> <ol> <li> <p>Navigate into the <code>tuos_ros</code> Course Repo that you downloaded earlier by using the Linux <code>cd</code> command (change directory). In TERMINAL 1 enter the following:</p> <p>TERMINAL 1: <pre><code>cd ~/ros2_ws/src/tuos_ros/\n</code></pre></p> </li> <li> <p>Here you'll find the <code>create_pkg.sh</code> helper script. Run this now using the following command to create a new package called <code>part1_pubsub</code>:</p> <p>TERMINAL 1: <pre><code>./create_pkg.sh part1_pubsub\n</code></pre></p> </li> <li> <p>Navigate into this new package directory (using <code>cd</code>):</p> <p>TERMINAL 1: <pre><code>cd ../part1_pubsub/\n</code></pre></p> <p>Info</p> <p><code>..</code> means \"go back one directory,\" so that command above is telling <code>cd</code> to navigate out of the <code>tuos_ros</code> directory (and therefore back to <code>~/ros2_ws/src/</code>), and then go into the <code>part1_pubsub</code> directory from there.</p> </li> <li> <p><code>tree</code> is a Linux command which shows us the content of the current directory in a nice tree-like format. Use <code>tree</code> now to show the current content of the <code>part1_pubsub</code> directory:</p> <pre><code>~/ros2_ws/src/part1_pubsub$ tree\n.\n\u251c\u2500\u2500 CMakeLists.txt\n\u251c\u2500\u2500 include\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 part1_pubsub\n\u2502\u00a0\u00a0     \u2514\u2500\u2500 minimal_header.hpp\n\u251c\u2500\u2500 package.xml\n\u251c\u2500\u2500 part1_pubsub\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 __init__.py\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 minimal_module.py\n\u251c\u2500\u2500 scripts\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 minimal_node.py\n\u2514\u2500\u2500 src\n    \u2514\u2500\u2500 minimal_node.cpp\n\n5 directories, 7 files\n</code></pre> <ul> <li><code>scripts</code>: is a directory that will contain all the Python Nodes that we'll create (you'll notice a <code>minimal_node.py</code> already exists in there).</li> <li> <p><code>part1_pubsub</code>: is a directory that we can use to store Python modules, that we can then import into our main Python nodes</p> <p>(<code>from part1_pubsub.minimal_module import ...</code>, for example)</p> </li> <li> <p><code>package.xml</code> and <code>CMakeLists.txt</code>: are both files that define our package, and how it must be built (using <code>colcon build</code>). We'll explore these more shortly... </p> </li> </ul> </li> </ol>"},{"location":"labs/assignment1/part1/#ex5","title":"Exercise 5: Creating a publisher node","text":"<ol> <li>From the root of your <code>part1_pubsub</code> package, navigate to the <code>scripts</code> folder using the <code>cd</code> command.</li> <li> <p><code>touch</code> is a Linux command that we can use to create an empty file. Use this to create an empty file called <code>publisher.py</code>, which we will add content to shortly:</p> <p>TERMINAL 1: <pre><code>touch publisher.py\n</code></pre></p> </li> <li> <p>Use <code>ls</code> to verify that the file has been created, but use the <code>-l</code> option with this, so that the command provides its output in \"a long listing format\":</p> <p>TERMINAL 1: <pre><code>ls -l\n</code></pre></p> <p>This should output something similar to the following:</p> <pre><code>~/ros2_ws/src/part1_pubsub/scripts$ ls -l\ntotal 4\n-rwxr-xr-x 1 student student 339 MMM DD HH:MM minimal_node.py\n-rw-r--r-- 1 student student   0 MMM DD HH:MM publisher.py\n</code></pre> <p>This confirms that the file exists, and the <code>0</code> in the middle of the bottom line there indicates that the file is empty (i.e. its current size is 0 bytes), which is what we'd expect.</p> </li> <li> <p>We therefore now need to open the file and add content to it. We'd recommend using Visual Studio Code (VS Code) as an IDE for this course, which can be launched with the following command in TERMINAL 1:</p> <p>TERMINAL 1: <pre><code>code ~\n</code></pre></p> <p>[TODO: does this work for Docker??]</p> </li> <li> <p>Using the VS Code File Explorer, locate the <code>publisher.py</code> file that you have just created (<code>ros2_ws/src/part1_pubsub/scripts/</code>) and click on the file to open it in the main editor. </p> </li> <li> <p>Once opened, copy the code provided here into the empty file and save it. </p> <p>Note</p> <p>It's important that you understand how this code works, so make sure that you read the annotations!</p> </li> <li> <p>Next, we need to add our <code>publisher.py</code> file as an executable to our package's <code>CMakeLists.txt</code>. This will ensure that it then gets built when we run <code>colcon build</code> (in the next step).</p> <p>In VS Code, open the <code>CMakeLists.txt</code> file that is at the root of your <code>part1_pubsub</code> package directory (<code>ros2_ws/src/part1_pubsub/CMakeLists.txt</code>). Locate the lines (near the bottom of the file) that read:</p> <pre><code># Install Python executables\ninstall(PROGRAMS\n  scripts/minimal_node.py\n  DESTINATION lib/${PROJECT_NAME}\n)\n</code></pre> <p>Replace <code>minimal_node.py</code> with <code>publisher.py</code> to define this as a Python executable in your package:</p> <pre><code># Install Python executables\ninstall(PROGRAMS\n  scripts/publisher.py\n  DESTINATION lib/${PROJECT_NAME}\n)\n</code></pre> </li> <li> <p>Now, use <code>colcon</code> to build your package.</p> <ol> <li> <p>You MUST run this from the root of your Colcon Workspace (i.e.: <code>~/ros2_ws/</code>), NOT the <code>src</code> directory (<code>~/ros2_ws/src/</code>), so navigate there now using <code>cd</code>:</p> <pre><code>cd ~/ros2_ws/\n</code></pre> </li> <li> <p>Then, use the following <code>colcon</code> command to build your package:</p> <pre><code>colcon build --packages-select part1_pubsub --symlink-install\n</code></pre> <p>What do the additional arguments above do?</p> <ul> <li><code>--packages-select</code>: Build only the <code>part1_pubsub</code> package, nothing else (without this <code>colcon</code> would attempt to build every package in the workspace).</li> <li><code>--symlink-install</code>: Ensures that you don't have to re-run <code>colcon build</code> every time you make a change to your package's executables (i.e. your Python files in the <code>scripts</code> directory).</li> </ul> </li> <li> <p>Finally, \"re-source\" your <code>bashrc</code><sup>4</sup>:</p> <pre><code>source ~/.bashrc\n</code></pre> </li> </ol> </li> <li> <p>We should now be able to run this node using the <code>ros2 run</code> command.</p> <p>Remember: <code>ros2 run {package name} {script name}</code>, so:</p> <p>TERMINAL 1: <pre><code>ros2 run part1_pubsub publisher.py\n</code></pre></p> <p>... Hmm, something not quite right? If you typed the command exactly as above and then tried to run it, you probably just received the following error:</p> <pre><code>$ ros2 run part1_pubsub publisher.py\nNo executable found\n</code></pre> <p>When we create a file using <code>touch</code> it is given certain permissions by default. Run <code>ls -l</code> again (making sure that your terminal is in the right location: <code>~/ros2_ws/src/part1_pubsub/scripts/</code>).</p> <p>The first bit tells us about the permissions that are currently set: <code>-rw-r--r--</code>. This tells us who has permission to do what with this file and (currently) the first bit: <code>-rw-</code>, tells us that we have permission to read or write to it. There is a third option we can set too though, which is the execute permission, and we can set this using the <code>chmod</code> Linux command...</p> </li> <li> <p>Run the <code>chmod</code> command as follows:</p> <p>TERMINAL 1: <pre><code>chmod +x publisher.py\n</code></pre></p> </li> <li> <p>Now, run <code>ls -l</code> again to see what has changed:</p> <p>TERMINAL 1: <pre><code>ls -l\n</code></pre></p> <p>We have now granted permission for the file to be executed too:</p> <pre><code>-rwxr-xr-x 1 student student 1125 MMM DD HH:MM publisher.py\n</code></pre> </li> <li> <p>OK, now use <code>ros2 run</code> again to (hopefully!) run the <code>publisher.py</code> node (remember: <code>ros2 run {package name} {script name}</code>).</p> <p>If you see a message in the terminal similar to the following then the node has been launched successfully:</p> <pre><code>[INFO] [#####] [simple_publisher]: The 'simple_publisher' node is inisialised.\n</code></pre> <p>Phew!</p> </li> <li> <p>We can further verify that our publisher node is running using a number of different tools. Try running the following commands in TERMINAL 2:</p> <ol> <li><code>ros2 node list</code>: This will provide a list of all the nodes that are currently active on the system. Verify that the name of our publisher node is visible in this list (it's probably the only item in the list at the moment!)</li> <li><code>ros2 topic list</code>: This will provide a list of the topics that are currently being used by nodes on the system. Verify that the name of the topic that our publisher is publishing messages to (<code>/my_topic</code>) is present within this list.</li> </ol> </li> </ol>"},{"location":"labs/assignment1/part1/#rostopic","title":"Interrogating ROS Topics","text":"<p>So far we have used the <code>ros2 topic</code> ROS command with two additional arguments: [TODO: check this!]</p> <ul> <li><code>list</code>: to provide us with a list of all the topics that are active on our ROS system, and</li> <li><code>info</code>: to provide us with information on a particular topic of interest.</li> </ul> <p>We can use the autocomplete functionality of the Linux terminal to provide us with a list of all the available options that we can use with the <code>ros2 topic</code> command.  To do this type <code>ros2 topic</code> followed by a Space and then press the Tab key twice:</p> <pre><code>rostopic[SPACE][TAB][TAB]\n</code></pre> <p>You should then be presented with a list of all options:</p> <p>[TODO: a gif]</p> <ul> <li> <p><code>ros2 topic hz {topic name}</code> provides information on the frequency (in Hz) at which messages are being published to a topic:</p> <pre><code>ros2 topic hz /my_topic\n</code></pre> <p>This should tell us that our publisher node is publishing messages to the <code>/my_topic</code> topic at (or close to) 1 Hz, which is exactly what we ask for in the <code>publisher.py</code> file (in the <code>__init__</code> part of our <code>Publisher</code> class). Enter Ctrl+C to stop this command.</p> </li> <li> <p><code>ros2 topic echo {topic name}</code> shows the messages being published to a topic:</p> <pre><code>ros2 topic echo /my_topic\n</code></pre> <p>This will provide a live stream of the messages that our <code>publisher.py</code> node is publishing to the <code>/my_topic</code> topic. Enter Ctrl+C to stop this.</p> </li> <li> <p>We can see some additional options for the <code>echo</code> command by viewing the help documentation for this too:</p> <pre><code>ros2 topic echo --help\n</code></pre> <p>From here, for instance, we can learn that if we just wanted to print the first message that was received we could use the <code>-once</code> option, for example:</p> <pre><code>ros2 topic echo /my_topic --once\n</code></pre> </li> </ul>"},{"location":"labs/assignment1/part1/#ex6","title":"Exercise 6: Creating a subscriber node","text":"<p>To illustrate how information can be passed from one node to another (via topics and messages) we'll now create another node to subscribe to the topic that our publisher node is broadcasting messages to.</p> <ol> <li> <p>In TERMINAL 2 use the filesystem commands that were introduced earlier (<code>cd</code>, <code>ls</code>, etc.) to navigate to the <code>scripts</code> folder of your <code>part1_pubsub</code> package.</p> </li> <li> <p>Use the same procedure as before to create a new empty Python file called <code>subscriber.py</code> and remember to make it executable! </p> </li> <li> <p>Then, open the newly created <code>subscriber.py</code> file in VS Code, paste in the code here and save it. </p> <p>Once again, it's important that you understand how this code works, so make sure you read the code annotations! </p> </li> <li> <p>Next, we need to add this as an additional executable for our package. </p> <p>Open up the <code>CMakeLists.txt</code> file at the root of your <code>part1_pubsub</code> package directory again, head back to the <code># Install Python executables</code> section and add the <code>subscriber.py</code> file:</p> <pre><code># Install Python executables\ninstall(PROGRAMS\n  scripts/publisher.py\n  scripts/subscriber.py\n  DESTINATION lib/${PROJECT_NAME}\n)\n</code></pre> </li> <li> <p>Now we need to <code>colcon build</code> again.</p> <ol> <li> <p>Make sure you're at the root of the Colcon Workspace:</p> <pre><code>cd ~/ros2_ws/\n</code></pre> </li> <li> <p>Run <code>colcon build</code> on only the <code>part1_pubsub</code> package:</p> <pre><code>colcon build --packages-select part1_pubsub --symlink-install\n</code></pre> </li> <li> <p>And then re-source the <code>bashrc</code>:</p> <pre><code>source ~/.bashrc\n</code></pre> </li> </ol> </li> <li> <p>Use <code>ros2 run</code> to execute your newly created <code>subscriber.py</code> node (remember: <code>ros2 run {package name} {script name}</code>). If your publisher and subscriber nodes are working correctly you should see an output like this:</p> <p>[TODO: another gif]</p> </li> <li> <p>Interrogate your ROS network:</p> <ol> <li> <p>As before, we can find out what nodes are running on our system by using the <code>ros2 node list</code> command. Run this in TERMINAL 3, you should see both your publisher and subscriber nodes listed there.</p> </li> <li> <p>Use the <code>ros2 topic</code> command to list all the topics that are available on the network. You should see <code>/my_topic</code> listed there.</p> </li> <li> <p>Use the <code>ros2 topic</code> command again to find more info on <code>my_topic</code>. </p> </li> <li> <p>Use the <code>ros2 interface</code> command to show you what type of data is being sent between the two nodes.</p> </li> </ol> </li> <li> <p>Finally, close down your publisher and subscriber nodes by entering Ctrl+C in the terminals where they are running (should be 1 &amp; 2).</p> </li> </ol>"},{"location":"labs/assignment1/part1/#ex7","title":"Exercise 7: Defining our own message","text":"<p>We've just created a publisher and subscriber that were able to communicate with one another via a topic. The data that the publisher was sending to the topic was very simple: a <code>example_interfaces/msg/String</code> type message.</p> <p>This message just has one field called <code>data</code> of the type <code>string</code>:</p> <pre><code>$ ros2 interface show example_interfaces/msg/String\n\nstring data\n</code></pre> <p>ROS messages will generally be more complex than this, typically containing several fields in a single message. We'll define our own custom message now, this time with two fields, so you can see how things work with slightly more complex data types. </p> <ol> <li> <p>Message interfaces must be defined within a <code>msg</code> folder at the root of our package directory, so let's create this folder now in TERMINAL 1:</p> <ol> <li> <p>First, navigate into your package:</p> <pre><code>cd ~/ros2_ws/src/part1_pubsub\n</code></pre> </li> <li> <p>Then use <code>mkdir</code> to make a new directory:</p> <pre><code>mkdir msg\n</code></pre> </li> </ol> </li> <li> <p>We'll create a message called <code>Example</code>, and to do this we'll need to create a new file called <code>Example.msg</code> inside the <code>msg</code> folder:</p> <pre><code>touch msg/Example.msg\n</code></pre> </li> <li> <p>To define the data structure of this message, we now need to open up the file and add the following content:</p> Example.msg<pre><code>string info\nint32 time\n</code></pre> <p>The message will therefore have two fields:</p> <p> # Field Name Data Type 1 <code>info</code> <code>string</code> 2 <code>time</code> <code>int32</code> <p></p> <p>We can give our fields any name that we want, but the data types must be either built-in-types or other pre-existing ROS interfaces.</p> <li> <p>We now need to declare this message in our package's <code>CMakeLists.txt</code> file, so that the necessary Python code can be created (by <code>colcon build</code>) to allow us to import this message into our own Python files.</p> <p>Add the following lines to your <code>part1_pubsub/CMakeLists.txt</code> file, above the <code>ament_package()</code> line:</p> CMakeLists.txt<pre><code>find_package(rosidl_default_generators REQUIRED)\nrosidl_generate_interfaces(${PROJECT_NAME}\n  \"msg/Example.msg\" \n)\n</code></pre> </li> <li> <p>We also need to modify our <code>package.xml</code> file. Add the following lines to this one, just above the <code>&lt;export&gt;</code> line:</p> package.xml<pre><code>&lt;buildtool_depend&gt;rosidl_default_generators&lt;/buildtool_depend&gt;\n&lt;exec_depend&gt;rosidl_default_runtime&lt;/exec_depend&gt;\n&lt;member_of_group&gt;rosidl_interface_packages&lt;/member_of_group&gt;\n</code></pre> </li> <li> <p>We can now use Colcon to generate the necessary source code for the message:</p> <ol> <li> <p>First, make sure you're in the root of the ROS2 Workspace:</p> <pre><code>cd ~/ros2_ws/\n</code></pre> </li> <li> <p>Then run <code>colcon build</code>:</p> <pre><code>colcon build --packages-select part1_pubsub --symlink-install \n</code></pre> </li> <li> <p>And finally re-source the <code>.bashrc</code>:</p> <pre><code>source ~/.bashrc\n</code></pre> </li> </ol> </li> <li> <p>We can now verify that this worked with some more <code>ros2</code> command line tools:</p> <ol> <li> <p>First, list all the ROS messages that are available to us on our system:</p> <pre><code>ros2 interface list -m\n</code></pre> <p>Scroll through this list and see if you can find our message in there (it'll be listed as <code>part1_pubsub/msg/Example</code>)</p> </li> <li> <p>Next, show the data structure of the interface:</p> <pre><code>ros2 interface show part1_pubsub/msg/Example\n</code></pre> <p>This should match with how we defined it in our <code>part1_pubsub/msg/Example.msg</code> file.</p> </li> </ol> </li>"},{"location":"labs/assignment1/part1/#ex8","title":"Exercise 8: Using a custom ROS Message","text":"<ol> <li> <p>Create a copy of the <code>publisher.py</code> file from Exercise 5. Let's do this from the command line too:</p> <ol> <li> <p>Navigate into your package's <code>scripts</code> folder:</p> <pre><code>cd ~/ros2_ws/src/part1_pubsub/scripts\n</code></pre> </li> <li> <p>And use the <code>cp</code> command to make a copy of the <code>publisher.py</code> file and call this new file <code>custom_msg_publisher.py</code>:</p> <pre><code>cp publisher.py custom_msg_publisher.py\n</code></pre> </li> <li> <p>Let's create a copy of the <code>subscriber.py</code> file too, while we're here:</p> <pre><code>cp subscriber.py custom_msg_subscriber.py\n</code></pre> </li> </ol> </li> <li> <p>Declare these two new files as additional executables in our <code>CMakeLists.txt</code>:</p> CMakeLists.txt<pre><code># Install Python executables\ninstall(PROGRAMS\n  scripts/publisher.py\n  scripts/subscriber.py\n  scripts/custom_msg_publisher.py   # ADD THIS \n  scripts/custom_msg_subscriber.py  # AND THIS\nDESTINATION lib/${PROJECT_NAME}\n)\n</code></pre> </li> <li> <p>Run Colcon again (last time now!):</p> <ol> <li>First:     <pre><code>cd ~/ros2_ws\n</code></pre></li> <li>Then:     <pre><code>colcon build --packages-select part1_pubsub --symlink-install\n</code></pre></li> <li>And finally:     <pre><code>source ~/.bashrc\n</code></pre></li> </ol> </li> <li> <p>Now modify your <code>custom_msg_publisher.py</code> file as follows:</p> custom_msg_publisher.py<pre><code>#!/usr/bin/env python3\n\nimport rclpy\nfrom rclpy.node import Node\n\nfrom part1_pubsub.msg import Example # (1)!\n\nclass SimplePublisher(Node):\n\n    def __init__(self):\n        super().__init__(\"simple_publisher\")\n\n        self.my_publisher = self.create_publisher(\n            msg_type=Example, # (2)!\n            topic=\"my_topic\",\n            qos_profile=10,\n        )\n\n        publish_rate = 1 # Hz\n        self.timer = self.create_timer(\n            timer_period_sec=1/publish_rate,\n            callback=self.timer_callback\n        )\n\n        self.get_logger().info(\n            f\"The '{self.get_name()}' node is initialised.\"\n        )\n\n    def timer_callback(self):\n        ros_time = self.get_clock().now().seconds_nanoseconds()\n\n        topic_msg = Example() # (3)!\n        topic_msg.info = \"The ROS time is...\"\n        topic_msg.time = ros_time[0]\n        self.my_publisher.publish(topic_msg)\n        self.get_logger().info(\n            f\"Publishing: '{topic_msg.info} {topic_msg.time:.0f}'\"\n        )\n\ndef main(args=None):\n    rclpy.init(args=args)\n    my_simple_publisher = SimplePublisher()\n    rclpy.spin(my_simple_publisher)\n    my_simple_publisher.destroy_node()\n    rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n</code></pre> <ol> <li> <p>We're now importing the <code>Example</code> message from our own <code>part1_pubsub</code> package.</p> </li> <li> <p>We're also now declaring that <code>\"my_topic\"</code> will use the <code>Example</code> message data structure to send messages.</p> </li> <li> <p>We need to deal with the topic messages differently now, to account for the more complex structure.</p> <p>We now populate our messages with two fields: <code>info</code> (a <code>string</code>) and <code>time</code> (an <code>int</code>). Identify what has changed here...</p> </li> </ol> </li> <li> <p>Final Task:</p> <p>Modify the <code>custom_msg_subscriber.py</code> node now to accommodate the new message type that is being published to <code>/my_topic</code>. </p> </li> </ol>"},{"location":"labs/assignment1/part1/#wrapping-up","title":"Wrapping Up","text":"<p>In this session we've covered the basics of ROS, and learnt about some key concepts such as Packages; Nodes; and how to send data across a ROS Network using Topics, Messages, and the Publisher-Subscriber Communication Method.</p> <p>We've learnt how to use some key <code>ros2</code> commands:  </p> <ul> <li><code>launch</code>: to launch multiple ROS Nodes via launch files.</li> <li><code>run</code>: to run executables within a ROS package.</li> <li><code>node</code>: to display information about active ROS Nodes.</li> <li><code>topic</code>: to display information about active ROS topics.</li> <li><code>interface</code>: to display information about all ROS Interfaces that are available to use in a ROS application.</li> </ul> <p>We have also learnt how to work in the Linux Terminal and navigate a Linux filesystem using key commands such as:</p> <ul> <li><code>ls</code>: lists the files in the current directory.</li> <li><code>cd</code>: change directory to move around the file system.</li> <li><code>mkdir</code>: make a new directory (<code>mkdir {new_folder}</code>).</li> <li><code>chmod</code>: modify file permissions (i.e. to add execute permissions to a file for all users: <code>chmod +x {file}</code>).</li> <li><code>touch</code>: create a file without any content.</li> </ul> <p>In addition to this we've also learnt how to create a ROS2 package, and how to create simple Python nodes that can publish and subscribe to topics on a ROS network. </p> <p>We've worked with pre-made ROS messages to do this and also created our own custom message interface to offer more advanced functionality.</p> <ol> <li> <p>What is a ROS2 Workspace? You can find out more here.\u00a0\u21a9</p> </li> <li> <p>What is Colcon? Find out more here.\u00a0\u21a9</p> </li> <li> <p>You can learn more about ROS2 Workspaces here.\u00a0\u21a9</p> </li> <li> <p>What does <code>source ~/.bashrc</code> do? See here for an explanation.\u00a0\u21a9</p> </li> </ol>"},{"location":"labs/assignment1/part2/","title":"Part 2: Odometry & Navigation","text":""},{"location":"labs/assignment1/part2/#introduction","title":"Introduction","text":"<p> Exercises: X Estimated Completion Time: Y hours</p>"},{"location":"labs/assignment1/part2/#aims","title":"Aims","text":"<p>In Part 2 you will learn how to control a ROS robot's position and velocity from both the command line and through ROS Nodes. You will also learn how to interpret the data that allows us to monitor a robot's position in its physical environment (odometry).  The things you will learn here form the basis for all robot navigation in ROS, from simple open-loop methods to more advanced closed-loop control (both of which you will explore).</p>"},{"location":"labs/assignment1/part2/#intended-learning-outcomes","title":"Intended Learning Outcomes","text":"<p>By the end of this session you will be able to:</p> <ol> <li>Interpret the Odometry data published by a ROS Robot and identify the parts of these messages that are relevant to a 2-wheeled differential drive robot (such as the TurtleBot3).</li> <li>Develop Python nodes to obtain Odometry messages from an active ROS network and translate them to provide useful information about a robot's pose in a convenient, human-readable way.</li> <li>Implement open-loop velocity control of a robot using ROS command-line tools.</li> <li>Develop Python nodes that use open-loop velocity control methods to make a robot follow a pre-defined motion path.</li> <li>Combine both publisher &amp; subscriber communication methods into a single Python node to implement closed-loop (odometry-based) velocity control of a robot.</li> <li>Explain the limitations of Odometry-based motion control methods. </li> </ol>"},{"location":"labs/assignment1/part2/#getting-started","title":"Getting Started","text":"<p>TODO:</p> <p>Step 1: Launch your ROS Environment</p> <p>If you haven't done so already, launch your ROS environment now:</p> <ol> <li>OPTION 1</li> <li>OPTION 2</li> <li>etc...</li> </ol> <p>You should now have access to ROS via a Linux terminal instance. We'll refer to this terminal instance as TERMINAL 1.</p> <p>Step 2: Make Sure The Course Repo is Up-To-Date</p> <p></p> <p>In Part 1 you should have downloaded and installed The Course Repo into your ROS environment. If you haven't done this yet then go back and do it now. If you have already done it, then it's worth just making sure it's all up-to-date, so run the following command now to do so:</p> <p>TERMINAL 1: <pre><code>cd ~/ros2_ws/src/tuos_ros/ &amp;&amp; git pull\n</code></pre></p> <p>Then build with Colcon: </p> <pre><code>cd ~/ros2_ws/ &amp;&amp; colcon build --packages-up-to tuos_ros\n</code></pre> <p>And finally, re-source your environment:</p> <pre><code>source ~/.bashrc\n</code></pre> <p>Warning</p> <p>If you have any other terminal instances open, then you'll need run <code>source ~/.bashrc</code> in these too, in order for any changes made by the Colcon build process to propagate through to these as well.</p> <p>Step 3: Launch a Waffle Simulation</p> <p>In TERMINAL 1 enter the following command to launch a simulation of a TurtleBot3 Waffle in an empty world:  </p> <p>TERMINAL 1: <pre><code>ros2 launch turtlebot3_gazebo empty_world.launch.py\n</code></pre></p> <p>A Gazebo simulation window should open and within this you should see a TurtleBot3 Waffle in empty space:</p> <p></p> <p>You're all set up and ready to go!</p>"},{"location":"labs/assignment1/part2/#velocity","title":"Velocity (Motion)","text":"<p>In Part 1 we learnt about ROS Topics, and about how the <code>teleop_keyboard</code> node could be used to publish messages to a particular topic in order to control the velocity of the robot (and thus change its position).</p> <p>Questions</p> <ol> <li>Which topic is used to control the velocity of the robot?</li> <li>What message type does this topic use?</li> </ol> <p>Return here if you need a reminder on how to find the answers to these questions.</p> <p>We also learnt how to find out more about this particular message type (using the <code>ros2 interface show</code> command): </p> <pre><code># This expresses velocity in free space broken into its linear and angular parts.\n\nVector3  linear\n        float64 x\n        float64 y\n        float64 z\nVector3  angular\n        float64 x\n        float64 y\n        float64 z\n</code></pre>"},{"location":"labs/assignment1/part2/#velocity-commands","title":"Velocity Commands","text":"<p>There are six \"fields\" that we can assign values to here: two velocity types, each with three velocity components: </p> <p> Velocity Type Component 1 Component 2 Component 3 <code>linear</code> <code>x</code> <code>y</code> <code>z</code> <code>angular</code> <code>x</code> <code>y</code> <code>z</code> <p></p> <p>These relate to a robot's six degrees of freedom, and the topic messages are therefore formatted to give a ROS Programmer the ability to ask a robot to move in any one of its six DOFs. </p> <p> Component (Axis) Linear Velocity Angular Velocity X \"Forwards/Backwards\" \"Roll\" Y \"Left/Right\" \"Pitch\" Z \"Up/Down\" \"Yaw\" <p></p>"},{"location":"labs/assignment1/part2/#the-degrees-of-freedom-of-a-waffle","title":"The Degrees of Freedom of a Waffle","text":"<p>The three \"axes\" in the table above are termed the \"Principal Axes\". In the context of our TurtleBot3 Waffle, these axes and the motion about them are defined as follows:</p> <p></p> <p></p> <p>As discussed above, a mobile robot can have up to six degrees of freedom in total, but this depends upon the robot's design and the actuators it is equipped with. </p> <p>Our TurtleBot3 Waffles only have two motors. These two motors can be controlled independently (known as a \"differential drive\" configuration), which ultimately provides it with a total of two degrees of freedom overall, as illustrated below.</p> <p></p> <p>It can therefore only move linearly in the x-axis (Forwards/Backwards) and angularly in the z-axis (Yaw).</p> <p> Principal Axis Linear Velocity Angular Velocity X \"Forwards/Backwards\" \"Roll\" Y \"Left/Right\" \"Pitch\" Z \"Up/Down\" \"Yaw\" <p></p> <p>Maximum Velocity Limits</p> <p>Keep in mind (while we're on the subject of velocity) that our TurtleBot3 Waffles have maximum velocity limits:</p> <p> Velocity Component Upper Limit Units Linear 0.26 m/s Angular 1.82 rad/s <p></p>"},{"location":"labs/assignment1/part2/#odometry","title":"Odometry (Position)","text":""},{"location":"labs/assignment1/part2/#odometry-in-action","title":"Odometry In Action","text":"<p>Let's take another look at all the topics that can be used to communicate with our robot:</p> <pre><code>ros2 topic list\n</code></pre> <p>Another topic of interest here is <code>/odom</code>. This topic contains Odometry data, which is also essential for robot navigation, giving us an approximation of a robot's location in its environment.</p> <p>Let's explore this further now, using <code>rqt</code>.</p>"},{"location":"labs/assignment1/part2/#ex1","title":"Exercise 1: Exploring Odometry Data","text":"<ol> <li> <p>In TERMINAL 2 launch <code>rqt</code>:</p> <p>TERMINAL 2: <pre><code>rqt\n</code></pre></p> </li> <li> <p>From the top menu select <code>Plugins</code> &gt; <code>Topics</code> &gt; <code>Topic Monitor</code></p> <p>Topic Monitor should then present you with a list of active topics which matches the topic list from the <code>ros2 topic list</code> command that you ran earlier.</p> </li> <li> <p>Check the box next to <code>/odom</code> and click the arrow next to it to expand the topic and reveal four base fields.</p> </li> <li> <p>Expand the <code>pose</code> &gt; <code>pose</code> &gt; <code>position</code> and <code>orientation</code> fields to reveal the data being published to the three position and four orientation values of this message.</p> </li> <li> <p>Also expand the <code>twist</code> &gt; <code>twist</code>, <code>linear</code> and <code>angular</code> fields to reveal the six values being published here too.</p> <p> </p> </li> <li> <p>Next, launch a new terminal instance, we'll call this one TERMINAL 3. Arrange this next to the <code>rqt</code> window, so that you can see them both simultaneously.</p> </li> <li> <p>In TERMINAL 3 launch the <code>teleop_keyboard</code> node as you did in Part 1: </p> <p>TERMINAL 3: <pre><code>ros2 run turtlebot3_teleop teleop_keyboard\n</code></pre></p> </li> <li> <p>Enter A a couple of times to make the robot rotate on the spot. Observe how the odometry data changes in Topic Monitor.</p> <p>Questions</p> <ol> <li>Which <code>pose</code> fields are changing?</li> <li>Is there anything in the <code>twist</code> part of the message that corresponds to the angular velocity that is being published by the <code>teleop_keyboard</code> node in TERMINAL 3? </li> </ol> </li> <li> <p>Now press the S key to halt the robot, then press W a couple of times to make the robot drive forwards.</p> <p>Questions</p> <ol> <li>Which <code>pose</code> fields are changing now? How does this relate to the position of the robot in the simulated world?</li> <li>How does the <code>twist</code> part of the message now correspond with the linear velocity setting in TERMINAL 3?</li> </ol> </li> <li> <p>Now press D a couple of times and your robot should start to move in a circle.</p> <p>Questions</p> <ol> <li>What linear and angular velocities are you requesting in TERMINAL 3, and how are these represented in the <code>twist</code> part of the <code>/odom</code> message?</li> <li>What about the <code>pose</code> part of the message? How is this data changing as your robot moves in a circular path.</li> <li>What are <code>twist</code> and <code>pose</code> actually telling us?</li> </ol> </li> <li> <p>Press S in TERMINAL 3 to stop the robot (but leave the <code>teleop_keyboard</code> node running).  Then, press Ctrl+C in TERMINAL 2 to close down <code>rqt</code>. </p> </li> <li> <p>Let's look at the Odometry data differently now. With the robot stationary, use <code>ros2 run</code> to run a Python node from the <code>tuos_examples</code> package: </p> <p>TERMINAL 2: <pre><code>ros2 run tuos_examples robot_pose\n</code></pre></p> </li> <li> <p>Now (using the <code>teleop_keyboard</code> node in TERMINAL 3) drive your robot around again, keeping an eye on the outputs that are being printed by the <code>robot_pose</code> node in TERMINAL 2 as you do so.</p> <p>The output of the <code>robot_pose</code> node shows you how the robot's position and orientation (i.e. \"pose\") are changing in real-time as you move the robot around. The <code>\"initial\"</code> column tells us the robot's pose when the node was first launched, and the <code>\"current\"</code> column show us what its pose currently is. The <code>\"delta\"</code> column then shows the difference between the two.</p> <p>Question</p> <p>Which pose parameters haven't changed, and is this what you would expect (considering the robot's principal axes, as illustrated above)?</p> </li> <li> <p>Press Ctrl+C in TERMINAL 2 and TERMINAL 3, to stop the <code>robot_pose</code> and <code>teleop_keyboard</code> nodes. </p> </li> </ol>"},{"location":"labs/assignment1/part2/#odometry-explained","title":"Odometry: Explained","text":"<p>Hopefully you have a good idea of what Odometry is now, but let's dig a little deeper using some key ROS command line tools again:</p> <p>TERMINAL 2: <pre><code>ros2 topic info /odom\n</code></pre></p> <p>This provides information about the type of message used by this topic:</p> <pre><code>Type: nav_msgs/msg/Odometry\n</code></pre> <p>We can find out more about this message using the <code>ros2 interface show</code> command:</p> <p>TERMINAL 2: <pre><code>ros2 interface show nav_msgs/msg/Odometry\n</code></pre></p> <p>Look down the far left-hand side to identify the four base fields of the message (i.e. the fields that are not indented):</p> <p> # Field Name Field Type 1 <code>header</code> <code>std_msgs/Header</code> 2 <code>child_frame_id</code> <code>string</code> 3 <code>pose</code> <code>geometry_msgs/PoseWithCovariance</code> 4 <code>twist</code> <code>geometry_msgs/TwistWithCovariance</code> <p></p> <p>We saw all these in <code>rqt</code> earlier. As before, its items 3 and 4 that are of most interest to us...</p>"},{"location":"labs/assignment1/part2/#pose","title":"Pose","text":"<pre><code># Estimated pose that is typically relative to a fixed world frame.\ngeometry_msgs/PoseWithCovariance pose\n        Pose pose\n                Point position\n                        float64 x\n                        float64 y\n                        float64 z\n                Quaternion orientation\n                        float64 x\n                        float64 y\n                        float64 z\n                        float64 w\n        float64[36] covariance\n</code></pre> <p>As you can see above, there are two key components to Pose:</p> <ol> <li>Position: Tells us where our robot is located in 3-dimensional space. This is expressed in units of meters.</li> <li>Orientation: Tells us which way our robot is pointing in its environment. This is expressed in units of Quaternions, which is a mathematically convenient way to store data related to a robot's orientation (it's a bit hard for us humans to understand and visualise this though, so we'll talk about how to convert it to a different format later).</li> </ol> <p>Pose is defined relative to an arbitrary reference point (typically where the robot was when it was turned on), and is determined from:</p> <ul> <li>Data from the Inertial Measurement Unit (IMU) on the OpenCR board</li> <li>Data from both the left and right wheel encoders</li> <li>A kinematic model of the robot</li> </ul> <p>All the above information can then be used to calculate (and keep track of) the distance travelled by the robot from its pre-defined reference point using a process called \"dead-reckoning.\"</p>"},{"location":"labs/assignment1/part2/#what-are-quaternions","title":"What are Quaternions?","text":"<p>Quaternions use four values to represent the orientation of something in 3 dimensional space<sup>1</sup>, as we can observe from the structure of the <code>nav_msgs/msg/Odometry</code> ROS message:</p> <pre><code>Quaternion orientation\n        float64 x\n        float64 y\n        float64 z\n        float64 w\n</code></pre> <p>For us, it's easier to think about the orientation of our robot in a \"Euler Angle\" representation, which tell us the degree of rotation about the three principal axes (as discussed above):</p> <ul> <li><code>\u03b8<sub>x</sub></code>, aka: \"Roll\"</li> <li><code>\u03b8<sub>y</sub></code>, aka: \"Pitch\"</li> <li><code>\u03b8<sub>z</sub></code>, aka: \"Yaw\"</li> </ul> <p>Fortunately, the maths involved in converting between these two orientation formats is fairly straight forward (see here).</p> <p>Recall from above however, that our TurtleBot3 can only move in a 2D plane and so, actually, its pose can be fully represented by just 3 terms: </p> <ul> <li><code>x</code> &amp; <code>y</code>: the 2D coordinates of the robot in the <code>X-Y</code> plane</li> <li><code>\u03b8<sub>z</sub></code>: the angle of the robot about the <code>z</code> (yaw) axis</li> </ul>"},{"location":"labs/assignment1/part2/#twist","title":"Twist","text":"<p>The fourth base field within the <code>nav_msgs/msg/Odometry</code> message is Twist:</p> <pre><code># Estimated linear and angular velocity relative to child_frame_id.\ngeometry_msgs/TwistWithCovariance twist\n        Twist twist\n                Vector3  linear\n                        float64 x\n                        float64 y\n                        float64 z\n                Vector3  angular\n                        float64 x\n                        float64 y\n                        float64 z\n        float64[36] covariance\n</code></pre> <p>This might look familiar from earlier! This tells us the current linear and angular velocities of the robot. These velocities are set by messages published to <code>/cmd_vel</code>, but are then monitored by data coming directly from the robot's wheel encoders, and provided here as a feedback signal.</p>"},{"location":"labs/assignment1/part2/#odometry-data-as-a-feedback-signal","title":"Odometry Data as a Feedback Signal","text":"<p>Odometry data can be really useful for robot navigation, allowing us to keep track of where a robot is, how it's moving and how to get back to where we started. We therefore need to know how to use odometry data effectively within our Python nodes, and we'll explore this now.</p>"},{"location":"labs/assignment1/part2/#ex2","title":"Exercise 2: Creating a Python node to process Odometry data","text":"<p>In Part 1 we learnt how to create a package and build simple Python nodes to publish and subscribe to messages on a topic. In this exercise we'll build a new subscriber node, much like you did in the previous session, but this one will subscribe to the <code>/odom</code> topic that we've been talking about above. We'll also create a new package called <code>part2_navigation</code> for this node to live in!</p> <ol> <li> <p>First, head to the <code>src</code> folder of your ROS2 workspace in your terminal:</p> <pre><code>cd ~/ros2_ws/src/\n</code></pre> </li> <li> <p>Then, use the <code>tuos_ros/create_pkg.sh</code> helper script to create your new package:</p> <pre><code>./tuos_ros/create_pkg.sh part2_navigation\n</code></pre> </li> <li> <p>Then navigate into the <code>scripts</code> folder of the new package using the <code>cd</code> command again:</p> <pre><code>cd part2_navigation/scripts/\n</code></pre> </li> <li> <p>The subscriber that we will build here will be structured in much the same way as the subscriber that we built in Part 1. The difference now though is that this one will subscribe to the <code>/odom</code> topic (instead of the rather meaningless <code>\"/my_topic\"</code> topic that we were using in Part 1). </p> <p>As a starting point, copy across the <code>subscriber.py</code> file from your <code>part1_pubsub</code> package:</p> <pre><code>cp ~/ros2_ws/src/part1_pubsub/scripts/subscriber.py ./odom_subscriber.py\n</code></pre> </li> <li> <p>The steps for converting this into an Odometry subscriber are outlined here. </p> </li> <li> <p>You'll need to add a new dependency to your package's <code>package.xml</code> file. Below the <code>&lt;exec_depend&gt;rclpy&lt;/exec_depend&gt;</code> line, add an execution dependency for <code>nav_msgs</code>:</p> package.xml<pre><code>&lt;exec_depend&gt;rclpy&lt;/exec_depend&gt;\n&lt;exec_depend&gt;nav_msgs&lt;/exec_depend&gt;\n</code></pre> </li> <li> <p>Next, declare the new node as an executable. Replace <code>minimal_node.py</code> with <code>odom_subscriber.py</code> in the <code>CMakeLists.txt</code>:</p> CMakeLists.txt<pre><code># Install Python executables\ninstall(PROGRAMS\n  scripts/odom_subscriber.py\n  DESTINATION lib/${PROJECT_NAME}\n)\n</code></pre> </li> <li> <p>Finally, head back to the terminal and use Colon to build the package, and the <code>odom_subscriber.py</code> node:</p> <pre><code>cd ~/ros2_ws/ &amp;&amp; colcon build --packages-select part2_navigation --symlink-install\n</code></pre> </li> <li> <p>Now we're ready to run this! Do so using <code>ros2 run</code> and see what it does:</p> <pre><code>ros2 run part2_navigation odom_subscriber.py\n</code></pre> </li> <li> <p>Have a think about what's different between this and the subscriber from last time...</p> <p>In the Subscriber from Part 1 we were working with a <code>String</code> type message from the <code>std_msgs</code> package, whereas this time we're using an <code>Odometry</code> message from the <code>nav_msgs</code> package instead - notice how the imports and the callback function have changed as a result of this.</p> </li> <li> <p>You need to add some additional code to the callback function now: </p> <ol> <li>The node needs to print the robot's real-time odometry data to the terminal in the form: <code>(x,y,\u03b8<sub>z</sub>)</code>.</li> <li>The format of the message has already been structured for you, but you need to add in the relevant variables that represent the correct elements of the robot's real-time pose.</li> <li>You'll need to use the <code>euler_from_quaternion</code> function (defined within the script) to convert the raw orientation values from Quaternions into Radians. If you need a hint, why not have a look back at this bit from earlier, or at the source code for the <code>robot_pose.py</code> node that we launched from the <code>tuos_examples</code> package in the previous exercise. </li> </ol> </li> <li> <p>Observe how the output (the formatted odometry data) changes whilst you move the robot around using the <code>teleop_keyboard</code> node in a new terminal instance (TERMINAL 3).</p> </li> <li>Stop your <code>odom_subscriber.py</code> node in TERMINAL 2 and the <code>teleop_keyboard</code> node in TERMINAL 3 by entering Ctrl+C in each of the terminals.</li> </ol>"},{"location":"labs/assignment1/part2/#basic-navigation-open-loop-velocity-control","title":"Basic Navigation: Open-loop Velocity Control","text":""},{"location":"labs/assignment1/part2/#ex3","title":"Exercise 3: Velocity Control from a Terminal","text":"<p>Warning</p> <p>Make sure that you've stopped the <code>teleop_keyboard</code> node before starting this exercise!</p> <p>We can use the <code>ros2 topic pub</code> command to publish data to a topic from a terminal by using the command in the following way:</p> <pre><code>ros2 topic pub {topic_name} {message_type} {message_data}\n</code></pre> <p>As we discovered earlier, the <code>/cmd_vel</code> topic is expecting messages containing linear and angular velocity data, each with an <code>x</code>, <code>y</code> and <code>z</code> component. When publishing topic messages in a terminal the commands can get quite long and complicated, but we can use autocomplete functionality to help us format the full command correctly. In TERMINAL 3 type the following, using the Tab key where indicated to invoke autocompletion...</p> <p>TERMINAL 3:</p> <p>First, press Tab to complete the topic name for you:</p> <pre><code>ros2 topic pub /cmd_[TAB]\n</code></pre> <p>Then, press Tab to format the message type correctly: </p> <pre><code>ros2 topic pub /cmd_vel g[TAB]\n</code></pre> <p>Finally, press Tab again to obtain the format of the message data:</p> <pre><code>ros2 topic pub /cmd_vel geometry_msgs/msg/Twist \"l[TAB]\n</code></pre> <p>The full command will then be presented:</p> <pre><code>ros2 topic pub /cmd_vel geometry_msgs/msg/Twist \"linear:\n  x: 0.0\n  y: 0.0\n  z: 0.0\nangular:\n  x: 0.0\n  y: 0.0\n  z: 0.0\"\n</code></pre> <p>Tip</p> <p>You can use Tab to autocomplete lots of terminal commands, experiment with it - it'll save you lots of time! </p> <ol> <li> <p>Scroll back through the message using the Left key on your keyboard and then edit the values of the various parameters, as appropriate. First, define some values that would make the robot rotate on the spot.  </p> </li> <li> <p>Enter Ctrl+C in TERMINAL 3 to stop the message from being published.</p> <p>Warning</p> <p>What happens to the robot when you stop the <code>ros2 topic pub</code> command?</p> <p>... it keeps on moving at the requested velocity!</p> <p>In order to make the robot actually stop, we need to publish a new message containing alternative velocity commands.</p> </li> <li> <p>In TERMINAL 3 press the Up key on your keyboard to recall the previous command, but don't press Enter just yet! Now press the Left key to track back through the message and change the velocity values in order to now make the robot stop.</p> </li> <li> <p>Once again, enter Ctrl+C in TERMINAL 3 to stop the publisher from actively publishing new messages, and then follow the same steps as above to compose another new message to now make the robot move in a circle.</p> </li> <li> <p>Enter Ctrl+C to again stop the message from being published, publish a further new message to stop the robot, and then compose (and publish) a message that would make the robot drive in a straight line.</p> </li> <li> <p>Finally, stop the robot again!</p> </li> </ol>"},{"location":"labs/assignment1/part2/#ex4","title":"Exercise 4: Creating a Python node to make the robot move in a circle","text":"<p>You will now learn how to control the velocity of the robot through a Python Node. In Pat 1 you built a simple publisher node, and this one will effectively be the same thing, this time however, we need to publish <code>Twist</code> type messages to the <code>/cmd_vel</code> topic instead... </p> <p>In TERMINAL 2, ensure that you're located within the <code>scripts</code> folder of your <code>part2_navigation</code> package (you could use <code>pwd</code> to check your current working directory).</p> <p>If you aren't located here then navigate to this directory using <code>cd</code>.</p> <ol> <li> <p>Create a new file called <code>move_circle.py</code>:</p> <p>TERMINAL 2: <pre><code>touch move_circle.py\n</code></pre> ... and make this file executable using the <code>chmod</code> command.</p> </li> <li> <p>Open up this file in VS Code. </p> <p>Use this code template to get you started:</p> A template for the move_circle.py node<pre><code>#!/usr/bin/env python3\n\nimport rclpy # (1)\nfrom rclpy.node import Node\n\n# (2)\n\nclass Circle(Node):\n\n    def __init__(self):\n        super().__init__(\"\") # (3)\n\n        self.publisher = self.create_publisher() # (4)\n        rate = # (5)\n        self.timer = self.create_timer(1/rate, self.timer_callback)\n\n        self.shutdown = False\n\n    def on_shutdown(self):\n        # (6)\n\n        self.shutdown = True\n\n    def timer_callback(self):\n        # (7)\n\ndef main(args=None):\n    rclpy.init(\n        args=args,\n        signal_handler_options=rclpy.signals.SignalHandlerOptions.NO\n    )\n\n    move_circle = # (8)\n\n    try: # (9)\n        rclpy.spin(move_circle)\n    except KeyboardInterrupt:\n        print(\"Shutdown requested with Ctrl+C\")\n    finally:\n        move_circle.on_shutdown()\n\n        while not move_circle.shutdown:\n            continue\n\n        move_circle.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n</code></pre> <ol> <li>This is important, we always need to import the ROS Client Library for Python (<code>rclpy</code>), plus a <code>Node</code> class (to use as the basis for you own ROS node).</li> <li>What other imports might we need here in order to create and publish a message to make the robot move?</li> <li>Give your node a descriptive name - this is the name that it will be given when it is registered on the ROS network, and the one that you would see if you used the <code>ros2 node list</code> command.</li> <li>What do you need to add here in order to set up an appropriate publisher to the <code>/cmd_vel</code> topic?</li> <li>Define an appropriate rate at which to publish velocity messages, and use this to set up a timer.</li> <li> <p>We'll use this to perform some important shutdown operations after a user has requested for the node to stop (using Ctrl+C), but before it actually does so. </p> <p>Question</p> <p>What actions would be important to take here to make sure the node shuts down safely and the robot actually stops moving?</p> <p>We'll call this method from <code>main()</code> before ultimately terminating the node (see later on in the code).</p> </li> <li> <p>You're going to need to create a message here containing appropriate velocities for the robot to move at. Then you'll need to actually publish that message to <code>/cmd_vel</code> (via your <code>self.publisher</code>). Running this inside a timer callback means that it will execute the rate that we specified in the <code>__init__</code></p> </li> <li> <p>What will you need to do here to instantiate your <code>Circle()</code> class?</p> </li> <li> <p>We call <code>rclpy.spin()</code> inside a Try - Except block, so that we can catch a <code>KeyboardInterrupt</code> (i.e. a Ctrl+C input from the user) during execution of the node. All shutdown procedures are executed from within a <code>finally</code> block, which ensures that all of these vital steps take place when an exception is raised (whether that's a <code>KeyboardInterrupt</code> or otherwise).</p> </li> </ol> </li> </ol> <ol> <li> <p>Quaternions are explained very nicely here, if you'd like to learn more.\u00a0\u21a9</p> </li> </ol>"},{"location":"labs/assignment1/part3/","title":"Part 3: SLAM and Autonomous Navigation","text":""},{"location":"labs/assignment1/part3/#introduction","title":"Introduction","text":"<p> Exercises: X</p> <p> Estimated Completion Time: Y</p>"},{"location":"labs/assignment1/part3/#aims","title":"Aims","text":"<p>From the work you did in Part 2 you may have started to appreciate the limitations associated with using odometry data alone as a feedback signal when trying to control a robot's position in its environment. In this next part you will explore an alternative data-stream that could be used to aid navigation further. You will leverage some existing ROS 2 libraries and TurtleBot3 packages to explore some really powerful mapping and autonomous navigation methods that are available within ROS.</p>"},{"location":"labs/assignment1/part3/#intended-learning-outcomes","title":"Intended Learning Outcomes","text":"<p>By the end of this session you will be able to:</p> <p>//add to the ILOs// </p> <ol> <li>Interpret the data that is published to the <code>/scan</code> topic and use existing ROS tools to visualise this.</li> <li>Use existing ROS tools to implement SLAM and build a map of an environment. </li> <li>Leverage existing ROS libraries to make a robot navigate an environment autonomously, using the map that you have generated.</li> <li>Explain how these SLAM and Navigation tools are implemented and what information is required in order to make them work.</li> </ol>"},{"location":"labs/assignment1/part3/#quick-links","title":"Quick Links","text":"<ul> <li>Exercise 1: Using RViz to Visualise Robot Data</li> <li>Exercise 2: Building a map of an environment with SLAM</li> <li>Exercise 3: Navigating an Environment Autonomously</li> </ul>"},{"location":"labs/assignment1/part3/#getting-started","title":"Getting Started","text":"<p>Step 1: Launch your ROS Environment</p> <p>If you haven't done so already, launch your ROS environment now:</p> <ol> <li>Option 1 </li> <li>Option 2</li> <li>Option 3</li> </ol> <p>Step 2: Make Sure The Course Repo is Up-To-Date</p> <p>In Part 1 you should have downloaded and installed The Course Repo into your ROS environment. Hopefully you've done this by now, but if you haven't then go back and do it now (you'll need it for some exercises here). If you have already done it, then (once again) it's worth just making sure it's all up-to-date, so run the following command now to do so:</p> <p>TERMINAL 1: <pre><code>cd ~/ros2_ws/src/tuos_ros/ &amp;&amp; git pull\n</code></pre></p> <p>Then build with Colcon: </p> <pre><code>cd ~/ros2_ws/ &amp;&amp; colcon build\n</code></pre> <p>And finally, re-source your environment:</p> <pre><code>source ~/.bashrc\n</code></pre> <p>Warning</p> <p>If you have any other terminal instances open, then you'll need run <code>source ~/.bashrc</code> in these too, in order for any changes made by the Colcon build process to propagate through to these as well.</p>"},{"location":"labs/assignment1/part3/#lidar","title":"Laser Displacement Data and The LiDAR Sensor","text":"<p>As you'll know from Part 2, odometry is really important for robot navigation, but it can be subject to drift and accumulated error over time.</p>"},{"location":"labs/assignment1/part3/#ex1","title":"Exercise 1: Using RViz to Visualise Robot Data","text":"<p>We're now going to place the robot in a more interesting environment than the \"empty world\" we've used in the previous parts of this course so far...</p> <ol> <li> <p>In TERMINAL 1 enter the following command to launch this:</p> <p>//need to check// <pre><code>ros2 launch turtlebot3_gazebo x.launch.py\n</code></pre> A Gazebo simulation should now be launched with a TurtleBot3 Waffle in a new environment:</p> </li> <li> <p>Open a new terminal instance (TERMINAL 2) and enter the following:</p> <p>TERMINAL 2: <pre><code>ros2 launch tuos_simulations rviz.launch launch\n</code></pre></p> <p>On running the command a new window should open:</p> <p>This is RViz, which is a ROS tool that allows us to visualise the data being measured by a robot in real-time. The red dots scattered around the robot represent laser displacement data which is measured by the LiDAR sensor located on the top of the robot.  This data allows the robot to measure the distance to any obstacles in its immediate surroundings. The LiDAR sensor spins continuously, sending out laser pulses as it does so. These laser pulses then bounce off any objects and are reflected back to the sensor. Distance can then be determined based on the time it takes for the pulses to complete the full journey (from the sensor, to the object, and back again), by a process called \"time of flight\". Because the LiDAR sensor spins and performs this process continuously, a full 360\u00b0 scan of the environment can be generated.  In this case (because we are working in simulation here) the data represents the objects surrounding the robot in its simulated environment, so you should notice that the red dots produce an outline that resembles the objects in the world that is being simulated in Gazebo (or partially at least).</p> </li> </ol>"},{"location":"labs/assignment1/part4/","title":"Part 4: ROS 2 Services","text":""},{"location":"labs/assignment1/part4/#introduction","title":"Introduction","text":"<p> Exercises: X</p> <p> Estimated Completion Time: Y hours</p>"},{"location":"labs/assignment1/part4/#aims","title":"Aims","text":"<p>In this part you will learn about ROS Services, a communication method that facilitates request-response interactions between nodes. You will understand how to use ROS services in combination with standard publisher/subscriber principles to enhance control for specific operations. Additionally, you'll create custom messages and services for tailored communication.</p>"},{"location":"labs/assignment1/part4/#intended-learning-outcomes","title":"Intended Learning Outcomes","text":"<p>By the end of this session you will be able to:</p> <ol> <li>Recognise how ROS Services differ from the standard topic-based publisher-subscriber approach, and identify appropriate use-cases for this type of messaging system.</li> <li>Implement Python node pairs to observe services in action, and understand how they work.</li> <li>Invoke different services using a range of service message types.</li> <li>Develop Python Service nodes of your own to perform specific robotic tasks.</li> <li>Harness Services, in combination with LiDAR data, to implement a basic obstacle avoidance behaviour </li> <li>Develop custom ROS messages and services (still need to think about the task for this) </li> <li>Demonstrate your understanding of ROS2 so far by developing a Python node which incorporates elements from this and previous parts of this course.</li> </ol>"},{"location":"labs/assignment1/part4/#quick-links","title":"Quick Links","text":"<ul> <li>Exercise 1: </li> </ul>"},{"location":"labs/assignment1/part4/#additional-resources","title":"Additional Resources","text":""},{"location":"labs/assignment1/part4/#prerequisites","title":"Prerequisites","text":"<p>Before we begin, ensure that you have the following:</p> <ol> <li>ROS2 Humble installed on your system</li> <li>Cloned the tuos package from github</li> <li>Basic understanding of ROS2 concepts like nodes and topics</li> </ol>"},{"location":"labs/assignment1/part4/#getting-started","title":"Getting Started","text":"<p>Step 1: Launch your ROS Environment</p> <p>If you haven't done so already, launch your ROS environment now:</p> <p>Step 2: Restore your work (todo)</p> <p>Step 3: Launch VS Code (todo) </p> <p>Step 4: Make Sure The Course Repo is Up-To-Date</p> <p>Once again, it's worth quickly checking that the Course Repo is up-to-date before you start on the Part 4 exercises. Go back to Part 1 if you haven't installed it yet (really?!). For the rest of us, see here for how to update.</p> <p>Step 5: Launch the Robot Simulation</p> <p>In TERMINAL 1 enter the following command to launch a simulation of a TurtleBot3 Waffle in an empty world:  </p> <p>TERMINAL 1: <pre><code>ros2 launch turtlebot3_gazebo empty_world.launch.py\n</code></pre> ...and then wait for the Gazebo window to open:</p> <p>have to add an image here</p>"},{"location":"labs/assignment1/part4/#an-introduction-to-services","title":"An Introduction to Services","text":"<p>So far, we've learnt about ROS topics and messages, and how individual nodes can access data on a robot by simply subscribing to topics that are being published by any other node on the system.  In addition to this, we also learnt how any node can publish messages to any topic: this essentially broadcasts the data contained in the message across the ROS Network, making it available to any other node on the network that may wish to access it.</p> <p>Another way to pass data between ROS Nodes is by using Services.  These are different to messages in that \"Service calls\" (that is, the process of requesting a service) occur only between one node and another:</p> <ul> <li>One node (a Service Client) sends a Request to another node.</li> <li>Another node (a Service Server) processes that request, performs an action and then sends back a Response.</li> </ul> <p></p> <p>Services are Synchronous (or sequential): When a ROS node sends a request to a service (as a Service Client) it can't do anything else until the service has been completed and the Service Server has sent a response back. This can be useful for a few reasons:</p> <ol> <li> <p>Discrete, short-duration actions: A robot might need to do something before it can move on to something else, e.g.:</p> <ul> <li>A robot needs to see something before it can move towards it.</li> <li>High definition cameras generate large amounts of data and consume battery power, so you may wish to turn a camera on for a specific amount of time (e.g. until an image has been captured) and then turn it off again.</li> </ul> </li> <li> <p>Computations: Remember that ROS is network-based, so you might want to offload some computations to a remote computer or a different device on a robot, e.g.:</p> <ul> <li>A client might send some data and then wait for another process (the server) to process it and send back the result.</li> </ul> </li> </ol> <p>It's also worth noting that any number of ROS Client nodes can call a service, but you can only have a single Server providing that particular service at any one time.</p> <p></p> <p>Question</p> <p>Can you think of any other scenarios where this type of communication protocol might be useful?</p>"},{"location":"labs/assignment1/part4/#ex1","title":"Exercise 1: Creating a Service Server in Python and calling it from the command-line","text":"<p>To start with, let's set up a service and learn how to make a call to it from the command-line to give you an idea of how this all works and why it might be useful.</p> <ol> <li> <p>First open up a new terminal instance (TERMINAL 2) and source your ROS2 environment as you did in part 1.</p> </li> <li> <p>Now navigate into the <code>ros2_ws/src</code> directory created in part 1 and create the <code>part4_services</code> package. Define <code>python</code> as a build type and <code>rclpy</code>, <code>geometry_msgs</code> and <code>tuos_msgs</code> as dependencies.</p> <p>TERMINAL 2: <pre><code>ros2 pkg create --build-type ament_cmake \n</code></pre></p> <p>Your terminal will return a message verifying the creation of your package.</p> <p>The <code>--dependencies</code> argument adds the necessary dependency lines to the <code>package.xml</code> file</p> <p>Info</p> <p><code>rclpy</code> is the Python library that provides the core functionality for interacting with ROS 2. It's the Python counterpart to the C++ client library, <code>rclcpp</code>.</p> </li> <li> <p>Then navigate into the <code>ros2_ws/src/part4_services/part4_services</code> and create an empty file called <code>move_server.py</code> using <code>touch</code> command.     <pre><code>touch move_server.py\n</code></pre></p> </li> <li> <p>Then, open the file in VS Code, copy and paste this code and then save it.  (todo: need to add the template)</p> <p>Note</p> <p>It's really important that you understand how the code above works, so that you know how to build your own service Servers in Python.</p> </li> <li> <p>Updating the package.xml file (todo)</p> </li> <li> <p>Next, open the setup.py file in your package directory and add an entry point for the <code>move_server</code> node:</p> <pre><code>entry_points={\n    'console_scripts': [\n        'move_server = part4_services.move_server:main',\n    ]\n}\n</code></pre> <p>Build and run:</p> </li> <li> <p>It's a good practice to run <code>rosdep</code> in the root of your workspace (<code>ros2_ws</code>) to check for missing dependencies before building:</p> <pre><code>rosdep install -i --from-path src --rosdistro humble -y\n</code></pre> </li> <li> <p>Finally, use Colcon to build your new package and its contents </p> <pre><code>cd ~/ros2_ws/ &amp;&amp; colcon build --packages-select part4_services --symlink-install\n</code></pre> </li> <li> <p>Now, we are ready to run the node. Use <code>ros2 run</code> and observe what is displayed on the terminal </p> <pre><code>ros2 run part4_services move_server\n</code></pre> </li> <li> <p>Then open another terminal window (TERMINAL 3) and source the setup files from inside the root directory again. </p> </li> <li> <p>While the node is running, use <code>ros2 service</code> command to view all the currently active services on the system:</p> <p>TERMINAL 3: <pre><code>ros2 service list\n</code></pre></p> <p>You should be able to see the service (todo)</p> </li> </ol>"},{"location":"labs/assignment1/part4/#ex2","title":"Exercise 2: Creating a Python Service Client Node","text":"<p>As well as calling a service from the command-line we can also build Python nodes to do the same thing (i.e. we can build Python Service Client Nodes). In this exercise you will learn how this is done.</p> <ol> <li> <p>TERMINAL 3 should be idle, so from here navigate to the <code>part4_service/</code> folder within the <code>part4_services</code> package that we created earlier:</p> <p>TERMINAL 3: <pre><code>cd ~/ros2_ws/src/part4_service/part4_services\n</code></pre></p> <ol> <li>Create a new file called <code>move_client.py</code></li> <li>Now as you did in the previous exercise, open the VS Code, copy and paste this code and then save it.  (todo: need to add the template)</li> </ol> <p>Note</p> <p>Once again, be sure to read the code and understand how this Python Service Client Node works too!</p> </li> <li> <p>Next, open the setup.py file (in VS Code) in your package directory and add another entry point for the <code>move_client</code> under the line where you added <code>move_server</code> previously:</p> <pre><code>entry_points={\n    'console_scripts': [\n        'move_server = part4_services.move_server:main',\n        'move_client = part4_services.move_client:main',\n    ]\n}\n</code></pre> </li> <li> <p>Return to TERMINAL 3 and launch the node using <code>ros2 run</code>:</p> <pre><code>ros2 run part4_services move_client\n</code></pre> </li> </ol> <p>TODO : ROS2 service call and creating a custom .msg and .srv</p> <p>Understanding key features  todo: ros2 service type     ros2 service find     ros2 interface show     ros2 service call</p>"},{"location":"labs/assignment1/part4/#ex3","title":"Exercise 3: Learn to create custom messages and service","text":""},{"location":"labs/assignment1/part4/#ex4","title":"Exercise 4: Creating your own Service","text":"<p>In this exercise you will create your own service Server to make the Waffle perform a specific movement for a given amount of time and then stop.</p>"},{"location":"labs/assignment1/part1/publisher/","title":"A Simple Publisher Node","text":""},{"location":"labs/assignment1/part1/publisher/#the-code","title":"The Code","text":"<p>Copy all the code below into your <code>publisher.py</code> file and review the annotations to understand how it all works.</p> <p>Tip</p> <p>Don't forget the Shebang! See below for further details...</p> publisher.py<pre><code>#!/usr/bin/env python3\n# A simple ROS2 Publisher\n\nimport rclpy # (1)!\nfrom rclpy.node import Node\n\nfrom example_interfaces.msg import String # (2)!\n\nclass SimplePublisher(Node): # (3)!\n\n    def __init__(self):\n        super().__init__(\"simple_publisher\") # (4)!\n\n        self.my_publisher = self.create_publisher(\n            msg_type=String,\n            topic=\"my_topic\",\n            qos_profile=10,\n        ) # (5)!\n\n        publish_rate = 1 # Hz\n        self.timer = self.create_timer(\n            timer_period_sec=1/publish_rate, \n            callback=self.timer_callback\n        ) # (6)!\n\n        self.get_logger().info(\n            f\"The '{self.get_name()}' node is initialised.\" # (7)!\n        )\n\n    def timer_callback(self): # (8)!\n        ros_time = self.get_clock().now().seconds_nanoseconds()\n\n        topic_msg = String()\n        topic_msg.data = f\"The ROS time is {ros_time[0]} (seconds).\"\n        self.my_publisher.publish(topic_msg)\n        self.get_logger().info(f\"Publishing: '{topic_msg.data}'\")\n\ndef main(args=None): # (9)!\n    rclpy.init(args=args)\n    my_simple_publisher = SimplePublisher()\n    rclpy.spin(my_simple_publisher)\n    my_simple_publisher.destroy_node()\n    rclpy.shutdown()\n\nif __name__ == '__main__': # (10)!\n    main()\n</code></pre> <ol> <li> <p><code>rclpy</code> is the ROS Client Library for Python. </p> <p>This is a vital import that allows us to create ROS nodes and initialise them on the ROS network.</p> <p>We also import the <code>Node</code> class from the <code>rclpy.node</code> library. This is a ready-made Python Class that contains all the necessary functionality that a Python ROS Node might need, so we'll use this as the basis for our own node (which we'll create shortly).</p> </li> <li> <p>We also need to import the <code>String</code> message type from the <code>example_interfaces.msg</code> library for publishing our messages.</p> </li> <li> <p>We create a Python class called <code>SimplePublisher()</code>, which we'll use to encapsulate all the functionality of our node.</p> <p>The vast majority of the functionality of this node is inherited from the <code>rclpy.node</code>, <code>Node()</code> Class which we imported above. </p> </li> <li> <p>Using the <code>super()</code> method we call the <code>__init__()</code> method from the parent Node class that our <code>SimplePublisher</code> class is derived from.</p> <p>We provide a name here, which is the name that will be used to register our node on the ROS network (we can call the node anything that we want, but it's a good idea to call it something meaningful).</p> </li> <li> <p>We then use the <code>create_publisher()</code> method (inherited from the <code>Node</code> class) in order to provide our node with the ability to publish messages to a ROS Topic. When calling this we provide 3 key bits of information:</p> <ol> <li> <p><code>msg_type</code>: The type of message that we want to publish.</p> <p>In our case, a <code>String</code> message from the <code>example_interfaces.msg</code> module.</p> </li> <li> <p><code>topic</code>: The name of the topic that we want to publish these messages to.</p> <p>This could be an existing topic (in which case, we'd need to make sure we used the correct message type), or a new topic (in which case, the name can be anything we want it to be).</p> <p>In our case, we want to create a new topic on the ROS network called <code>\"my_topic\"</code>.</p> </li> <li> <p><code>qos_profile</code>: A queue size, which is a \"Quality of Service\" (QoS) setting which limits the amount of messages that are queued in a buffer. </p> <p>In our case, we're setting this to <code>10</code>, which is generally appropriate for most of the applications that we'll be working on.</p> </li> </ol> </li> <li> <p>Here, we're calling the <code>create_timer()</code> method, which we'll use to control the rate at which messages are published to our topic. Here we define 2 things:</p> <ol> <li> <p><code>timer_period_sec</code>: The rate at which we want the timer to run. This must be provided as a period, in seconds. In the line above, we have specified a publishing frequency (in Hz):</p> <p><code>publish_rate = 1 # Hz</code></p> <p>So the associated time period (in seconds) is: </p> <p>\\(T = \\frac{1}{f}\\)</p> </li> <li> <p><code>callback</code>: This is a function that will be executed every time the timer elapses at the desired rate (1 Hz). We're specifying a function called <code>timer_callback</code>, which we'll define later on in the code...</p> </li> </ol> </li> <li> <p>Finally, we use the <code>get_logger().info()</code> method to send a Log message to the terminal to inform us that the initialisation of our node is complete.</p> </li> <li> <p>Here we define the timer callback function. Anything in here will execute at the rate that we specified when we created the <code>create_timer()</code> instance before. In our case:</p> <ol> <li>Use the <code>get_clock()</code> method to get the current ROS Time.</li> <li>Instantiate a <code>String()</code> message (defined as <code>topic_msg</code>).</li> <li>Populate this message with data. In our case, a statement that includes the ROS Time, as obtained above.</li> <li>Call the <code>publish()</code> method of our <code>my_publisher</code> object, to actually publish this message to the <code>\"my_topic\"</code> topic.</li> <li>Send the message data to the terminal as a log message as well, so that we can see what it is when our Node is actually running.</li> </ol> </li> <li> <p>With the functionality of our <code>SimplePublisher</code> class now established, we define a <code>main()</code> function for the Node. This will be fairly common to most Python Nodes that we create, with the following 5 key processes:</p> <ol> <li>Initialise the <code>rclpy</code> library.</li> <li>Create an instance of our <code>SimplePublisher()</code> node.</li> <li>\"Spin\" the node to keep it alive so that any callbacks can execute as required (in our case here, just the <code>timer_callback()</code>). </li> <li>Destroy the node once termination is requested (triggered by entering Ctrl+C in the terminal).</li> <li>Shutdown the <code>rclpy</code> library.</li> </ol> </li> <li> <p>Finally, we call the <code>main()</code> function to set everything going. We do this inside an <code>if</code> statement, to ensure that our node is the main executable (i.e. it has been executed directly (via <code>ros2 run</code>), and hasn't been called by another script)</p> </li> </ol>"},{"location":"labs/assignment1/part1/publisher/#defining-package-dependencies","title":"Defining Package Dependencies","text":"<p>We're importing a couple of Python libraries into our node here, which means that our package has two dependencies: <code>rclpy</code> and <code>example_interfaces</code>:</p> <pre><code>import rclpy \nfrom rclpy.node import Node\n\nfrom example_interfaces.msg import String\n</code></pre> <p>Its good practice to add these dependencies to your <code>package.xml</code> file. Locate this file (<code>ros2_ws/src/part1_pubsub/package.xml</code>), open it up and find the following line:</p> <pre><code>&lt;exec_depend&gt;rclpy&lt;/exec_depend&gt;\n</code></pre> <p><code>rclpy</code> is therefore already defined as an execution dependency (which means that our package needs this library in order to execute our code), but we need to add <code>example_interfaces</code> as well, so add the following additional line underneath:</p> <pre><code>&lt;exec_depend&gt;example_interfaces&lt;/exec_depend&gt;\n</code></pre> <p>Job done. Save the file and close it.</p>"},{"location":"labs/assignment1/part1/publisher/#shebang","title":"The Shebang","text":"<p>The very first line of code looks like a comment, but it is actually a very crucial part of the script:</p> <pre><code>#!/usr/bin/env python3\n</code></pre> <p>This is called the Shebang, and it tells the operating system which interpreter to use to execute the code. In our case here, it tells the operating system where to find the right Python interpreter that should be used to actually run the code.</p> <p> \u2190 Back to Part 1 </p>"},{"location":"labs/assignment1/part1/subscriber/","title":"A Simple Subscriber Node","text":""},{"location":"labs/assignment1/part1/subscriber/#the-code","title":"The Code","text":"<p>Copy all the code below into your <code>subscriber.py</code> file and (again) make sure you read the annotations to understand how it all works!</p> subscriber.py<pre><code>#!/usr/bin/env python3\n# A simple ROS2 Subscriber\n\nimport rclpy # (1)!\nfrom rclpy.node import Node\n\nfrom example_interfaces.msg import String\n\nclass SimpleSubscriber(Node): # (2)! \n\n    def __init__(self): \n        super().__init__(\"simple_subscriber\") # (3)!\n\n        self.my_subscriber = self.create_subscription(\n            msg_type=String,\n            topic=\"{BLANK}\",\n            callback=self.msg_callback,\n            qos_profile=10,\n        ) # (4)!\n\n        self.get_logger().info(\n            f\"The '{self.get_name()}' node is initialised.\"\n        ) # (5)!\n\n    def msg_callback(self, topic_message: String): # (6)!\n        # (7)!\n        self.get_logger().info(f\"The '{self.get_name()}' node heard:\") \n        self.get_logger().info(f\"'{topic_message.data}'\")\n\ndef main(args=None): # (8)!\n    rclpy.init(args=args)\n    my_simple_subscriber = SimpleSubscriber()\n    rclpy.spin(my_simple_subscriber)\n    my_simple_subscriber.destroy_node()\n    rclpy.shutdown() \n\nif __name__ == '__main__':\n    main()\n</code></pre> <ol> <li> <p>As with our publisher node, we need to import the <code>rclpy</code> client library and the <code>String</code> message type from the <code>example_interfaces.msg</code> library in order to write a Python ROS Node and use the relevant ROS messages:</p> </li> <li> <p>This time, we create a Python Class called <code>SimpleSubscriber()</code> instead, but which still inherits the <code>Node</code> class from <code>rclpy</code> as we did with the Publisher before.</p> </li> <li> <p>Once again, using the <code>super()</code> method we call the <code>__init__()</code> method from the parent Node class that our <code>SimpleSubscriber</code> class is derived from, and provide a name to use to register in on the network.</p> </li> <li> <p>We're now using the <code>create_subscription()</code> method here, which will allow this node to subscribe to messages on a ROS Topic. When calling this we provide 4 key bits of information:</p> <ol> <li> <p><code>msg_type</code>: The type of message that the topic uses (which we could obtain by running the <code>ros2 topic info</code> command).</p> <p>We know (having just created the publisher), that our topic uses <code>String</code> messages (from <code>example_interfaces</code>).</p> </li> <li> <p><code>topic</code>: The name of the topic that we want to listen (or subscribe) to.</p> <p>Fill in the Blank!</p> <p>Replace the <code>{BLANK}</code> in the code above with the name of the topic that our <code>publisher.py</code> node was set up to publish to!</p> </li> <li> <p><code>callback</code>: When building a subscriber, we need a callback function, which is a function that will execute every time a new message is received from the topic.</p> <p>At this stage, we define what this callback function is called (<code>self.msg_callback</code>), and we'll actually define the function itself further down within the Class.</p> </li> <li> <p><code>qos_profile</code>: As before, a queue size to limit the amount of messages that are queued in a buffer. </p> </li> </ol> </li> <li> <p>Print a Log message to the terminal to indicate that the initialisation process has taken place.</p> </li> <li> <p>Here we're defining what will happen each time our subscriber receives a new message. This callback function must have only one argument (other than <code>self</code>), which will contain the message data that has been received:</p> <p>We're also using a Python Type Annotation here too, which informs the interpreter that the <code>topic_message</code> that is received by the <code>msg_callback</code> function will be of the <code>String</code> data type.</p> <p>(All this really does is allow autocomplete functionality to work within our text editor, so that whenever we want to pull an attribute from the <code>toic_message</code> object it will tell us what attributes actually exist within the object.)</p> </li> <li> <p>In this simple example, all we're going to do on receipt of a message is to print a couple of log messages to the terminal, to include: </p> <ol> <li> <p>The name of this node (using the <code>self.get_name()</code> method)</p> </li> <li> <p>The message that has been received (<code>topic_mesage.data</code>)</p> </li> </ol> </li> <li> <p>The rest of this is exactly the same as before with our publisher.</p> </li> </ol>"},{"location":"labs/assignment1/part1/subscriber/#dfts","title":"Don't Forget the Shebang!","text":"<p>Remember: don't forget the shebang, it's very important!</p> <pre><code>#!/usr/bin/env python3\n</code></pre> <p> \u2190 Back to Part 1 </p>"},{"location":"labs/assignment1/part2/odom_subscriber/","title":"An Odomerty Subscriber Node","text":""},{"location":"labs/assignment1/part2/odom_subscriber/#the-initial-code","title":"The Initial Code","text":"<p>Having copied the <code>subscriber.py</code> file from your <code>part1_pubsub</code> package, you'll start out with the following code:</p> <pre><code>#!/usr/bin/env python3\n# A simple ROS2 Subscriber\n\nimport rclpy\nfrom rclpy.node import Node\n\nfrom example_interfaces.msg import String\n\nclass SimpleSubscriber(Node):\n\n    def __init__(self): \n        super().__init__(\"simple_subscriber\")\n\n        self.my_subscriber = self.create_subscription(\n            msg_type=String,\n            topic=\"{BLANK}\",\n            callback=self.msg_callback,\n            qos_profile=10,\n        )\n\n        self.get_logger().info(\n            f\"The '{self.get_name()}' node is initialised.\"\n        )\n\n    def msg_callback(self, topic_message: String):\n        # (7)!\n        self.get_logger().info(f\"The '{self.get_name()}' node heard:\") \n        self.get_logger().info(f\"'{topic_message.data}'\")\n\ndef main(args=None):\n    rclpy.init(args=args)\n    my_simple_subscriber = SimpleSubscriber()\n    rclpy.spin(my_simple_subscriber)\n    my_simple_subscriber.destroy_node()\n    rclpy.shutdown() \n\nif __name__ == '__main__':\n    main()\n</code></pre> <p>Let's look at what we need to change now.</p>"},{"location":"labs/assignment1/part2/odom_subscriber/#from-simple-subscriber-to-odom-subscriber","title":"From Simple Subscriber to Odom Subscriber","text":""},{"location":"labs/assignment1/part2/odom_subscriber/#imports","title":"Imports","text":"<p>We will generally rely on <code>rclpy</code> and the <code>Node</code> class from the <code>rclpy.node</code> library, for most nodes that we will create, so our first two imports will remain the same. </p> <p>We won't be working with <code>String</code> type messages any more however, so we need to replace this line in order to import the correct message type. As we know from earlier in Part 2, the <code>/odom</code> topic uses messages of the type <code>nav_msgs/msg/Odometry</code>:</p> <pre><code>$ ros2 topic info /odom\nType: nav_msgs/msg/Odometry\n...\n</code></pre> <p>This tells us everything we need to know to construct the Python import statement correctly:</p> <pre><code>from nav_msgs.msg import Odometry\n</code></pre> <p>We'll also need to import a handy function that should already exist as an importable module in your <code>part2_navigation</code> package called <code>tb3_tools</code>:</p> <pre><code>from part2_navigation.tb3_tools import quaternion_to_euler\n</code></pre> <p>As the name suggests, we'll use this to convert the raw orientation values from <code>/odom</code> into their Euler Angle representation.</p> Info <p>This module can be found here: <code>part2_navigation/part2_navigation/tb3_tools.py</code>, if you want to have a look.</p>"},{"location":"labs/assignment1/part2/odom_subscriber/#change-the-class-name","title":"Change the Class Name","text":"<p>Previously our class was called <code>SimpleSubscriber()</code>, change this to something more appropriate now, e.g.: <code>OdomSubscriber()</code>.</p>"},{"location":"labs/assignment1/part2/odom_subscriber/#initialising-the-class","title":"Initialising the Class","text":"<p>The structure of this remains largely the same, we just need to modify a few things: </p> <ol> <li> <p>Change the name that is used to register the node on the ROS Network:</p> <pre><code>super().__init__(\"odom_subscriber\")\n</code></pre> </li> <li> <p>Change the subscription parameters:</p> <pre><code>self.my_subscriber = self.create_subscription(\n    msg_type=Odometry, # (1)!\n    topic=\"odom\", # (2)!\n    callback=self.msg_callback, \n    qos_profile=10,\n)\n</code></pre> <ol> <li><code>/odom</code> uses the Odometry message type (as imported above)</li> <li>The topic name is <code>\"odom\"</code>, of course!</li> </ol> </li> </ol> <p>The final thing we'll do inside our class' <code>__init__</code> method (after we've set up the subscriber) is initialise a counter:</p> <pre><code>self.counter = 0 \n</code></pre> <p>The reason for this will become clear shortly...</p>"},{"location":"labs/assignment1/part2/odom_subscriber/#modifying-the-message-callback","title":"Modifying the Message Callback","text":"<p>This is where the changes are a bit more significant...</p> <pre><code>def msg_subscriber(self, topic_message: Odometry): # (1)!\n\n    pose = topic_data.pose.pose # (2)!\n\n    # (3)!\n    pos_x = pose.position.x\n    pos_y = pose.position.y\n    pos_z = pose.position.z\n\n    roll, pitch, yaw = quaternion_to_euler(pose.orientation) # (4)!\n\n    if self.counter &gt; 10: # (5)!\n        self.counter = 0\n        print(f\"x = {pos_x:.3f} (m), y = ? (m), theta_z = ? (radians)\") # (6)!\n    else:\n        self.counter += 1\n</code></pre> <ol> <li>When defining our message callback, we should modify the type of the <code>topic_message</code> input.</li> <li> <p>There are two key parts to an odometry message: Pose and Twist.</p> <p>We're only really interested in the Pose part of the message here, so grab this first.</p> </li> <li> <p>As we know by now, Pose contains information about both the \"position\" and \"orientation\" of the robot, we extract the position values first and assign them to the variables <code>pos_x</code>, <code>pos_y</code> and <code>pos_z</code>.</p> <p>Position data is provided in meters, so we don't need to do any conversion on this and can use the data directly.</p> </li> <li> <p>Orientation data is in quaternions, so we convert this by passing it to the <code>quaternion_to_euler</code> function that we imported from <code>tb3_tools</code> earlier.</p> <p>This function provides us with the orientation of the robot about its 3 principal axes:</p> <ul> <li><code>\u03b8<sub>x</sub></code>: \"Roll\"</li> <li><code>\u03b8<sub>y</sub></code>: \"Pitch\"</li> <li><code>\u03b8<sub>z</sub></code>: \"Yaw\"</li> </ul> </li> <li> <p>Here we print out the values that we're interested in to the terminal.</p> <p>This callback function will execute every time a new message is published to the <code>odom</code> topic, which occurs at a rate of around 20 times per second (20 Hz).</p> Tip <p>We can use he <code>ros2 topic hz</code> function to tell us this:</p> <pre><code>$ ros2 topic hz /odom\naverage rate: 18.358\nmin: 0.037s max: 0.088s std dev: 0.01444s window: 20\n</code></pre> <p>That's a lot of messages to be printed to the terminal every second! We therefore use an <code>if</code> statement and a <code>counter</code> to ensure that our <code>print</code> statement only executes for 1 in every 10 topic messages instead.</p> </li> <li> <p>Task: Continue formatting the <code>print</code> message to display the three odometry values that are relevant to our robot!  </p> </li> </ol>"},{"location":"labs/assignment1/part2/odom_subscriber/#updating-main","title":"Updating \"Main\"","text":"<p>The only thing left to do now is update any relevant parts of the <code>main</code> function to ensure that you are instantiating, spinning and shutting down your node correctly.</p> <p> \u2190 Back to Part 2 </p>"},{"location":"labs/assignment2/","title":"Assignment #2: Team Robotics Project","text":""},{"location":"labs/assignment2/#overview","title":"Overview","text":"<p>In Assignment #2 you will put into practice everything that you learn about ROS in Assignment #1, and explore the capabilities of the framework further.</p> <p>You will attend a 2-hour lab session per week in Diamond Computer Room 5 for the full 12-week semester. You will work in teams to develop ROS Nodes for our TurtleBot3 Waffles that allow them to successfully complete a series of robotics tasks, most of which in a real-world environment. There are XXX tasks to complete in total, all of which will be assessed as part of Assignment #2.</p> <p>TODO...</p>"},{"location":"ros/","title":"Installing ROS","text":"<p>Details on the ROS2 Simulation environment (TODO)</p>"},{"location":"waffles/","title":"The Waffles","text":"<p>Details on the robot's and how to work with them.</p> <p>Based on this from 2023/24</p>"}]}
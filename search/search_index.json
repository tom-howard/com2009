{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>"},{"location":"#com2009-ros-labs","title":"COM2009 ROS Labs","text":"<p>ROS Labs for the COM2009-3009 Robotics Course at The University of Sheffield (and more) </p> <p> </p> <p>By Tom Howard Department of Multidisciplinary Engineering Education  </p> <p>(Image courtesy of Andy Brown)</p> <p>Find out more...</p> <p></p>"},{"location":"about/","title":"Welcome","text":"<p>This section might include: </p> <ul> <li>About</li> <li>The Robots</li> <li>License</li> <li>Acknowledgements</li> <li>Version History</li> </ul> <p>See here for reference</p>"},{"location":"extras/","title":"ROS Extras","text":"<p>Extra ROS2 tutorials etc that aren't part of the main Assignment #1 Course, but that might be helpful for Assignment #2...</p> <p>A bit like this from 2023/24</p>"},{"location":"labs/","title":"The COM2009 Lab Course","text":"<p>For the COM2009 Robotics course you must complete two lab assignments:</p> <ul> <li> <p>Assignment #1: \"An Introduction to ROS (the Robot Operating System)\".</p> <p>Here you will learn what ROS is and how to use it. You will complete this assignment individually, and in your own time.</p> <p>Weighting: 25% of the overall COM2009 module mark.</p> </li> <li> <p>Assignment #2: \"Team Robotics Project\".</p> <p>Here you will work in teams of 3-4 to complete a series of real-world robotics tasks using our Tutlebot3 Waffle Robots in the Lab (Diamond Computer Room 5).</p> <p>Weighting: 30% of the overall COM2009 module mark</p> </li> </ul>"},{"location":"labs/assignment1/","title":"Assignment #1: An Introduction to ROS","text":""},{"location":"labs/assignment1/#overview","title":"Overview","text":"<p>Assignment #1 is an X-part course, which you should complete in full and in order. The course is designed to be completed in simulation, so you will therefore need access to a ROS installation which can either be installed on your own machine, or accessed on a range of managed computers across the University of Sheffield campus. See here for more information on how to install ROS (TODO).</p> <p>Each part of the course comprises a series of step-by-step instructions and exercises to teach you how ROS works, and introduces you to the core principles of the framework. The exercises give you the opportunity to see how to apply these principles to practical robotic applications. Completing this course is essential for obtaining all the necessary skills for Assignment #2: the Team Robotics Project, where you will work in teams to program our real TurtleBot3 Waffle robots (TODO).  </p>"},{"location":"labs/assignment1/#the-course","title":"The Course","text":"<ul> <li> <p>Part 1: Getting Started with ROS2</p> <p>In this first part you will learn the basics of ROS and become familiar with some key tools and principles of this framework, allowing you to program robots and work with ROS applications effectively.</p> </li> <li> <p>Part 2: Odometry &amp; Navigation</p> <p>In this session you'll learn about Odometry data, which informs us of a robot's position in an environment. You'll also learn how to control a ROS robot's velocity (and thus its position) using both open and closed-loop control methods.</p> </li> <li> <p>Part 3: SLAM &amp; Autonomous Navigation</p> <p>Here you'll take your first look at the LiDAR sensor, the data that it generates, and how this can be of huge benefit for robotics applications. You'll see this in practice by leveraging the mapping and autonomous navigation tools within ROS.</p> </li> <li> <p>Part 4: ROS Services</p> <p>In this part of the course you'll learn about ROS Services, which offer an alternative way for nodes to communicate in ROS. You will see how this framework can be used to control a robot or invoke certain behaviours more effectively for certain tasks.</p> </li> <li> <p>Part 5: ROS Actions</p> <p>Building on what you learnt about ROS Services in Part 4, here you will look at ROS Actions, which are similar to Services, but with a few key differences.</p> </li> <li> <p>Part 6: Cameras, Machine Vision &amp; OpenCV</p> <p>Here you'll learn how to work with images from an on-board camera. You will look at techniques to detect features within these images, and use this to inform robot decision-making.</p> </li> </ul>"},{"location":"labs/assignment1/#assessment","title":"Assessment","text":"<p>This assignment is worth 25% of the overall mark for COM2009, and is assessed via an on-campus Blackboard-based test taking place in week 7 or 8 of the Spring Semester. </p>"},{"location":"labs/assignment1/part1/","title":"Part 1: Getting Started with ROS2","text":""},{"location":"labs/assignment1/part1/#introduction","title":"Introduction","text":"<p> Exercises: 8 Estimated Completion Time: 2 hours</p>"},{"location":"labs/assignment1/part1/#aims","title":"Aims","text":"<p>In the first part of this lab course you will learn the basics of ROS and become familiar with some key tools and principles of the framework which will allow you to program robots and work with ROS applications effectively.  For the most part, you will interact with ROS using the Linux command line and so you will also become familiar with some key Linux command line tools that will help you.  Finally, you will learn how to create some basic ROS Nodes using Python and get a taste of how ROS topics and messages work.</p>"},{"location":"labs/assignment1/part1/#intended-learning-outcomes","title":"Intended Learning Outcomes","text":"<p>By the end of this session you will be able to:  </p> <ol> <li>Control a TurtleBot3 Robot, in simulation, using ROS.</li> <li>Launch ROS applications using <code>ros2 launch</code> and <code>ros2 run</code>.</li> <li>Interrogate running ROS applications using key ROS command line tools.</li> <li>Create a ROS package comprised of multiple nodes and program these nodes (in Python) to communicate with one another using ROS Communication Methods.</li> <li>Create a custom ROS message interface and create Python Nodes to use this.</li> <li>Navigate a Linux filesystem and learn how to do various filesystem operations from within a Linux Terminal.</li> </ol>"},{"location":"labs/assignment1/part1/#quick-links","title":"Quick Links","text":""},{"location":"labs/assignment1/part1/#exercises","title":"Exercises","text":"<ul> <li>Exercise 1: Launching a simulation and making a robot move</li> <li>Exercise 2: Visualising the ROS Network</li> <li>Exercise 3: Exploring ROS Topics and Messages</li> <li>Exercise 4: Creating your own ROS Package</li> <li>Exercise 5: Creating a publisher node</li> <li>Exercise 6: Creating a subscriber node</li> <li>Exercise 7: Defining our own message</li> <li>Exercise 8: Using a custom ROS Message</li> </ul>"},{"location":"labs/assignment1/part1/#additional-resources","title":"Additional Resources","text":"<ul> <li>A Simple Python Publisher</li> <li>A Simple Python Subscriber</li> </ul>"},{"location":"labs/assignment1/part1/#first-steps","title":"First Steps","text":"<p>Step 1: Accessing a ROS2 Environment for this Course</p> <p>If you haven't done so already, see here for all the details on how to install or access a ROS environment for this course (TODO).</p> <p>Step 2: Launch ROS</p> <p>Launch your ROS environment.</p> <ol> <li>OPTION 1</li> <li>OPTION 2</li> <li>etc...</li> </ol> <p>Either way, you should now have access to ROS via a Linux terminal instance, and we'll refer to this terminal instance as TERMINAL 1.</p> <p>Step 3: Download The Course Repo</p> <p></p> <p>We've put together a few ROS packages specifically for this course. These all live within this GitHub repo, and you'll need to download and install this into your ROS environment now, before going any further.</p> <p>[TODO: Create a ROS2 Workspace first??]</p> <ol> <li> <p>In TERMINAL 1, Navigate into the \"ROS2 Workspace\" using the <code>cd</code> command<sup>1</sup>:</p> <pre><code>cd ~/ros2_ws/src/\n</code></pre> </li> <li> <p>Then, run the following command to clone the Course Repo from GitHub:</p> <p>TERMINAL 1: <pre><code>git clone https://github.com/tom-howard/tuos_ros.git -b humble\n</code></pre></p> </li> <li> <p>Once this is done, you'll need to build this using a tool called \"Colcon\"<sup>2</sup>:</p> <p>TERMINAL 1: <pre><code>cd ~/ros2_ws/ &amp;&amp; colcon build --packages-up-to tuos_ros &amp;&amp; source ~/.bashrc\n</code></pre></p> </li> </ol> <p>Don't worry too much about what you just did, for now. We'll cover this in more detail throughout the course. That's it for now though, we'll start using some of the packages that we've just installed a bit later on.</p>"},{"location":"labs/assignment1/part1/#ex1","title":"Exercise 1: Launching a simulation and making a robot move","text":"<p>Now that you're all up and running, let's launch ROS and fire up a simulation of our TurtleBot3 Waffle robot... </p> <ol> <li> <p>In the terminal enter the following command to launch a simulation of a TurtleBot3 Waffle in an empty world:  </p> <p>TERMINAL 1: <pre><code>ros2 launch turtlebot3_gazebo empty_world.launch.py\n</code></pre></p> </li> <li> <p>A Gazebo simulation window should open and within this you should see a basic representation of the robot's that you'll work with in the lab (TODO):</p> </li> </ol> <p>[FIGURE]     </p> <ol> <li> <p>With the Gazebo simulation up and running, return to your terminal and open up a second terminal instance (TERMINAL 2)</p> <p>[TODO: use tmux??]</p> </li> <li> <p>In this new terminal instance enter the following command:</p> <p>TERMINAL 2: <pre><code>ros2 run turtlebot3_teleop teleop_keyboard\n</code></pre></p> </li> <li> <p>Follow the instructions provided in the terminal to drive the robot around using specific buttons on your keyboard:</p> <p> </p> </li> </ol>"},{"location":"labs/assignment1/part1/#summary","title":"Summary","text":"<p>You have just launched a number of different applications on a ROS Network using two different ROS commands - <code>ros2 launch</code> and <code>ros2 run</code>: </p> <ol> <li><code>ros2 launch turtlebot3_gazebo empty_world.launch.py</code></li> <li><code>ros2 run turtlebot3_teleop teleop_keyboard</code></li> </ol> <p>These two commands have a similar structure, but work slightly differently. </p> <p>The first command you used was a <code>launch</code> command, which has the following two parts to it (after the <code>launch</code> bit):</p> <pre><code>ros2 launch {[1] Package name} {[2] Launch file}\n</code></pre> <p>Part [1] specifies the name of the ROS package containing the functionality that we want to execute. Part [2] is a file within that package that tells ROS exactly what scripts ('nodes') that we want to launch. We can launch multiple nodes at the same time from a single launch file.</p> <p>The second command was a <code>run</code> command, which has a structure similar to <code>launch</code>:</p> <pre><code>ros2 run {[1] Package name} {[2] Node name}\n</code></pre> <p>Here, Part [1] is the same as the <code>launch</code> command, but Part [2] is slightly different: <code>{[2] Node name}</code>. Here we are directly specifying a single script that we want to execute. We therefore use <code>ros2 run</code> if we only want to launch a single node on the ROS network: the <code>teleop_keyboard</code> node (a Python script), in this case.</p>"},{"location":"labs/assignment1/part1/#ros-packages-nodes","title":"ROS Packages &amp; Nodes","text":""},{"location":"labs/assignment1/part1/#packages","title":"Packages","text":"<p>ROS applications are organised into packages. Packages are basically folders containing scripts, configurations and launch files (ways to launch those scripts and configurations), all of which relate to some common robot functionality. ROS uses packages as a way to organise all the programs running on a robot. </p> <p>Info</p> <p>The package system is a fundamental concept in ROS and all ROS programs are organised in this way.</p> <p>You will create a number of packages throughout this course, each containing different nodes, launch files and other things too. We'll start to explore this later on in this part of the course.</p>"},{"location":"labs/assignment1/part1/#nodes","title":"Nodes","text":"<p>ROS Nodes are executables that perform specific robot tasks and operations. Earlier on we used <code>ros2 run</code> to execute a node called <code>teleop_keyboard</code>, which allowed us to remotely control (or \"teleoperate\") the robot, for example. </p> <p>Question</p> <p>What was the name of the ROS package that contained the <code>teleop_keyboard</code> node? (Remember: <code>ros2 run {[1] Package name} {[2] Node name}</code>)</p> <p>A ROS robot might have hundreds of individual nodes running simultaneously to carry out all its necessary operations and actions. Each node runs independently, but uses ROS communication methods to share data with the other nodes on the ROS Network.</p>"},{"location":"labs/assignment1/part1/#the-ros-network","title":"The ROS Network","text":"<p>We can use the <code>ros2 node</code> command to view all the nodes that are currently active on a ROS Network.</p>"},{"location":"labs/assignment1/part1/#ex2","title":"Exercise 2: Visualising the ROS Network","text":"<p>You should currently have two terminal instances active: the first in which you launched the Gazebo simulation (TERMINAL 1) and the second with your <code>teleop_keyboard</code> node active (TERMINAL 2).</p> <ol> <li>Open up a new terminal instance now (TERMINAL 3).</li> <li> <p>Use the following command to have a look at which nodes are currently active on the network:</p> <p>TERMINAL 3: <pre><code>ros2 node list\n</code></pre></p> <p>Only a handful of nodes should be listed:</p> <pre><code>/camera_driver\n/gazebo\n/teleop_keyboard\n/turtlebot3_diff_drive\n/turtlebot3_imu\n/turtlebot3_joint_state\n/turtlebot3_laserscan\n</code></pre> </li> <li> <p>We can visualise the connections between the active nodes by using an application called RQT. RQT is a collection of graphical tools that allow us to interact with and interrogate the ROS network. Launch the main RQT application by entering <code>rqt</code> in TERMINAL 3 (you might see some warnings in the terminal when you do this, but don't worry about them):</p> <p>TERMINAL 3: <pre><code>rqt\n</code></pre></p> <p>A window should then open:</p> <p> </p> </li> <li> <p>From here, we then want to load the Node Graph plugin. From the top menu select <code>Plugins</code> &gt; <code>Introspection</code> &gt; <code>Node Graph</code>.</p> </li> <li> <p>Select <code>Nodes/Topics (all)</code> from the top-left most dropdown, and in the <code>Hide</code> section uncheck everything except <code>Debug</code> and <code>Params</code> (you may then need to hit the refresh button):</p> <p> </p> <p>Here, nodes are represented by rectangles and topics by ellipses (hover over a region of the graph to enable colour highlighting).</p> <p>This tool shows us that (amongst other things) the <code>/teleop_keyboard</code> and <code>/turtlebot3_diff_drive</code> nodes are communicating with one another. The direction of the arrow tells us that <code>/teleop_keyboard</code> is a Publisher and <code>/turtlebot3_diff_drive</code> is a Subscriber. The two nodes communicate via a ROS Topic called <code>/cmd_vel</code>. </p> </li> </ol>"},{"location":"labs/assignment1/part1/#publishers-and-subscribers-a-ros-communication-method","title":"Publishers and Subscribers: A ROS Communication Method","text":"<p>ROS Topics are key to making things happen on a robot. Nodes can publish (write) and/or subscribe to (read) ROS Topics in order to share data around the ROS network. Data is published to topics using ROS Messages. As we've just learnt, the <code>teleop_keyboard</code> node was publishing messages to a topic (<code>/cmd_vel</code>) to make the robot move earlier.</p> <p>Let's have a look at this in a bit more detail...</p>"},{"location":"labs/assignment1/part1/#ex3","title":"Exercise 3: Exploring ROS Topics and Messages","text":"<p>We can find out more about the <code>/cmd_vel</code> topic by using the <code>ros2 topic</code> command.</p> <ol> <li> <p>Open up yet another new terminal instance (TERMINAL 4) and type the following:</p> <p>TERMINAL 4: <pre><code>ros2 topic list\n</code></pre></p> <p>This shows us all the topics that are currently available on the ROS network (a lot of which we saw in the RQT Node Graph above):</p> <pre><code>/camera/camera_info\n/camera/image_raw\n/clock\n/cmd_vel\n/imu\n/joint_states\n/odom\n/parameter_events\n/performance_metrics\n/robot_description\n/rosout\n/scan\n/tf\n/tf_static\n</code></pre> <p>Let's find out a bit more about <code>/cmd_vel</code>...</p> </li> <li> <p>Use the <code>topic info</code> command now:</p> <p>TERMINAL 4: <pre><code>ros2 topic info /cmd_vel\n</code></pre></p> <p>This should provide the following output:</p> <pre><code>Type: geometry_msgs/msg/Twist\nPublisher count: 1\nSubscription count: 1\n</code></pre> <p>We've now established the following information about <code>/cmd_vel</code>:</p> <ol> <li>The topic has 1 publisher writing data to it</li> <li>The topic also has 1 subscriber reading this data</li> <li>From RQT Node Graph we know that the <code>/teleop_keyboard</code> node is the publisher (i.e. the node writing data to the topic)</li> <li>The <code>/turtlebot3_diff_drive</code> node is receiving this data (and acting upon it). This node therefore monitors (i.e. subscribes to) the <code>/cmd_vel</code> topic and makes the robot move in the simulator whenever a velocity command is published.</li> <li> <p>Data is transmitted on the <code>/cmd_vel</code> topic using an Interface. This particular interface type is: <code>geometry_msgs/msg/Twist</code>. </p> <p>The type field has three parts to it:</p> <ol> <li><code>geometry_msgs</code>: the name of the ROS package that this interface belongs to.</li> <li><code>msg</code>: that this is a topic message rather than another type of interface (there are three types of interface, and we'll learn about the other two later in this course).</li> <li><code>Twist</code>: the actual message type (i.e., the way the data is structured)</li> </ol> <p>In summary then, we've established that if we want to make the robot move we need to publish <code>Twist</code> messages to the <code>/cmd_vel</code> topic.</p> </li> </ol> </li> <li> <p>We can use the <code>ros2 interface</code> command to provide further information about the message structure:</p> <p>TERMINAL 4: <pre><code>ros2 interface show geometry_msgs/msg/Twist\n</code></pre></p> <p>From this, we obtain the following:</p> <pre><code># This expresses velocity in free space broken into its linear and angular parts.\n\nVector3  linear\n        float64 x\n        float64 y\n        float64 z\nVector3  angular\n        float64 x\n        float64 y\n        float64 z\n</code></pre> <p>We'll learn more about what this means in Part 2.</p> </li> <li> <p>To finish, enter Ctrl+C in each of the three terminals that should currently have ROS processes running (Terminals 1, 2 and 3). The associated Gazebo and RQT Node Graph windows should close as a result of this too.</p> </li> </ol> <p>Tip</p> <p>Whenever you need to stop any ROS process use Ctrl+C in the terminal it's running in.</p>"},{"location":"labs/assignment1/part1/#creating-your-first-ros-applications","title":"Creating Your First ROS Applications","text":"<p>Shortly you will create some simple publisher and subscriber nodes in Python and send simple ROS messages between them. As we learnt earlier though, ROS applications must be contained within packages, and so we need to create a package first in order to start creating our own ROS nodes. </p> <p>It's important to work in a specific filesystem location when we create and work on our own ROS packages. These are called \"Workspaces\" and you should already have one ready to go within your local ROS environment<sup>3</sup>:</p> <pre><code>~/ros2_ws/src/\n</code></pre> <p>Note</p> <p><code>~</code> is an alias for your home directory. So <code>cd ~/ros2_ws/src/</code> is the same as typing <code>cd /home/{your username}/ros2_ws/src/</code>.</p> <p>Important</p> <p>All new packages must be located in the <code>src</code> folder of the workspace!!</p>"},{"location":"labs/assignment1/part1/#ex4","title":"Exercise 4: Creating your own ROS Package","text":"<p>The <code>ros2</code> Command Line Interface (CLI) includes a tool to create a new ROS packages: <code>ros2 pkg create</code>. This tool supports two different \"build types:\"</p> <ol> <li> <p>CMake (for packages containing nodes written in C++):</p> <p><code>ros2 pkg create --build-type ament_cmake</code></p> </li> <li> <p>Python (for packages containing nodes written in well, er, Python!):</p> <p><code>ros2 pkg create --build-type ament_python</code></p> <p>Packages are structured slightly differently in each case.</p> </li> </ol> <p>You can learn more about all this from the Official ROS2 Tutorials (if you're interested).</p> <p>We'll be using Python throughout this course, but we'll actually take a slightly different approach to package creation that will provide us with a little more flexibility and ease of use (particularly for things we'll do later on in the Assignment #1 course and in Assignment #2). We've therefore created a helper script (inside the <code>tuos_ros</code> Course Repo) to help you create packages without using either of the above two commands. The approach we'll take is based on this tutorial (courtesy of the Robotics Backend), so feel free to look at this if you'd like to find out more. Then, simply follow the steps below to create your first ROS package for this course, using the <code>create_pkg.sh</code> helper tool.</p> <ol> <li> <p>Navigate into the <code>tuos_ros</code> Course Repo that you downloaded earlier by using the Linux <code>cd</code> command (change directory). In TERMINAL 1 enter the following:</p> <p>TERMINAL 1: <pre><code>cd ~/ros2_ws/src/tuos_ros/\n</code></pre></p> </li> <li> <p>Here you'll find the <code>create_pkg.sh</code> helper script. Run this now using the following command to create a new package called <code>part1_pubsub</code>:</p> <p>TERMINAL 1: <pre><code>./create_pkg.sh part1_pubsub\n</code></pre></p> </li> <li> <p>Navigate into this new package directory (using <code>cd</code>):</p> <p>TERMINAL 1: <pre><code>cd ../part1_pubsub/\n</code></pre></p> <p>Info</p> <p><code>..</code> means \"go back one directory,\" so that command above is telling <code>cd</code> to navigate out of the <code>tuos_ros</code> directory (and therefore back to <code>~/ros2_ws/src/</code>), and then go into the <code>part1_pubsub</code> directory from there.</p> </li> <li> <p><code>tree</code> is a Linux command which shows us the content of the current directory in a nice tree-like format. Use <code>tree</code> now to show the current content of the <code>part1_pubsub</code> directory:</p> <pre><code>~/ros2_ws/src/part1_pubsub$ tree\n.\n\u251c\u2500\u2500 CMakeLists.txt\n\u251c\u2500\u2500 include\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 part1_pubsub\n\u2502\u00a0\u00a0     \u2514\u2500\u2500 minimal_header.hpp\n\u251c\u2500\u2500 package.xml\n\u251c\u2500\u2500 part1_pubsub\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 __init__.py\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 tb3_tools.py\n\u251c\u2500\u2500 scripts\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 minimal_node.py\n\u2514\u2500\u2500 src\n    \u2514\u2500\u2500 minimal_node.cpp\n\n5 directories, 7 files\n</code></pre> <ul> <li><code>scripts</code>: is a directory that will contain all the Python Nodes that we'll create (you'll notice a <code>minimal_node.py</code> already exists in there).</li> <li> <p><code>part1_pubsub</code>: is a directory that we can use to store Python modules, that we can then import into our main Python nodes</p> <p>(<code>from part1_pubsub.tb3_tools import ...</code>, for example)</p> </li> <li> <p><code>package.xml</code> and <code>CMakeLists.txt</code>: are both files that define our package, and how it must be built (using <code>colcon build</code>). We'll explore these more shortly... </p> </li> </ul> </li> </ol>"},{"location":"labs/assignment1/part1/#ex5","title":"Exercise 5: Creating a publisher node","text":"<ol> <li>From the root of your <code>part1_pubsub</code> package, navigate to the <code>scripts</code> folder using the <code>cd</code> command.</li> <li> <p><code>touch</code> is a Linux command that we can use to create an empty file. Use this to create an empty file called <code>publisher.py</code>, which we will add content to shortly:</p> <p>TERMINAL 1: <pre><code>touch publisher.py\n</code></pre></p> </li> <li> <p>Use <code>ls</code> to verify that the file has been created, but use the <code>-l</code> option with this, so that the command provides its output in \"a long listing format\":</p> <p>TERMINAL 1: <pre><code>ls -l\n</code></pre></p> <p>This should output something similar to the following:</p> <pre><code>~/ros2_ws/src/part1_pubsub/scripts$ ls -l\ntotal 4\n-rwxr-xr-x 1 student student 339 MMM DD HH:MM minimal_node.py\n-rw-r--r-- 1 student student   0 MMM DD HH:MM publisher.py\n</code></pre> <p>This confirms that the file exists, and the <code>0</code> in the middle of the bottom line there indicates that the file is empty (i.e. its current size is 0 bytes), which is what we'd expect.</p> </li> <li> <p>We therefore now need to open the file and add content to it. We'd recommend using Visual Studio Code (VS Code) as an IDE for this course, which can be launched with the following command in TERMINAL 1:</p> <p>TERMINAL 1: <pre><code>code ~\n</code></pre></p> <p>[TODO: does this work for Docker??]</p> </li> <li> <p>Using the VS Code File Explorer, locate the <code>publisher.py</code> file that you have just created (<code>ros2_ws/src/part1_pubsub/scripts/</code>) and click on the file to open it in the main editor. </p> </li> <li> <p>Once opened, copy the code provided here into the empty file and save it. </p> <p>Note</p> <p>It's important that you understand how this code works, so make sure that you read the annotations!</p> </li> <li> <p>Next, we need to add our <code>publisher.py</code> file as an executable to our package's <code>CMakeLists.txt</code>. This will ensure that it then gets built when we run <code>colcon build</code> (in the next step).</p> <p>In VS Code, open the <code>CMakeLists.txt</code> file that is at the root of your <code>part1_pubsub</code> package directory (<code>ros2_ws/src/part1_pubsub/CMakeLists.txt</code>). Locate the lines (near the bottom of the file) that read:</p> <pre><code># Install Python executables\ninstall(PROGRAMS\n  scripts/minimal_node.py\n  DESTINATION lib/${PROJECT_NAME}\n)\n</code></pre> <p>Replace <code>minimal_node.py</code> with <code>publisher.py</code> to define this as a Python executable in your package:</p> <pre><code># Install Python executables\ninstall(PROGRAMS\n  scripts/publisher.py\n  DESTINATION lib/${PROJECT_NAME}\n)\n</code></pre> </li> <li> <p>Now, use <code>colcon</code> to build your package.</p> <ol> <li> <p>You MUST run this from the root of your Colcon Workspace (i.e.: <code>~/ros2_ws/</code>), NOT the <code>src</code> directory (<code>~/ros2_ws/src/</code>), so navigate there now using <code>cd</code>:</p> <pre><code>cd ~/ros2_ws/\n</code></pre> </li> <li> <p>Then, use the following <code>colcon</code> command to build your package:</p> <pre><code>colcon build --packages-select part1_pubsub --symlink-install\n</code></pre> <p>What do the additional arguments above do?</p> <ul> <li><code>--packages-select</code>: Build only the <code>part1_pubsub</code> package, nothing else (without this <code>colcon</code> would attempt to build every package in the workspace).</li> <li><code>--symlink-install</code>: Ensures that you don't have to re-run <code>colcon build</code> every time you make a change to your package's executables (i.e. your Python files in the <code>scripts</code> directory).</li> </ul> </li> <li> <p>Finally, \"re-source\" your <code>bashrc</code><sup>4</sup>:</p> <pre><code>source ~/.bashrc\n</code></pre> </li> </ol> </li> <li> <p>We should now be able to run this node using the <code>ros2 run</code> command. </p> <p>Remember: <code>ros2 run {package name} {script name}</code>, so:</p> <p>TERMINAL 1: <pre><code>ros2 run part1_pubsub publisher.py\n</code></pre></p> <p>... Hmm, something not quite right? If you typed the command exactly as above and then tried to run it, you probably just received the following error:</p> <pre><code>$ ros2 run part1_pubsub publisher.py\nNo executable found\n</code></pre> <p></p> <p>When we create a file using <code>touch</code> it is given certain permissions by default. Run <code>ls -l</code> again (making sure that your terminal is in the right location: <code>~/ros2_ws/src/part1_pubsub/scripts/</code>).</p> <p>The first bit tells us about the permissions that are currently set: <code>-rw-r--r--</code>. This tells us who has permission to do what with this file and (currently) the first bit: <code>-rw-</code>, tells us that we have permission to read or write to it. There is a third option we can set too though, which is the execute permission, and we can set this using the <code>chmod</code> Linux command...</p> </li> <li> <p>Run the <code>chmod</code> command as follows:</p> <p>TERMINAL 1: <pre><code>chmod +x publisher.py\n</code></pre></p> </li> <li> <p>Now, run <code>ls -l</code> again to see what has changed:</p> <p>TERMINAL 1: <pre><code>ls -l\n</code></pre></p> <p>We have now granted permission for the file to be executed too:</p> <pre><code>-rwxr-xr-x 1 student student 1125 MMM DD HH:MM publisher.py\n</code></pre> </li> <li> <p>OK, now use <code>ros2 run</code> again to (hopefully!) run the <code>publisher.py</code> node (remember: <code>ros2 run {package name} {script name}</code>).</p> <p>If you see a message in the terminal similar to the following then the node has been launched successfully:</p> <pre><code>[INFO] [#####] [simple_publisher]: The 'simple_publisher' node is inisialised.\n</code></pre> <p>Phew!</p> </li> <li> <p>We can further verify that our publisher node is running using a number of different tools. Try running the following commands in TERMINAL 2:</p> <ol> <li><code>ros2 node list</code>: This will provide a list of all the nodes that are currently active on the system. Verify that the name of our publisher node is visible in this list (it's probably the only item in the list at the moment!)</li> <li><code>ros2 topic list</code>: This will provide a list of the topics that are currently being used by nodes on the system. Verify that the name of the topic that our publisher is publishing messages to (<code>/my_topic</code>) is present within this list.</li> </ol> </li> </ol>"},{"location":"labs/assignment1/part1/#rostopic","title":"Interrogating ROS Topics","text":"<p>So far we have used the <code>ros2 topic</code> ROS command with two additional arguments: [TODO: check this!]</p> <ul> <li><code>list</code>: to provide us with a list of all the topics that are active on our ROS system, and</li> <li><code>info</code>: to provide us with information on a particular topic of interest.</li> </ul> <p>We can use the autocomplete functionality of the Linux terminal to provide us with a list of all the available options that we can use with the <code>ros2 topic</code> command.  To do this type <code>ros2 topic</code> followed by a Space and then press the Tab key twice:</p> <pre><code>rostopic[SPACE][TAB][TAB]\n</code></pre> <p>You should then be presented with a list of all options:</p> <p>[TODO: a gif]</p> <ul> <li> <p><code>ros2 topic hz {topic name}</code> provides information on the frequency (in Hz) at which messages are being published to a topic:</p> <pre><code>ros2 topic hz /my_topic\n</code></pre> <p>This should tell us that our publisher node is publishing messages to the <code>/my_topic</code> topic at (or close to) 1 Hz, which is exactly what we ask for in the <code>publisher.py</code> file (in the <code>__init__</code> part of our <code>Publisher</code> class). Enter Ctrl+C to stop this command.</p> </li> <li> <p><code>ros2 topic echo {topic name}</code> shows the messages being published to a topic:</p> <pre><code>ros2 topic echo /my_topic\n</code></pre> <p>This will provide a live stream of the messages that our <code>publisher.py</code> node is publishing to the <code>/my_topic</code> topic. Enter Ctrl+C to stop this.</p> </li> <li> <p>We can see some additional options for the <code>echo</code> command by viewing the help documentation for this too:</p> <pre><code>ros2 topic echo --help\n</code></pre> <p>From here, for instance, we can learn that if we just wanted to print the first message that was received we could use the <code>-once</code> option, for example:</p> <pre><code>ros2 topic echo /my_topic --once\n</code></pre> </li> </ul>"},{"location":"labs/assignment1/part1/#ex6","title":"Exercise 6: Creating a subscriber node","text":"<p>To illustrate how information can be passed from one node to another (via topics and messages) we'll now create another node to subscribe to the topic that our publisher node is broadcasting messages to.</p> <ol> <li> <p>In TERMINAL 2 use the filesystem commands that were introduced earlier (<code>cd</code>, <code>ls</code>, etc.) to navigate to the <code>scripts</code> folder of your <code>part1_pubsub</code> package.</p> </li> <li> <p>Use the same procedure as before to create a new empty Python file called <code>subscriber.py</code> and remember to make it executable! </p> </li> <li> <p>Then, open the newly created <code>subscriber.py</code> file in VS Code, paste in the code here and save it. </p> <p>Once again, it's important that you understand how this code works, so make sure you read the code annotations! </p> </li> <li> <p>Next, we need to add this as an additional executable for our package. </p> <p>Open up the <code>CMakeLists.txt</code> file at the root of your <code>part1_pubsub</code> package directory again, head back to the <code># Install Python executables</code> section and add the <code>subscriber.py</code> file:</p> <pre><code># Install Python executables\ninstall(PROGRAMS\n  scripts/publisher.py\n  scripts/subscriber.py\n  DESTINATION lib/${PROJECT_NAME}\n)\n</code></pre> </li> <li> <p>Now we need to <code>colcon build</code> again.</p> <ol> <li> <p>Make sure you're at the root of the Colcon Workspace:</p> <pre><code>cd ~/ros2_ws/\n</code></pre> </li> <li> <p>Run <code>colcon build</code> on only the <code>part1_pubsub</code> package:</p> <pre><code>colcon build --packages-select part1_pubsub --symlink-install\n</code></pre> </li> <li> <p>And then re-source the <code>bashrc</code>:</p> <pre><code>source ~/.bashrc\n</code></pre> </li> </ol> </li> <li> <p>Use <code>ros2 run</code> to execute your newly created <code>subscriber.py</code> node (remember: <code>ros2 run {package name} {script name}</code>). If your publisher and subscriber nodes are working correctly you should see an output like this:</p> <p>[TODO: another gif]</p> </li> <li> <p>Interrogate your ROS network:</p> <ol> <li> <p>As before, we can find out what nodes are running on our system by using the <code>ros2 node list</code> command. Run this in TERMINAL 3, you should see both your publisher and subscriber nodes listed there.</p> </li> <li> <p>Use the <code>ros2 topic</code> command to list all the topics that are available on the network. You should see <code>/my_topic</code> listed there.</p> </li> <li> <p>Use the <code>ros2 topic</code> command again to find more info on <code>my_topic</code>. </p> </li> <li> <p>Use the <code>ros2 interface</code> command to show you what type of data is being sent between the two nodes.</p> </li> </ol> </li> <li> <p>Finally, close down your publisher and subscriber nodes by entering Ctrl+C in the terminals where they are running (should be 1 &amp; 2).</p> </li> </ol>"},{"location":"labs/assignment1/part1/#ex7","title":"Exercise 7: Defining our own message","text":"<p>We've just created a publisher and subscriber that were able to communicate with one another via a topic. The data that the publisher was sending to the topic was very simple: a <code>example_interfaces/msg/String</code> type message.</p> <p>This message just has one field called <code>data</code> of the type <code>string</code>:</p> <pre><code>$ ros2 interface show example_interfaces/msg/String\n\nstring data\n</code></pre> <p>ROS messages will generally be more complex than this, typically containing several fields in a single message. We'll define our own custom message now, this time with two fields, so you can see how things work with slightly more complex data types. </p> <ol> <li> <p>Message interfaces must be defined within a <code>msg</code> folder at the root of our package directory, so let's create this folder now in TERMINAL 1:</p> <ol> <li> <p>First, navigate into your package:</p> <pre><code>cd ~/ros2_ws/src/part1_pubsub\n</code></pre> </li> <li> <p>Then use <code>mkdir</code> to make a new directory:</p> <pre><code>mkdir msg\n</code></pre> </li> </ol> </li> <li> <p>We'll create a message called <code>Example</code>, and to do this we'll need to create a new file called <code>Example.msg</code> inside the <code>msg</code> folder:</p> <pre><code>touch msg/Example.msg\n</code></pre> </li> <li> <p>To define the data structure of this message, we now need to open up the file and add the following content:</p> Example.msg<pre><code>string info\nint32 time\n</code></pre> <p>The message will therefore have two fields:</p> <p> # Field Name Data Type 1 <code>info</code> <code>string</code> 2 <code>time</code> <code>int32</code> <p></p> <p>We can give our fields any name that we want, but the data types must be either built-in-types or other pre-existing ROS interfaces.</p> <li> <p>We now need to declare this message in our package's <code>CMakeLists.txt</code> file, so that the necessary Python code can be created (by <code>colcon build</code>) to allow us to import this message into our own Python files.</p> <p>Add the following lines to your <code>part1_pubsub/CMakeLists.txt</code> file, above the <code>ament_package()</code> line:</p> CMakeLists.txt<pre><code>find_package(rosidl_default_generators REQUIRED)\nrosidl_generate_interfaces(${PROJECT_NAME}\n  \"msg/Example.msg\" \n)\n</code></pre> </li> <li> <p>We also need to modify our <code>package.xml</code> file. Add the following lines to this one, just above the <code>&lt;export&gt;</code> line:</p> package.xml<pre><code>&lt;buildtool_depend&gt;rosidl_default_generators&lt;/buildtool_depend&gt;\n&lt;exec_depend&gt;rosidl_default_runtime&lt;/exec_depend&gt;\n&lt;member_of_group&gt;rosidl_interface_packages&lt;/member_of_group&gt;\n</code></pre> </li> <li> <p>We can now use Colcon to generate the necessary source code for the message:</p> <ol> <li> <p>First, make sure you're in the root of the ROS2 Workspace:</p> <pre><code>cd ~/ros2_ws/\n</code></pre> </li> <li> <p>Then run <code>colcon build</code>:</p> <pre><code>colcon build --packages-select part1_pubsub --symlink-install \n</code></pre> </li> <li> <p>And finally re-source the <code>.bashrc</code>:</p> <pre><code>source ~/.bashrc\n</code></pre> </li> </ol> </li> <li> <p>We can now verify that this worked with some more <code>ros2</code> command line tools:</p> <ol> <li> <p>First, list all the ROS messages that are available to us on our system:</p> <pre><code>ros2 interface list -m\n</code></pre> <p>Scroll through this list and see if you can find our message in there (it'll be listed as <code>part1_pubsub/msg/Example</code>)</p> </li> <li> <p>Next, show the data structure of the interface:</p> <pre><code>ros2 interface show part1_pubsub/msg/Example\n</code></pre> <p>This should match with how we defined it in our <code>part1_pubsub/msg/Example.msg</code> file.</p> </li> </ol> </li>"},{"location":"labs/assignment1/part1/#ex8","title":"Exercise 8: Using a custom ROS Message","text":"<ol> <li> <p>Create a copy of the <code>publisher.py</code> file from Exercise 5. Let's do this from the command line too:</p> <ol> <li> <p>Navigate into your package's <code>scripts</code> folder:</p> <pre><code>cd ~/ros2_ws/src/part1_pubsub/scripts\n</code></pre> </li> <li> <p>And use the <code>cp</code> command to make a copy of the <code>publisher.py</code> file and call this new file <code>custom_msg_publisher.py</code>:</p> <pre><code>cp publisher.py custom_msg_publisher.py\n</code></pre> </li> <li> <p>Let's create a copy of the <code>subscriber.py</code> file too, while we're here:</p> <pre><code>cp subscriber.py custom_msg_subscriber.py\n</code></pre> </li> </ol> </li> <li> <p>Declare these two new files as additional executables in our <code>CMakeLists.txt</code>:</p> CMakeLists.txt<pre><code># Install Python executables\ninstall(PROGRAMS\n  scripts/publisher.py\n  scripts/subscriber.py\n  scripts/custom_msg_publisher.py   # ADD THIS \n  scripts/custom_msg_subscriber.py  # AND THIS\nDESTINATION lib/${PROJECT_NAME}\n)\n</code></pre> </li> <li> <p>Run Colcon again (last time now!):</p> <ol> <li>First:     <pre><code>cd ~/ros2_ws\n</code></pre></li> <li>Then:     <pre><code>colcon build --packages-select part1_pubsub --symlink-install\n</code></pre></li> <li>And finally:     <pre><code>source ~/.bashrc\n</code></pre></li> </ol> </li> <li> <p>Now modify your <code>custom_msg_publisher.py</code> file as follows:</p> custom_msg_publisher.py<pre><code>#!/usr/bin/env python3\n\nimport rclpy\nfrom rclpy.node import Node\n\nfrom part1_pubsub.msg import Example # (1)!\n\nclass SimplePublisher(Node):\n\n    def __init__(self):\n        super().__init__(\"simple_publisher\")\n\n        self.my_publisher = self.create_publisher(\n            msg_type=Example, # (2)!\n            topic=\"my_topic\",\n            qos_profile=10,\n        )\n\n        publish_rate = 1 # Hz\n        self.timer = self.create_timer(\n            timer_period_sec=1/publish_rate,\n            callback=self.timer_callback\n        )\n\n        self.get_logger().info(\n            f\"The '{self.get_name()}' node is initialised.\"\n        )\n\n    def timer_callback(self):\n        ros_time = self.get_clock().now().seconds_nanoseconds()\n\n        topic_msg = Example() # (3)!\n        topic_msg.info = \"The ROS time is...\"\n        topic_msg.time = ros_time[0]\n        self.my_publisher.publish(topic_msg)\n        self.get_logger().info(\n            f\"Publishing: '{topic_msg.info} {topic_msg.time:.0f}'\"\n        )\n\ndef main(args=None):\n    rclpy.init(args=args)\n    my_simple_publisher = SimplePublisher()\n    rclpy.spin(my_simple_publisher)\n    my_simple_publisher.destroy_node()\n    rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n</code></pre> <ol> <li> <p>We're now importing the <code>Example</code> message from our own <code>part1_pubsub</code> package.</p> </li> <li> <p>We're also now declaring that <code>\"my_topic\"</code> will use the <code>Example</code> message data structure to send messages.</p> </li> <li> <p>We need to deal with the topic messages differently now, to account for the more complex structure.</p> <p>We now populate our messages with two fields: <code>info</code> (a <code>string</code>) and <code>time</code> (an <code>int</code>). Identify what has changed here...</p> </li> </ol> </li> <li> <p>Final Task:</p> <p>Modify the <code>custom_msg_subscriber.py</code> node now to accommodate the new message type that is being published to <code>/my_topic</code>. </p> </li> </ol>"},{"location":"labs/assignment1/part1/#wrapping-up","title":"Wrapping Up","text":"<p>In this session we've covered the basics of ROS, and learnt about some key concepts such as Packages; Nodes; and how to send data across a ROS Network using Topics, Messages, and the Publisher-Subscriber Communication Method.</p> <p>We've learnt how to use some key <code>ros2</code> commands:  </p> <ul> <li><code>launch</code>: to launch multiple ROS Nodes via launch files.</li> <li><code>run</code>: to run executables within a ROS package.</li> <li><code>node</code>: to display information about active ROS Nodes.</li> <li><code>topic</code>: to display information about active ROS topics.</li> <li><code>interface</code>: to display information about all ROS Interfaces that are available to use in a ROS application.</li> </ul> <p>We have also learnt how to work in the Linux Terminal and navigate a Linux filesystem using key commands such as:</p> <ul> <li><code>ls</code>: lists the files in the current directory.</li> <li><code>cd</code>: change directory to move around the file system.</li> <li><code>mkdir</code>: make a new directory (<code>mkdir {new_folder}</code>).</li> <li><code>chmod</code>: modify file permissions (i.e. to add execute permissions to a file for all users: <code>chmod +x {file}</code>).</li> <li><code>touch</code>: create a file without any content.</li> </ul> <p>In addition to this we've also learnt how to create a ROS2 package, and how to create simple Python nodes that can publish and subscribe to topics on a ROS network. </p> <p>We've worked with pre-made ROS messages to do this and also created our own custom message interface to offer more advanced functionality.</p> <ol> <li> <p>What is a ROS2 Workspace? You can find out more here.\u00a0\u21a9</p> </li> <li> <p>What is Colcon? Find out more here.\u00a0\u21a9</p> </li> <li> <p>You can learn more about ROS2 Workspaces here.\u00a0\u21a9</p> </li> <li> <p>What does <code>source ~/.bashrc</code> do? See here for an explanation.\u00a0\u21a9</p> </li> </ol>"},{"location":"labs/assignment1/part2/","title":"Part 2: Odometry & Navigation","text":""},{"location":"labs/assignment1/part2/#introduction","title":"Introduction","text":"<p> Exercises: 6 Estimated Completion Time: 3 hours</p>"},{"location":"labs/assignment1/part2/#aims","title":"Aims","text":"<p>In Part 2 you will learn how to control a ROS robot's position and velocity from both the command line and through ROS Nodes. You will also learn how to interpret the data that allows us to monitor a robot's position in its physical environment (odometry).  The things you will learn here form the basis for all robot navigation in ROS, from simple open-loop methods to more advanced closed-loop control (both of which you will explore).</p>"},{"location":"labs/assignment1/part2/#intended-learning-outcomes","title":"Intended Learning Outcomes","text":"<p>By the end of this session you will be able to:</p> <ol> <li>Interpret the Odometry data published by a ROS Robot and identify the parts of these messages that are relevant to a 2-wheeled differential drive robot (such as the TurtleBot3).</li> <li>Develop Python nodes to obtain Odometry messages from an active ROS network and translate them to provide useful information about a robot's pose in a convenient, human-readable way.</li> <li>Implement open-loop velocity control of a robot using ROS command-line tools.</li> <li>Develop Python nodes that use open-loop velocity control methods to make a robot follow a pre-defined motion path.</li> <li>Combine both publisher &amp; subscriber communication methods into a single Python node to implement closed-loop (odometry-based) velocity control of a robot.</li> <li>Explain the limitations of Odometry-based motion control methods. </li> </ol>"},{"location":"labs/assignment1/part2/#quick-links","title":"Quick Links","text":""},{"location":"labs/assignment1/part2/#exercises","title":"Exercises","text":"<ul> <li>Exercise 1: Exploring Odometry Data</li> <li>Exercise 2: Creating a Python Node to Process Odometry Data</li> <li>Exercise 3: Controlling Velocity with the ROS2 CLI</li> <li>Exercise 4: Creating a Python Node to Make a Robot Move in a circle</li> <li>Exercise 5: Implementing a Shutdown Procedure</li> <li>Exercise 6: Making our Robot Follow a Square Motion Path</li> </ul>"},{"location":"labs/assignment1/part2/#additional-resources","title":"Additional Resources","text":"<ul> <li>An Odometry Subscriber Node</li> <li>A Simple Velocity Control Node (Move Circle)</li> <li>Odometry-based Navigation (Move Square)</li> </ul>"},{"location":"labs/assignment1/part2/#getting-started","title":"Getting Started","text":"<p>TODO:</p> <p>Step 1: Launch your ROS Environment</p> <p>If you haven't done so already, launch your ROS environment now:</p> <ol> <li>OPTION 1</li> <li>OPTION 2</li> <li>etc...</li> </ol> <p>You should now have access to ROS via a Linux terminal instance. We'll refer to this terminal instance as TERMINAL 1.</p> <p>Step 2: Make Sure The Course Repo is Up-To-Date</p> <p></p> <p>In Part 1 you should have downloaded and installed The Course Repo into your ROS environment. If you haven't done this yet then go back and do it now. If you have already done it, then it's worth just making sure it's all up-to-date, so run the following command now to do so:</p> <p>TERMINAL 1: <pre><code>cd ~/ros2_ws/src/tuos_ros/ &amp;&amp; git pull\n</code></pre></p> <p>Then build with Colcon: </p> <pre><code>cd ~/ros2_ws/ &amp;&amp; colcon build --packages-up-to tuos_ros\n</code></pre> <p>And finally, re-source your environment:</p> <pre><code>source ~/.bashrc\n</code></pre> <p>Warning</p> <p>If you have any other terminal instances open, then you'll need run <code>source ~/.bashrc</code> in these too, in order for any changes made by the Colcon build process to propagate through to these as well.</p> <p>Step 3: Launch a Waffle Simulation</p> <p>In TERMINAL 1 enter the following command to launch a simulation of a TurtleBot3 Waffle in an empty world:  </p> <p>TERMINAL 1: <pre><code>ros2 launch turtlebot3_gazebo empty_world.launch.py\n</code></pre></p> <p>A Gazebo simulation window should open and within this you should see a TurtleBot3 Waffle in empty space:</p> <p></p> <p>You're all set up and ready to go!</p>"},{"location":"labs/assignment1/part2/#velocity","title":"Velocity (Motion)","text":"<p>In Part 1 we learnt about ROS Topics, and about how the <code>teleop_keyboard</code> node could be used to publish messages to a particular topic in order to control the velocity of the robot (and thus change its position).</p> <p>Questions</p> <ol> <li>Which topic is used to control the velocity of the robot?</li> <li>What message type does this topic use?</li> </ol> <p>Return here if you need a reminder on how to find the answers to these questions.</p> <p>We also learnt how to find out more about this particular message type (using the <code>ros2 interface show</code> command): </p> <pre><code>Vector3  linear\n        float64 x\n        float64 y\n        float64 z\nVector3  angular\n        float64 x\n        float64 y\n        float64 z\n</code></pre>"},{"location":"labs/assignment1/part2/#velocity-commands","title":"Velocity Commands","text":"<p>When defining velocity commands for a ROS robot, there are six \"fields\" that we can assign values to: two velocity types, each with three velocity components: </p> <p> Velocity Type Component 1 Component 2 Component 3 <code>linear</code> <code>x</code> <code>y</code> <code>z</code> <code>angular</code> <code>x</code> <code>y</code> <code>z</code> <p></p> <p>These relate to a robot's six degrees of freedom, and the topic messages are therefore formatted to give a ROS Programmer the ability to ask a robot to move in any one of its six DOFs. </p> <p> Component (Axis) Linear Velocity Angular Velocity X \"Forwards/Backwards\" \"Roll\" Y \"Left/Right\" \"Pitch\" Z \"Up/Down\" \"Yaw\" <p></p>"},{"location":"labs/assignment1/part2/#the-degrees-of-freedom-of-a-waffle","title":"The Degrees of Freedom of a Waffle","text":"<p>The three \"axes\" in the table above are termed the \"Principal Axes.\" In the context of our TurtleBot3 Waffle, these axes and the motion about them are defined as follows:</p> <p></p> <p></p> <p>As discussed above, a mobile robot can have up to six degrees of freedom in total, but this depends upon the robot's design and the actuators it is equipped with. </p> <p>Our TurtleBot3 Waffles only have two motors. These two motors can be controlled independently (in what is known as a \"differential drive\" configuration), which ultimately provides it with a total of two degrees of freedom overall, as illustrated below.</p> <p></p> <p>When issuing Velocity Commands therefore, only two (of the six) velocity command fields are applicable: linear velocity in the x-axis (Forwards/Backwards) and angular velocity about the z-axis (Yaw).</p> <p> Principal Axis Linear Velocity Angular Velocity X \"Forwards/Backwards\" \"Roll\" Y \"Left/Right\" \"Pitch\" Z \"Up/Down\" \"Yaw\" <p></p> <p>Maximum Velocity Limits</p> <p>Keep in mind (while we're on the subject of velocity) that our TurtleBot3 Waffles have maximum velocity limits:</p> <p> Velocity Component Upper Limit Units Linear (X) 0.26 m/s Angular (Z) 1.82 rad/s <p></p>"},{"location":"labs/assignment1/part2/#odometry","title":"Odometry (Position)","text":""},{"location":"labs/assignment1/part2/#odometry-in-action","title":"Odometry In Action","text":"<p>Let's take another look at all the topics that can be used to communicate with our robot:</p> <pre><code>ros2 topic list\n</code></pre> <p>Another topic of interest here is <code>/odom</code>. This topic contains Odometry data, which is also essential for robot navigation, giving us an approximation of a robot's location in its environment.</p> <p>Let's explore this further now, using <code>rqt</code>.</p>"},{"location":"labs/assignment1/part2/#ex1","title":"Exercise 1: Exploring Odometry Data","text":"<ol> <li> <p>In TERMINAL 2 launch <code>rqt</code>:</p> <p>TERMINAL 2: <pre><code>rqt\n</code></pre></p> </li> <li> <p>From the top menu select <code>Plugins</code> &gt; <code>Topics</code> &gt; <code>Topic Monitor</code></p> <p>Topic Monitor should then present you with a list of active topics which matches the topic list from the <code>ros2 topic list</code> command that you ran earlier.</p> </li> <li> <p>Check the box next to <code>/odom</code> and click the arrow next to it to expand the topic and reveal four base fields.</p> </li> <li> <p>Expand the <code>pose</code> &gt; <code>pose</code> &gt; <code>position</code> and <code>orientation</code> fields to reveal the data being published to the three position and four orientation values of this message.</p> </li> <li> <p>Also expand the <code>twist</code> &gt; <code>twist</code>, <code>linear</code> and <code>angular</code> fields to reveal the six values being published here too.</p> <p> </p> </li> <li> <p>Next, launch a new terminal instance, we'll call this one TERMINAL 3. Arrange this next to the <code>rqt</code> window, so that you can see them both simultaneously.</p> </li> <li> <p>In TERMINAL 3 launch the <code>teleop_keyboard</code> node as you did in Part 1: </p> <p>TERMINAL 3: <pre><code>ros2 run turtlebot3_teleop teleop_keyboard\n</code></pre></p> </li> <li> <p>Enter A a couple of times to make the robot rotate on the spot. Observe how the odometry data changes in Topic Monitor.</p> <p>Questions</p> <ol> <li>Which <code>pose</code> fields are changing?</li> <li>Is there anything in the <code>twist</code> part of the message that corresponds to the angular velocity that is being published by the <code>teleop_keyboard</code> node in TERMINAL 3? </li> </ol> </li> <li> <p>Now press the S key to halt the robot, then press W a couple of times to make the robot drive forwards.</p> <p>Questions</p> <ol> <li>Which <code>pose</code> fields are changing now? How does this relate to the position of the robot in the simulated world?</li> <li>How does the <code>twist</code> part of the message now correspond with the linear velocity setting in TERMINAL 3?</li> </ol> </li> <li> <p>Now press D a couple of times and your robot should start to move in a circle.</p> <p>Questions</p> <ol> <li>What linear and angular velocities are you requesting in TERMINAL 3, and how are these represented in the <code>twist</code> part of the <code>/odom</code> message?</li> <li>What about the <code>pose</code> part of the message? How is this data changing as your robot moves in a circular path.</li> <li>What are <code>twist</code> and <code>pose</code> actually telling us?</li> </ol> </li> <li> <p>Press S in TERMINAL 3 to stop the robot (but leave the <code>teleop_keyboard</code> node running).  Then, press Ctrl+C in TERMINAL 2 to close down <code>rqt</code>. </p> </li> <li> <p>Let's look at the Odometry data differently now. With the robot stationary, use <code>ros2 run</code> to run a Python node from the <code>tuos_examples</code> package: </p> <p>TERMINAL 2: <pre><code>ros2 run tuos_examples robot_pose\n</code></pre></p> </li> <li> <p>Now (using the <code>teleop_keyboard</code> node in TERMINAL 3) drive your robot around again, keeping an eye on the outputs that are being printed by the <code>robot_pose</code> node in TERMINAL 2 as you do so.</p> <p>The output of the <code>robot_pose</code> node shows you how the robot's position and orientation (i.e. \"pose\") are changing in real-time as you move the robot around. The <code>\"initial\"</code> column tells us the robot's pose when the node was first launched, and the <code>\"current\"</code> column show us what its pose currently is. The <code>\"delta\"</code> column then shows the difference between the two.</p> <p>Question</p> <p>Which pose parameters haven't changed, and is this what you would expect (considering the robot's principal axes, as illustrated above)?</p> </li> <li> <p>Press Ctrl+C in TERMINAL 2 and TERMINAL 3, to stop the <code>robot_pose</code> and <code>teleop_keyboard</code> nodes. </p> </li> </ol>"},{"location":"labs/assignment1/part2/#odometry-explained","title":"Odometry: Explained","text":"<p>Hopefully you have a good idea of what Odometry is now, but let's dig a little deeper using some key ROS command line tools again:</p> <p>TERMINAL 2: <pre><code>ros2 topic info /odom\n</code></pre></p> <p>This provides information about the type of message used by this topic:</p> <pre><code>Type: nav_msgs/msg/Odometry\n</code></pre> <p>We can find out more about this message using the <code>ros2 interface show</code> command:</p> <p>TERMINAL 2: <pre><code>ros2 interface show nav_msgs/msg/Odometry\n</code></pre></p> <p>Look down the far left-hand side to identify the four base fields of the message (i.e. the fields that are not indented):</p> <p></p> <p> # Field Name Field Type 1 <code>header</code> <code>std_msgs/Header</code> 2 <code>child_frame_id</code> <code>string</code> 3 <code>pose</code> <code>geometry_msgs/PoseWithCovariance</code> 4 <code>twist</code> <code>geometry_msgs/TwistWithCovariance</code> <p></p> <p>We saw all these in <code>rqt</code> earlier. As before, its items 3 and 4 that are of most interest to us...</p>"},{"location":"labs/assignment1/part2/#pose","title":"Pose","text":"<pre><code># Estimated pose that is typically relative to a fixed world frame.\ngeometry_msgs/PoseWithCovariance pose\n        Pose pose\n                Point position\n                        float64 x\n                        float64 y\n                        float64 z\n                Quaternion orientation\n                        float64 x\n                        float64 y\n                        float64 z\n                        float64 w\n        float64[36] covariance\n</code></pre> <p>As you can see above, there are two key components to Pose:</p> <ol> <li><code>position</code>: Tells us where our robot is located in 3-dimensional space. This is expressed in units of meters.</li> <li><code>orientation</code>: Tells us which way our robot is pointing in its environment. This is expressed in units of Quaternions, which is a mathematically convenient way to store data related to a robot's orientation (it's a bit hard for us humans to understand and visualise this though, so we'll talk about how to convert it to a different format later).</li> </ol> <p>Pose is defined relative to an arbitrary reference point (typically where the robot was when it was turned on), and is determined from:</p> <ul> <li>Data from the Inertial Measurement Unit (IMU) on the OpenCR board</li> <li>Data from both the left and right wheel encoders</li> <li>A kinematic model of the robot</li> </ul> <p>All the above information can then be used to calculate (and keep track of) the distance travelled by the robot from its pre-defined reference point using a process called \"dead-reckoning.\"</p>"},{"location":"labs/assignment1/part2/#what-are-quaternions","title":"What are Quaternions?","text":"<p>Quaternions use four values to represent the orientation of something in 3 dimensional space<sup>1</sup>, as we can observe from the structure of the <code>nav_msgs/msg/Odometry</code> ROS message:</p> <pre><code>Quaternion orientation\n        float64 x\n        float64 y\n        float64 z\n        float64 w\n</code></pre> <p>For us, it's easier to think about the orientation of our robot in a \"Euler Angle\" representation, which tell us the degree of rotation about the three principal axes (as discussed above):</p> <ul> <li><code>\u03b8<sub>x</sub></code>, aka: \"Roll\"</li> <li><code>\u03b8<sub>y</sub></code>, aka: \"Pitch\"</li> <li><code>\u03b8<sub>z</sub></code>, aka: \"Yaw\"</li> </ul> <p>Fortunately, the maths involved in converting between these two orientation formats is fairly straight forward (see here).</p> <p>Recall from above however, that our TurtleBot3 can only move in a 2D plane (unfortunately, it can't fly!) and so, actually, its pose can be fully represented by just 3 terms: </p> <ul> <li><code>x</code> &amp; <code>y</code>: the 2D coordinates of the robot in the <code>X-Y</code> plane</li> <li><code>\u03b8<sub>z</sub></code>: the angle of the robot about the <code>z</code> (yaw) axis</li> </ul>"},{"location":"labs/assignment1/part2/#twist","title":"Twist","text":"<p>The fourth base field within the <code>nav_msgs/msg/Odometry</code> message is Twist:</p> <pre><code># Estimated linear and angular velocity relative to child_frame_id.\ngeometry_msgs/TwistWithCovariance twist\n        Twist twist\n                Vector3  linear\n                        float64 x\n                        float64 y\n                        float64 z\n                Vector3  angular\n                        float64 x\n                        float64 y\n                        float64 z\n        float64[36] covariance\n</code></pre> <p>This might look familiar from earlier! This tells us the current linear and angular velocities of the robot. These velocities are set by messages published to <code>/cmd_vel</code>, but are then monitored by data coming directly from the robot's wheel encoders, and are provided here as a feedback signal.</p>"},{"location":"labs/assignment1/part2/#odometry-data-as-a-feedback-signal","title":"Odometry Data as a Feedback Signal","text":"<p>Odometry data can be really useful for robot navigation, allowing us to keep track of where a robot is, how it's moving and how to get back to where we started. We therefore need to know how to use odometry data effectively within our Python nodes, and we'll explore this now.</p>"},{"location":"labs/assignment1/part2/#ex2","title":"Exercise 2: Creating a Python Node to Process Odometry Data","text":"<p>In Part 1 we learnt how to create a package and build simple Python nodes to publish and subscribe to messages on a topic (called <code>/my_topic</code>). In this exercise we'll build a new subscriber node, much like we did previously, but this one will subscribe to the <code>/odom</code> topic that we've been talking about above. We'll also create a new package called <code>part2_navigation</code> for this node to live in!</p> <ol> <li> <p>First, head to the <code>src</code> folder of your ROS2 workspace in your terminal and into the <code>tuos_ros</code> Course Repo:</p> <pre><code>cd ~/ros2_ws/src/tuos_ros/\n</code></pre> </li> <li> <p>Then, use the <code>create_pkg.sh</code> helper script to create your new package:</p> <pre><code>./create_pkg.sh part2_navigation\n</code></pre> </li> <li> <p>Then navigate into the <code>scripts</code> folder of the new package using the <code>cd</code> command again:</p> <pre><code>cd ../part2_navigation/scripts/\n</code></pre> </li> <li> <p>The subscriber that we will build here will be structured in much the same way as the subscriber that we built in Part 1. </p> <p>As a starting point, copy across the <code>subscriber.py</code> file from your <code>part1_pubsub</code> package:</p> <pre><code>cp ~/ros2_ws/src/part1_pubsub/scripts/subscriber.py ./odom_subscriber.py\n</code></pre> </li> <li> <p>Next, follow the steps for converting this into an Odometry subscriber. </p> </li> <li> <p>You'll need to add a new dependency to your package's <code>package.xml</code> file now. Below the <code>&lt;exec_depend&gt;rclpy&lt;/exec_depend&gt;</code> line, add an execution dependency for <code>nav_msgs</code>:</p> package.xml<pre><code>&lt;exec_depend&gt;rclpy&lt;/exec_depend&gt;\n&lt;exec_depend&gt;nav_msgs&lt;/exec_depend&gt;\n</code></pre> </li> <li> <p>Next, declare the <code>odom_subscriber.py</code> node as an executable. Replace <code>minimal_node.py</code> with <code>odom_subscriber.py</code> in the <code>CMakeLists.txt</code>:</p> CMakeLists.txt<pre><code># Install Python executables\ninstall(PROGRAMS\n  scripts/odom_subscriber.py\n  DESTINATION lib/${PROJECT_NAME}\n)\n</code></pre> </li> <li> <p>Finally, head back to the terminal and use Colcon to build the package, and the <code>odom_subscriber.py</code> node:</p> <pre><code>cd ~/ros2_ws/ &amp;&amp; colcon build --packages-select part2_navigation --symlink-install\n</code></pre> </li> <li> <p>Now we're ready to run this! Do so using <code>ros2 run</code> and see what it does:</p> <pre><code>ros2 run part2_navigation odom_subscriber.py\n</code></pre> </li> <li> <p>Having followed all the steps, the output from your node should be similar to that shown below:</p> <p>[TODO: a gif]</p> </li> <li> <p>Observe how the output (the formatted odometry data) changes whilst you move the robot around using the <code>teleop_keyboard</code> node in a new terminal instance (TERMINAL 3).</p> </li> <li>Stop your <code>odom_subscriber.py</code> node in TERMINAL 2 and the <code>teleop_keyboard</code> node in TERMINAL 3 by entering Ctrl+C in each of the terminals.</li> </ol>"},{"location":"labs/assignment1/part2/#basic-navigation-open-loop-velocity-control","title":"Basic Navigation: Open-loop Velocity Control","text":""},{"location":"labs/assignment1/part2/#ex3","title":"Exercise 3: Controlling Velocity with the ROS2 CLI","text":"<p>Warning</p> <p>Make sure that you've stopped the <code>teleop_keyboard</code> node before starting this exercise!</p> <p>We can use the <code>ros2 topic pub</code> command to publish data to a topic from a terminal by using the command in the following way:</p> <pre><code>ros2 topic pub {topic_name} {message_type} {message_data}\n</code></pre> <p>As we discovered earlier, the <code>/cmd_vel</code> topic is expecting messages containing linear and angular velocity data, each with an <code>x</code>, <code>y</code> and <code>z</code> component. When publishing topic messages in a terminal the commands can get quite long and complicated, but we can use autocomplete functionality to help us format the full command correctly.</p> <ol> <li> <p>In TERMINAL 3 type the following, using the Tab key where indicated to invoke autocompletion...</p> <ol> <li> <p>First, type the text as shown below and then press the Tab key where indicated to complete the topic name for you:</p> <pre><code>ros2 topic pub /cmd_[TAB]\n</code></pre> </li> <li> <p>Then, type <code>g</code> and then press Tab again to format the rest of the message type for you: </p> <pre><code>ros2 topic pub /cmd_vel g[TAB]\n</code></pre> </li> <li> <p>The message data then needs to be entered inside quotation marks, type <code>\"l</code> and then press Tab again to obtain the format of the message data:</p> <pre><code>ros2 topic pub /cmd_vel geometry_msgs/msg/Twist \"l[TAB]\n</code></pre> <p>The full command will then be presented:</p> <pre><code>ros2 topic pub /cmd_vel geometry_msgs/msg/Twist \"linear:\n  x: 0.0\n  y: 0.0\n  z: 0.0\nangular:\n  x: 0.0\n  y: 0.0\n  z: 0.0\"\n</code></pre> <p>Tip</p> <p>You can use Tab to autocomplete lots of terminal commands, experiment with it - it'll save you lots of time! </p> </li> </ol> </li> <li> <p>Scroll back through the message using the Left key on your keyboard and then edit the values of the various fields, as appropriate.</p> <p>First, define some values that would make the robot rotate on the spot.  </p> </li> <li> <p>Enter Ctrl+C in TERMINAL 3 to stop the message from being published.</p> <p>What happens to the robot when you stop the <code>ros2 topic pub</code> command?</p> <p>... it keeps on moving at the requested velocity!</p> <p>In order to make the robot actually stop, we need to publish a new message containing alternative velocity commands.</p> </li> <li> <p>In TERMINAL 3 press the Up key on your keyboard to recall the previous command, but don't press Enter just yet! Now press the Left key to track back through the message and change the velocity field values in order to now make the robot stop.</p> </li> <li> <p>Once again, enter Ctrl+C in TERMINAL 3 to stop the publisher from actively publishing new messages, and then follow the same steps as above to compose another new message to now make the robot move in a circle.</p> </li> <li> <p>Enter Ctrl+C to again stop the message from being published, publish a further new message to stop the robot, and then compose (and publish) a message that would make the robot drive in a straight line.</p> </li> <li> <p>Finally, stop the robot again!</p> </li> </ol>"},{"location":"labs/assignment1/part2/#ex4","title":"Exercise 4: Creating a Python Node to Make a Robot Move in a circle","text":"<p>Controlling a robot from the terminal (or by using the <code>teleop_keyboard</code> node) is all well and good, but what about if we need to implement some more advanced control or autonomy?</p> <p>We'll now learn how to control the velocity of our robot programmatically, from a Python Node. We'll start out with a simple example to achieve a simple velocity profile (a circle), but this will provide us with the basis on which we can build more complex velocity control algorithms (which we'll look at in the following exercise).</p> <p>In Part 1 we built a simple publisher node, and this one will work in much the same way, but this time however, we need to publish <code>Twist</code> type messages to the <code>/cmd_vel</code> topic instead... </p> <ol> <li> <p>In TERMINAL 2, ensure that you're located within the <code>scripts</code> folder of your <code>part2_navigation</code> package (you could use <code>pwd</code> to check your current working directory).</p> <p>If you aren't located here then navigate to this directory using <code>cd</code>.</p> </li> <li> <p>Create a new file called <code>move_circle.py</code>:</p> <p>TERMINAL 2: <pre><code>touch move_circle.py\n</code></pre> ... and make this file executable using the <code>chmod</code> command (as we did in Part 1).</p> </li> <li> <p>The task is to make the robot move in a circle with a path radius of approximately 0.5 meters.</p> <p>Follow the steps here for building this (using the Part 1 Publisher Node as a starting point). </p> </li> <li> <p>Our <code>move_circle.py</code> node has a new dependency:</p> <pre><code>from geometry_msgs.msg import Twist\n</code></pre> <p>We therefore need to add this dependency to our package's <code>package.xml</code> file.</p> <p>Earlier on we added <code>nav_msgs</code> to this. Below this, add a new <code>&lt;exec_depend&gt;</code> for <code>geometry_msgs</code>:</p> package.xml<pre><code>&lt;exec_depend&gt;rclpy&lt;/exec_depend&gt;\n&lt;exec_depend&gt;nav_msgs&lt;/exec_depend&gt;\n&lt;exec_depend&gt;geometry_msgs&lt;/exec_depend&gt;  &lt;!-- (1)! --&gt;\n</code></pre> <ol> <li>ADD THIS LINE!</li> </ol> </li> <li> <p>Next (hopefully you're getting the idea by now!), declare the <code>move_circle.py</code> node as an executable in the <code>CMakeLists.txt</code>:</p> CMakeLists.txt<pre><code># Install Python executables\ninstall(PROGRAMS\n  scripts/odom_subscriber.py\n  scripts/move_circle.py\n  DESTINATION lib/${PROJECT_NAME}\n)\n</code></pre> </li> <li> <p>Finally, head back to the terminal and use Colcon to build the new node alongside everything else in the package:</p> <pre><code>cd ~/ros2_ws/ &amp;&amp; colcon build --packages-select part2_navigation --symlink-install\n</code></pre> </li> <li> <p>Run this node now, using <code>ros2 run</code> and see what happens:</p> <pre><code>ros2 run part2_navigation move_circle.py\n</code></pre> <p>Head back to the Gazebo simulation and watch as the robot moves around in a circle of 0.5 meter radius!</p> </li> <li> <p>Once you're done, enter Ctrl+C in TERMINAL 2 to stop the <code>move_circle.py</code> node. Notice what happens to the robot when you do this...</p> <p>Question</p> <p>What does happen to the robot when you hit Ctrl+C to stop the node?</p> <p>Answer: It carries on moving !</p> </li> </ol>"},{"location":"labs/assignment1/part2/#ex5","title":"Exercise 5: Implementing a Shutdown Procedure","text":"<p>Clearly, our work on the <code>move_circle.py</code> node isn't quite done. When we terminate our node we'd expect the robot to stop moving, but this (currently) isn't the case. </p> <p>You may have also noticed (with all the nodes that we have created so far) an error traceback in the terminal, every time we hit Ctrl+C. </p> <p>None of this is very good, and we'll address this now by modifying the <code>move_circle.py</code> file to incorporate a proper (and safe) shutdown procedure.</p> <ol> <li> <p>Return to the <code>move_circle.py</code> file in VS Code. </p> </li> <li> <p>First, we need to add an import to our Node:</p> <pre><code>from rclpy.signals import SignalHandlerOptions\n</code></pre> <p>You'll see what this is for shortly...</p> </li> <li> <p>Then move on to the <code>__init__()</code> method of your <code>Circle()</code> class.</p> <p>Add in a boolean flag here called <code>shutdown</code>:</p> <pre><code>self.shutdown = False\n</code></pre> <p>... to begin with, we want this to be set to <code>False</code>.</p> </li> <li> <p>Next, add a new method to your <code>Circle()</code> class, called <code>on_shutdown()</code>:</p> <pre><code>def on_shutdown(self):\n    self.get_logger().info(\n        \"Stopping the robot...\"\n    )\n    self.my_publisher.publish(Twist()) # (1)!\n    self.shutdown = True # (2)!\n</code></pre> <ol> <li>All velocities within the <code>Twist()</code> message class are set to zero by default, so we can just publish this as-is, in order to ask the robot to stop.</li> <li>Set the <code>shutdown</code> flag to true to indicate that a stop message has now been published.</li> </ol> </li> <li> <p>Finally, head to the <code>main()</code> function of the script. This is where most of the changes need to be made...</p> <pre><code>def main(args=None):\n    rclpy.init(\n        args=args,\n        signal_handler_options=SignalHandlerOptions.NO\n    ) # (1)!\n    move_circle = Circle()\n    try:\n        rclpy.spin(move_circle) # (2)!\n    except KeyboardInterrupt: # (3)!\n        print(\n            f\"{move_circle.get_name()} received a shutdown request (Ctrl+C).\"\n        )\n    finally: \n        move_circle.on_shutdown() # (4)!\n        while not move_circle.shutdown: # (5)!\n            continue\n        move_circle.destroy_node() # (6)!\n        rclpy.shutdown()\n</code></pre> <ol> <li> <p>When initialising <code>rclpy</code>, we're requesting for our <code>move_circle.py</code> node to handle \"signals\" (i.e. events like a Ctrl+C), rather than letting <code>rclpy</code> handle these for us. Here we're using the <code>SignalHandlerOptions</code> object that we imported from <code>rclpy.signals</code> earlier.</p> </li> <li> <p>We set our node to spin inside a Try-Except block now, so that we can catch a <code>KeyboardInterrupt</code> (i.e. a Ctrl+C) and act accordingly when this happens.</p> </li> <li> <p>On detection of the <code>KeyboardInterrupt</code> we print a message to the terminal. After this, the code will move on to the <code>finally</code> block...</p> </li> <li> <p>Call the <code>on_shutdown()</code> method that we defined earlier. This will ensure that a STOP command is published to the robot (via <code>/cmd_vel</code>).</p> </li> <li> <p>This <code>while</code> loop will continue to iterate until our boolean <code>shutdown</code> flag has turned <code>True</code>, to indicate that the STOP message has been published.</p> </li> <li> <p>The rest is the same as before...</p> <p>... destroy the node and then shutdown <code>rclpy</code>.</p> </li> </ol> </li> <li> <p>With all this in place, run the node again now (<code>ros2 run ...</code>).</p> <p>Now, when you hit Ctrl+C you should find that the robot actually stops moving. Ah, much better!</p> </li> </ol>"},{"location":"labs/assignment1/part2/#odometry-based-navigation","title":"Odometry-based Navigation","text":"<p>Over the course of the previous two exercises we've created a Python node to make your robot move using open-loop control. To achieve this we published velocity commands to the <code>/cmd_vel</code> topic to make the robot follow a circular motion path.</p> <p>Questions</p> <ol> <li>How do we know if our robot actually achieved the motion path that we asked for?</li> <li>In a real-world environment, what external factors might result in the robot not achieving its desired trajectory?</li> </ol> <p>Earlier on we also learnt about Robot Odometry, which is used by the robot to keep track of its position and orientation (aka Pose) in the environment.  As explained earlier, this is determined by a process called \"dead-reckoning,\" which is only really an approximation, but it's a fairly good one in any case, and we can use this as a feedback signal to understand if our robot is moving in the way that we expect it to.</p> <p>We can therefore build on the techniques that we used in the <code>move_circle.py</code> exercise, and now also build in the ability to subscribe to a topic too and obtain some real-time feedback. To do this, we'll need to subscribe to the <code>/odom</code> topic, and use this to implement some basic closed-loop control.</p>"},{"location":"labs/assignment1/part2/#ex6","title":"Exercise 6: Making our Robot Follow a Square Motion Path","text":"<ol> <li> <p>Make sure your <code>move_circle.py</code> node is no longer running in TERMINAL 2, stopping it with Ctrl+C if necessary.</p> </li> <li> <p>Make sure TERMINAL 2 is still located inside your <code>part2_navigation</code> package.</p> </li> <li> <p>Navigate to the package <code>scripts</code> directory and use the Linux <code>touch</code> command to create a new file called <code>move_square.py</code>:</p> <p>TERMINAL 2: <pre><code>touch move_square.py\n</code></pre></p> </li> <li> <p>Then make this file executable using <code>chmod</code>:</p> <p>TERMINAL 2: <pre><code>chmod +x move_square.py\n</code></pre></p> </li> <li> <p>Use the VS Code File Explorer to navigate to this <code>move_square.py</code> file and open it up, ready for editing.</p> </li> <li>There's a template here to help you with this exercise. Copy and paste the template code into your new <code>move_square.py</code> file to get you started. </li> <li> <p>Run the code as it is to see what happens... </p> <p>Fill in the Blank!</p> <p>Something not quite working as expected? Did we forget something very crucial on the very first line of the code template?!</p> </li> <li> <p>Fill in the blank as required and then adapt the code to make your robot follow a square motion path of 1 x 1 meter dimensions.</p> </li> </ol> <p>After following a square motion path a few times, your robot should return to the same location that it started from.</p> <p>Advanced feature</p> <p>Adapt the node to make the robot automatically stop once it has performed two complete loops.</p>"},{"location":"labs/assignment1/part2/#wrapping-up","title":"Wrapping Up","text":"<p>In this session we've learnt how to control the velocity and position of a robot from both the command-line (using ROS command-line tools) and from ROS Nodes by publishing correctly formatted messages to the <code>/cmd_vel</code> topic.  </p> <p>We've also learnt about Odometry, which is published by our robot to the <code>/odom</code> topic.  The odometry data tells us the current linear and angular velocities of our robot in relation to its 3 principal axes.  In addition to this though, it also tells us where in physical space our robot is located and oriented, which is determined based on dead-reckoning. </p> <p>Questions</p> <ol> <li>What information (sensor/actuator data) is used to do this?</li> <li>Do you see any potential limitations of this?</li> </ol> <p>Consider reading Chapter 11.1.3 (\"Pose of Robot\") in the ROS Robot Programming eBook that we mentioned here.</p> <p>In the final exercise we explored the development of odometry-based control to make a robot follow a square motion path. You will likely have observed some degree of error in this which could be due to the fact that Odometry data is determined by dead-reckoning and is therefore subject to drift and error. Consider how other factors may impact the accuracy of control too.</p> <p>Questions</p> <ol> <li>How might the rate at which the odometry data is sampled play a role?</li> <li>How quickly can your robot receive new velocity commands, and how quickly can it respond?</li> </ol> <p>Be aware that we did all this in simulation here too. In fact, in a real world environment, this type of navigation might be less effective, since things such as measurement noise and calibration errors can also have considerable impact. You will have the opportunity to experience this first hand in the labs.</p> <p>Ultimately then, we've seen a requirement here for additional information to provide more confidence of a robot's location in its environment, in order to enhance its ability to navigate effectively and avoid crashing into things! We'll explore this further later in this course.</p> <ol> <li> <p>Quaternions are explained very nicely here, if you'd like to learn more.\u00a0\u21a9</p> </li> </ol>"},{"location":"labs/assignment1/part3/","title":"Part 3: SLAM and Autonomous Navigation","text":""},{"location":"labs/assignment1/part3/#introduction","title":"Introduction","text":"<p> Exercises: X</p> <p> Estimated Completion Time: Y</p>"},{"location":"labs/assignment1/part3/#aims","title":"Aims","text":"<p>From the work you did in Part 2 you may have started to appreciate the limitations associated with using odometry data alone as a feedback signal when trying to control a robot's position in its environment. In this next part you will explore an alternative data-stream that could be used to aid navigation further. You will leverage some existing ROS 2 libraries and TurtleBot3 packages to explore some really powerful mapping and autonomous navigation methods that are available within ROS.</p>"},{"location":"labs/assignment1/part3/#intended-learning-outcomes","title":"Intended Learning Outcomes","text":"<p>By the end of this session you will be able to:</p> <p>//add to the ILOs// </p> <ol> <li>Interpret the data that is published to the <code>/scan</code> topic and use existing ROS tools to visualise this.</li> <li>Use existing ROS tools to implement SLAM and build a map of an environment. </li> <li>Leverage existing ROS libraries to make a robot navigate an environment autonomously, using the map that you have generated.</li> <li>Explain how these SLAM and Navigation tools are implemented and what information is required in order to make them work.</li> </ol>"},{"location":"labs/assignment1/part3/#quick-links","title":"Quick Links","text":"<ul> <li>Exercise 1: Using RViz to Visualise Robot Data</li> <li>Exercise 2: Building a map of an environment with SLAM</li> <li>Exercise 3: Navigating an Environment Autonomously</li> </ul>"},{"location":"labs/assignment1/part3/#getting-started","title":"Getting Started","text":"<p>Step 1: Launch your ROS Environment</p> <p>If you haven't done so already, launch your ROS environment now:</p> <ol> <li>Option 1 </li> <li>Option 2</li> <li>Option 3</li> </ol> <p>Step 2: Make Sure The Course Repo is Up-To-Date</p> <p>In Part 1 you should have downloaded and installed The Course Repo into your ROS environment. Hopefully you've done this by now, but if you haven't then go back and do it now (you'll need it for some exercises here). If you have already done it, then (once again) it's worth just making sure it's all up-to-date, so run the following command now to do so:</p> <p>TERMINAL 1: <pre><code>cd ~/ros2_ws/src/tuos_ros/ &amp;&amp; git pull\n</code></pre></p> <p>Then build with Colcon: </p> <pre><code>cd ~/ros2_ws/ &amp;&amp; colcon build\n</code></pre> <p>And finally, re-source your environment:</p> <pre><code>source ~/.bashrc\n</code></pre> <p>Warning</p> <p>If you have any other terminal instances open, then you'll need run <code>source ~/.bashrc</code> in these too, in order for any changes made by the Colcon build process to propagate through to these as well.</p>"},{"location":"labs/assignment1/part3/#lidar","title":"Laser Displacement Data and The LiDAR Sensor","text":"<p>As you'll know from Part 2, odometry is really important for robot navigation, but it can be subject to drift and accumulated error over time.</p>"},{"location":"labs/assignment1/part3/#ex1","title":"Exercise 1: Using RViz to Visualise Robot Data","text":"<p>We're now going to place the robot in a more interesting environment than the \"empty world\" we've used in the previous parts of this course so far...</p> <ol> <li> <p>In TERMINAL 1 enter the following command to launch this:</p> <p>//need to check// <pre><code>ros2 launch turtlebot3_gazebo x.launch.py\n</code></pre> A Gazebo simulation should now be launched with a TurtleBot3 Waffle in a new environment:</p> </li> <li> <p>Open a new terminal instance (TERMINAL 2) and enter the following:</p> <p>TERMINAL 2: <pre><code>ros2 launch tuos_simulations rviz.launch\n</code></pre></p> <p>On running the command a new window should open:</p> <p>This is RViz, which is a ROS tool that allows us to visualise the data being measured by a robot in real-time. The red dots scattered around the robot represent laser displacement data which is measured by the LiDAR sensor located on the top of the robot.  This data allows the robot to measure the distance to any obstacles in its immediate surroundings. The LiDAR sensor spins continuously, sending out laser pulses as it does so. These laser pulses then bounce off any objects and are reflected back to the sensor. Distance can then be determined based on the time it takes for the pulses to complete the full journey (from the sensor, to the object, and back again), by a process called \"time of flight\". Because the LiDAR sensor spins and performs this process continuously, a full 360\u00b0 scan of the environment can be generated.  In this case (because we are working in simulation here) the data represents the objects surrounding the robot in its simulated environment, so you should notice that the red dots produce an outline that resembles the objects in the world that is being simulated in Gazebo (or partially at least).</p> </li> </ol>"},{"location":"labs/assignment1/part4/","title":"Part 4: ROS 2 Services","text":""},{"location":"labs/assignment1/part4/#introduction","title":"Introduction","text":"<p> Exercises: X</p> <p> Estimated Completion Time: Y hours</p>"},{"location":"labs/assignment1/part4/#aims","title":"Aims","text":"<p>In this part you will learn about ROS Services, a communication method that facilitates request-response interactions between nodes. You will understand how to use ROS services in combination with standard publisher/subscriber principles to enhance control for specific operations. Additionally, you'll create custom messages and services for tailored communication.</p>"},{"location":"labs/assignment1/part4/#intended-learning-outcomes","title":"Intended Learning Outcomes","text":"<p>By the end of this session you will be able to:</p> <ol> <li>Recognise how ROS Services differ from the standard topic-based publisher-subscriber approach, and identify appropriate use-cases for this type of messaging system.</li> <li>Implement Python node pairs to observe services in action, and understand how they work.</li> <li>Invoke different services using a range of service message types.</li> <li>Develop Python Service nodes of your own to perform specific robotic tasks.</li> <li>Harness Services, in combination with LiDAR data, to implement a basic obstacle avoidance behaviour </li> <li>Develop custom ROS messages and services (still need to think about the task for this) </li> <li>Demonstrate your understanding of ROS2 so far by developing a Python node which incorporates elements from this and previous parts of this course.</li> </ol>"},{"location":"labs/assignment1/part4/#quick-links","title":"Quick Links","text":"<ul> <li>Exercise 1: </li> </ul>"},{"location":"labs/assignment1/part4/#additional-resources","title":"Additional Resources","text":""},{"location":"labs/assignment1/part4/#prerequisites","title":"Prerequisites","text":"<p>Before we begin, ensure that you have the following:</p> <ol> <li>ROS2 Humble installed on your system</li> <li>Cloned the tuos package from github</li> <li>Basic understanding of ROS2 concepts like nodes and topics</li> </ol>"},{"location":"labs/assignment1/part4/#getting-started","title":"Getting Started","text":"<p>Step 1: Launch your ROS Environment</p> <p>If you haven't done so already, launch your ROS environment now:</p> <p>Step 2: Restore your work (todo)</p> <p>Step 3: Launch VS Code (todo) </p> <p>Step 4: Make Sure The Course Repo is Up-To-Date</p> <p>Once again, it's worth quickly checking that the Course Repo is up-to-date before you start on the Part 4 exercises. Go back to Part 1 if you haven't installed it yet (really?!). For the rest, run the following commands: <pre><code>cd ~/ros2_ws/src/tuos_ros/ &amp;&amp; git pull\n</code></pre></p> <p>Now build with colcon: <pre><code>cd ~/ros2_ws/ &amp;&amp; colcon build \n</code></pre> Finally, re-source the environment  <pre><code>source ~/.bashrc\n</code></pre></p>"},{"location":"labs/assignment1/part4/#step-5-launch-the-robot-simulation","title":"Step 5: Launch the Robot Simulation","text":"<p>From TERMINAL 1, launch the TurtleBot3 Waffle \"Empty World\"  simulation:</p> <p>TERMINAL 1: <pre><code>ros2 launch turtlebot3_gazebo turtlebot3_empty_world.launch\n</code></pre> ...and then wait for the Gazebo window to open:</p>"},{"location":"labs/assignment1/part4/#an-introduction-to-services","title":"An Introduction to Services","text":"<p>So far, we've learnt about ROS topics and messages, and how individual nodes can access data on a robot by simply subscribing to topics that are being published by any other node on the system.  In addition to this, we also learnt how any node can publish messages to any topic: this essentially broadcasts the data contained in the message across the ROS Network, making it available to any other node on the network that may wish to access it.</p> <p>ROS2 uses interface as a communication structure that allow different nodes to exchange data. These interfaces are broadly categorized into three types:</p> <ol> <li>Messages</li> <li>Services</li> <li>Actions</li> </ol> <p>We have already learned how to use <code>Messages</code> in part 2 and now we will learn in detail about <code>ROS2 Services</code>.   </p> <p>These are different to messages in that \"Service calls\" (that is, the process of requesting a service) occur only between one node and another:</p> <ul> <li>One node (a Service Client) sends a Request to another node.</li> <li>Another node (a Service Server) processes that request, performs an action and then sends back a Response.</li> </ul> <p></p> <p>Services are Synchronous (or sequential): When a ROS node sends a request to a service (as a Service Client) it can't do anything else until the service has been completed and the Service Server has sent a response back. This can be useful for a few reasons:</p> <ul> <li> <p>There can be multiple service clients using the same service but only one service server for a service. </p> </li> <li> <p>Discrete, short-duration actions: A robot might need to do something before it can move on to something else, e.g.:</p> <ul> <li>A robot needs to see something before it can move towards it.</li> <li>High definition cameras generate large amounts of data and consume battery power, so you may wish to turn a camera on for a specific amount of time (e.g. until an image has been captured) and then turn it off again.</li> </ul> </li> <li> <p>Computations: Remember that ROS is network-based, so you might want to offload some computations to a remote computer or a different device on a robot, e.g.:</p> <ul> <li>A client might send some data and then wait for another process (the server) to process it and send back the result.</li> </ul> </li> </ul> <p>It's also worth noting that any number of ROS Client nodes can call a service, but you can only have a single Server providing that particular service at any one time.</p> <p></p> <p>Question</p> <p>Can you think of any other scenarios where this type of communication protocol might be useful?</p>"},{"location":"labs/assignment1/part4/#ex1","title":"Exercise 1: Creating a Service Server in Python and calling it from the command-line","text":"<p>To start with, let's set up a service and learn how to make a call to it from the command-line to give you an idea of how this all works and why it might be useful.</p> <ol> <li> <p>First open up a new terminal instance (TERMINAL 2) and source your ROS2 environment as you did in part 1: </p> <ol> <li>Now navigate into the Course Repo <code>ros2_ws/src/tuos_ros</code> and run the helper script agian as you did in part 1 to create a new package called <code>part4_services</code>:</li> </ol> <p>TERMINAL 2: <pre><code>./create_pkg.sh part4_services        \n</code></pre></p> <p>Your terminal will return a message verifying the creation of your package.</p> </li> <li> <p>Navigate into the new package directory using cd:</p> <p>TERMINAL 2:</p> <pre><code>cd ../part4_services/\n</code></pre> </li> <li> <p>Then navigate into the <code>scripts</code> folder in the package directory (using cd) and create an empty file called <code>move_server.py</code> using <code>touch</code> command.     <pre><code>touch move_server.py\n</code></pre></p> </li> <li> <p>Open the file in VS Code, copy and paste this code and then save it.  (todo: need to add the template)</p> <p>Note</p> <p>It's really important that you understand how the code above works, so that you know how to build your own service Servers in Python. Also, make sure that the <code>move_server</code> file is executable using <code>chmod +x</code> command. </p> </li> <li> <p>Next, we need to add our <code>move_server.py</code> file as an executable to our package's <code>CMakeLists.txt</code>. This will ensure that it then gets built when we run <code>colcon build</code> (in the next step):</p> <p>In VS Code, open the <code>CMakeLists.txt</code> file that is at the root of your <code>part4_services</code> package directory (<code>ros2_ws/src/part4_services/CMakeLists.txt</code>). Locate the lines (near the bottom of the file) that read:</p> <pre><code># Install Python executables\ninstall(PROGRAMS\n  scripts/minimal_node.py\n  DESTINATION lib/${PROJECT_NAME}\n)\n</code></pre> <p>Replace <code>minimal_node.py</code> with <code>move_server.py</code> to define this as a Python executable in your package:</p> <p><pre><code># Install Python executables\ninstall(PROGRAMS\n  scripts/publisher.py\n  DESTINATION lib/${PROJECT_NAME}\n)\n</code></pre> i.  It's a good practice to run <code>rosdep</code> in the root of your workspace (<code>ros2_ws</code>) to check for missing dependencies before building:</p> <pre><code>rosdep install -i --from-path src --rosdistro humble -y\n</code></pre> </li> <li> <p>Then, use Colcon to build your new package and its contents :</p> <p>TERMINAL 2: <pre><code>cd ~/ros2_ws/ &amp;&amp; colcon build --packages-select part4_services --symlink-install\n</code></pre> i. Finally re-source your <code>bashrc</code>:  <pre><code>source ~/.bashrc\n</code></pre></p> </li> <li> <p>Now, we are ready to run the node. Use <code>ros2 run</code> and observe what is displayed on the terminal </p> <p>TERMINAL 2: <pre><code>ros2 run part4_services move_server.py\n</code></pre> You should see this message:  <pre><code>The 'move_service' server is ready to be called...\n</code></pre></p> </li> <li> <p>Open a new terminal window (TERMINAL 3) </p> </li> <li> <p>While the node is running, use <code>ros2 service</code> command to view all the currently active services on the system:</p> <p>TERMINAL 3: <pre><code>ros2 service list\n</code></pre> You should see the <code>/move_service</code> service that we defined in the Python code: <pre><code>service_name = \"move_service\"\n</code></pre></p> </li> <li> <p>We can find out more about this using the <code>ros2 service type</code> command:</p> <p>TERMINAL 3: <pre><code>ros2 service type /move_service \n</code></pre> Which should provide the following output:</p> <pre><code>std_srvs/srv/SetBool \n</code></pre> <p>This shows that the <code>move_service_server</code> node is using <code>SetBool</code> service (or interface) type defined in the <code>std_srv</code> package</p> <p>Tip</p> <p>You can also view the type of all services at the same time by adding <code>-t</code> to the <code>ros2 service list</code> command.</p> </li> <li> <p>We can also call this service from the command line using <code>ros2 service call</code>. <pre><code>ros2 service call &lt;service_name&gt; &lt;service_type&gt; &lt;arguments&gt; \n</code></pre></p> <p>In this case,  <pre><code>ros2 service call /move_service std_srvs/srv/SetBool \"data: false\"\n</code></pre></p> </li> <li> <p>Press Enter to issue the command and make a call to the service.      You should see the following response:     <pre><code>requester: making request: std_srvs.srv.SetBool_Request(data=False)\n\nresponse:\nstd_srvs.srv.SetBool_Response(success = False, message=\"Nothing happened, set request_signal to 'true' next time.\")\n</code></pre></p> </li> <li> <p>Arrange the terminals 1 and 3 so that you can see both the Gazebo simulation and the terminal that you just issued the <code>ros2 service call</code> command in.</p> </li> <li> <p>In TERMINAL 3 enter the <code>ros2 service call</code> command again, but this time set the <code>data</code> input to <code>true</code>. You should be able to see the response of the robot in Gazebo simulation. Switch back to TERMINAL 2 and observe the terminal output there as well. </p> </li> </ol> <p>Summary</p> <p>In the section above, you learned how to create a Service Server node. This node sits idle and keeps waiting for its service to be called. Then you called the service through command line which prompted the Server to carry out the following tasks defined in the Python code,     1. Start a timer     1. Issue a velocity commnad to the robot to move it forward     1. Wait for 5 seconds     1. Issue a velocity command to stop the robot     1. Get the service Response and issue it as an output to the terminal in which the service is called</p>"},{"location":"labs/assignment1/part4/#understanding-key-features-of-ros2-service","title":"Understanding key features of ros2 service","text":"<p>In Part 2, you learned how to find out more about a particular message type, using the <code>ros2 interface show</code> command. You can do the same to find out the details of service type as follow: </p> <p>Terminal 3 <pre><code>ros2 interface show std_srvs/srv/SetBool\n</code></pre> which will give the following output: </p> <pre><code>bool data   # e.g. for hardware enabling / disabling \n---\nbool success     # indicate successful run of triggered service\nstring message   # informational, e.g. for error messages\n</code></pre>"},{"location":"labs/assignment1/part4/#the-format-of-setbool-service","title":"The Format of SetBool Service","text":"<p>The service above is structured in two parts separated by three hyphens (<code>---</code>). The part above the hyphens is called the Service Request while the part below is Service Response:</p> <pre><code>bool data        &lt;-- Request \n---\nbool success     &lt;-- Response (Parameter 1 of 2)\nstring message   &lt;-- Response (Parameter 2 of 2)\n</code></pre> <p>In order to Call a service, we need to provide data to it in the format specified in the Request section. A service Server (like the Python node we created above) will then send data back to the caller in the format specified in the Response section.</p> <p>The <code>std_srvs/srv/SetBool</code> service that we're working with here has one request parameter:</p> <ol> <li>A boolean input called <code>data</code>     ...which is the only thing we need to send to the Service Server in  order to call the service.</li> </ol> <p>There are then two response parameters:</p> <ol> <li>A boolean flag called <code>success</code></li> <li>A text string called <code>message</code>     ...both of these will be returned to the client, by the server, once  the Service has completed.</li> </ol>"},{"location":"labs/assignment1/part4/#ex2","title":"Exercise 2: Creating a Python Service Client Node","text":"<p>Instead of calling a service from command-line we can also build Python Service Client Nodes to do the same. In this exercise you will learn how this is done.</p> <ol> <li> <p>TERMINAL 3 should be idle, so from here navigate to the <code>scripts</code> folder within the <code>part4_services</code> package that we created earlier:</p> <p>TERMINAL 3: <pre><code>cd ~/ros2_ws/src/part4_services/scripts\n</code></pre></p> </li> <li> <p>Create a new file called <code>move_client.py</code></p> </li> <li> <p>Now as you did in the previous exercise, open the VS Code, copy and paste this code and then save it. </p> <p>Note</p> <p>Once again, be sure to read the code and understand how this Python Service Client Node works too!</p> </li> <li> <p>Return to TERMINAL 3 and launch the node using <code>ros2 run</code>:</p> <pre><code>ros2 run part4_services move_client.py \n</code></pre> </li> </ol> <p>The response should be exactly the same when we called the service from the command line. </p>"},{"location":"labs/assignment1/part4/#ex3","title":"Exercise 3: Learn to create custom services","text":"<p>In previous exercises you learned about messages, topics and services by using the predefined definitions of them. While using predefined interfaces is considered a good practice, it is also important to know how you can custom define these interfaces based on your own need. This exercise will teach you, step-by-step, how to create custom service definition and use it to move the robot to the requested position (providing x and y coordinates).</p> <p>Procedure </p> <ol> <li>Close down the Service Server that is currently running in TERMINAL 2</li> <li> <p>Navigate to your <code>part4_services</code> package </p> <p>TERMINAL 2: <pre><code>cd ~ros2_ws/src/part4_services\n</code></pre> and make a new directory <code>srv</code> by running the following command: <pre><code>mkdir srv\n</code></pre></p> </li> <li> <p>Now navigate into the newly created directory <code>srv</code> and create new file called <code>MoveToPosition.srv</code></p> <p>Note</p> <p>It is important that your file name should end with <code>.srv</code> extension as this identifies the file as a ROS service.</p> </li> <li> <p>As we learned earlier, a service file consists of two parts: <code>Request</code> and <code>Response</code>. Here we will provide our own definition for each one of these parts as follow:</p> <p><pre><code>float32 goal_x      &lt;-- request parameter 1 of 2\nfloat32 goal_y      &lt;-- request parameter 2 of 2\n---\nbool success        &lt;-- response \n</code></pre>  The service takes in two user inputs <code>goal_x</code> and <code>goal_y</code> of type <code>float</code> for the <code>x</code> and <code>y</code> coordinates to where the robot needs to move.</p> </li> <li> <p>Open the VS Code, copy and paste the above lines and save the file. </p> </li> <li> <p>We need to add a few lines in the <code>CMakeList.txt</code> to convert the defined service into language-specific code (C++ and Python) and make it usable:</p> <pre><code>find_package(rosidl_default_generators REQUIRED)\nrosidl_generate_interfaces(${PROJECT_NAME}\n\"srv/MoveToPosition.srv\"\n)\n</code></pre> </li> <li> <p>Now open the <code>Package.xml</code> file and add the following lines:     <pre><code>&lt;build_depend&gt;rosidl_default_generators&gt;&lt;/build_depend&gt;\n&lt;exec_depend&gt;rosidl_default_runtime&gt;&lt;/exec_depend&gt;\n&lt;member_of_group&gt;rosidl_interface_packages&gt;&lt;/member_of_group&gt;\n</code></pre>     These lines specify the dependencies required to run the custom service. </p> </li> <li> <p>Next, navigate to the <code>scripts</code> folder of the <code>part4_services</code> package and create an empty file called <code>MoveToPosition.py</code>. </p> </li> <li> <p>Open the newly created file in VS Code. Copy and paste the code provided here. </p> </li> <li> <p>Now modify the code as follow:</p> <ol> <li>Change the imports to utilise the service we just created </li> <li>Develop the callback_function() to: <ol> <li>Process the two parameters that will be provided to the server via the `service request</li> <li>Retrieve the current position and calculate the difference to goal</li> <li>Generate movement command to the specific coordinates</li> <li>Return a correctly formatted service response message to the service caller</li> </ol> </li> <li>Launch the server node using <code>ros2 run</code> command from TERMINAL 2 and <code>call</code> the service from the command-line using <code>ros2 service call</code> in TERMINAL 3 as you did earlier</li> </ol> </li> <li> <p>Make sure you build the package in the root directory of ros2 workspace using <code>colcon</code> and source the environment: </p> Tip <p>For convenience, you can use a handy alias <code>src</code> instead of writing the whole <code>source ~/.bashrc</code></p> </li> </ol>"},{"location":"labs/assignment1/part4/#a-recap-on-everything-youve-learnt-so-far","title":"A recap on everything you've learnt so far...","text":"<p>You should now hopefully understand how to use the ROS2 Service architecture and understand why, and in what context, it might be useful to use this type of communication method in a robot application.</p> <p>Remember</p> <p>Services are synchronous and are useful for one-off, quick actions or for offloading jobs or computations that might need to be done before something else can happen. (Think of it as a transaction that you might make in a shop: You hand over some money, and in return you get a chocolate bar, for example!)</p>"},{"location":"labs/assignment1/part4/#ex4","title":"Exercise 4: Creating your own Service","text":"<p>In this exercise you will create your own service Server to make the Waffle perform a specific movement for a given amount of time and then stop.</p>"},{"location":"labs/assignment1/part1/publisher/","title":"A Simple Publisher Node","text":""},{"location":"labs/assignment1/part1/publisher/#the-code","title":"The Code","text":"<p>Copy all the code below into your <code>publisher.py</code> file and review the annotations to understand how it all works.</p> <p>Tip</p> <p>Don't forget the Shebang! See below for further details...</p> publisher.py<pre><code>#!/usr/bin/env python3\n# A simple ROS2 Publisher\n\nimport rclpy # (1)!\nfrom rclpy.node import Node\n\nfrom example_interfaces.msg import String # (2)!\n\nclass SimplePublisher(Node): # (3)!\n\n    def __init__(self):\n        super().__init__(\"simple_publisher\") # (4)!\n\n        self.my_publisher = self.create_publisher(\n            msg_type=String,\n            topic=\"my_topic\",\n            qos_profile=10,\n        ) # (5)!\n\n        publish_rate = 1 # Hz\n        self.timer = self.create_timer(\n            timer_period_sec=1/publish_rate, \n            callback=self.timer_callback\n        ) # (6)!\n\n        self.get_logger().info(\n            f\"The '{self.get_name()}' node is initialised.\" # (7)!\n        )\n\n    def timer_callback(self): # (8)!\n        ros_time = self.get_clock().now().seconds_nanoseconds()\n\n        topic_msg = String()\n        topic_msg.data = f\"The ROS time is {ros_time[0]} (seconds).\"\n        self.my_publisher.publish(topic_msg)\n        self.get_logger().info(f\"Publishing: '{topic_msg.data}'\")\n\ndef main(args=None): # (9)!\n    rclpy.init(args=args)\n    my_simple_publisher = SimplePublisher()\n    rclpy.spin(my_simple_publisher)\n    my_simple_publisher.destroy_node()\n    rclpy.shutdown()\n\nif __name__ == '__main__': # (10)!\n    main()\n</code></pre> <ol> <li> <p><code>rclpy</code> is the ROS Client Library for Python. </p> <p>This is a vital import that allows us to create ROS nodes and initialise them on the ROS network.</p> <p>We also import the <code>Node</code> class from the <code>rclpy.node</code> library. This is a ready-made Python Class that contains all the necessary functionality that a Python ROS Node might need, so we'll use this as the basis for our own node (which we'll create shortly).</p> </li> <li> <p>We also need to import the <code>String</code> message type from the <code>example_interfaces.msg</code> library for publishing our messages.</p> </li> <li> <p>We create a Python class called <code>SimplePublisher()</code>, which we'll use to encapsulate all the functionality of our node.</p> <p>The vast majority of the functionality of this node is inherited from the <code>rclpy.node</code>, <code>Node()</code> Class which we imported above. </p> </li> <li> <p>Using the <code>super()</code> method we call the <code>__init__()</code> method from the parent Node class that our <code>SimplePublisher</code> class is derived from.</p> <p>We provide a name here, which is the name that will be used to register our node on the ROS network (we can call the node anything that we want, but it's a good idea to call it something meaningful).</p> </li> <li> <p>We then use the <code>create_publisher()</code> method (inherited from the <code>Node</code> class) in order to provide our node with the ability to publish messages to a ROS Topic. When calling this we provide 3 key bits of information:</p> <ol> <li> <p><code>msg_type</code>: The type of message that we want to publish.</p> <p>In our case, a <code>String</code> message from the <code>example_interfaces.msg</code> module.</p> </li> <li> <p><code>topic</code>: The name of the topic that we want to publish these messages to.</p> <p>This could be an existing topic (in which case, we'd need to make sure we used the correct message type), or a new topic (in which case, the name can be anything we want it to be).</p> <p>In our case, we want to create a new topic on the ROS network called <code>\"my_topic\"</code>.</p> </li> <li> <p><code>qos_profile</code>: A queue size, which is a \"Quality of Service\" (QoS) setting which limits the amount of messages that are queued in a buffer. </p> <p>In our case, we're setting this to <code>10</code>, which is generally appropriate for most of the applications that we'll be working on.</p> </li> </ol> </li> <li> <p>Here, we're calling the <code>create_timer()</code> method, which we'll use to control the rate at which messages are published to our topic. Here we define 2 things:</p> <ol> <li> <p><code>timer_period_sec</code>: The rate at which we want the timer to run. This must be provided as a period, in seconds. In the line above, we have specified a publishing frequency (in Hz):</p> <p><code>publish_rate = 1 # Hz</code></p> <p>So the associated time period (in seconds) is: </p> <p>\\(T = \\frac{1}{f}\\)</p> </li> <li> <p><code>callback</code>: This is a function that will be executed every time the timer elapses at the desired rate (1 Hz). We're specifying a function called <code>timer_callback</code>, which we'll define later on in the code...</p> </li> </ol> </li> <li> <p>Finally, we use the <code>get_logger().info()</code> method to send a Log message to the terminal to inform us that the initialisation of our node is complete.</p> </li> <li> <p>Here we define the timer callback function. Anything in here will execute at the rate that we specified when we created the <code>create_timer()</code> instance before. In our case:</p> <ol> <li>Use the <code>get_clock()</code> method to get the current ROS Time.</li> <li>Instantiate a <code>String()</code> message (defined as <code>topic_msg</code>).</li> <li>Populate this message with data. In our case, a statement that includes the ROS Time, as obtained above.</li> <li>Call the <code>publish()</code> method of our <code>my_publisher</code> object, to actually publish this message to the <code>\"my_topic\"</code> topic.</li> <li>Send the message data to the terminal as a log message as well, so that we can see what it is when our Node is actually running.</li> </ol> </li> <li> <p>With the functionality of our <code>SimplePublisher</code> class now established, we define a <code>main()</code> function for the Node. This will be fairly common to most Python Nodes that we create, with the following 5 key processes:</p> <ol> <li>Initialise the <code>rclpy</code> library.</li> <li>Create an instance of our <code>SimplePublisher()</code> node.</li> <li>\"Spin\" the node to keep it alive so that any callbacks can execute as required (in our case here, just the <code>timer_callback()</code>). </li> <li>Destroy the node once termination is requested (triggered by entering Ctrl+C in the terminal).</li> <li>Shutdown the <code>rclpy</code> library.</li> </ol> </li> <li> <p>Finally, we call the <code>main()</code> function to set everything going. We do this inside an <code>if</code> statement, to ensure that our node is the main executable (i.e. it has been executed directly (via <code>ros2 run</code>), and hasn't been called by another script)</p> </li> </ol>"},{"location":"labs/assignment1/part1/publisher/#defining-package-dependencies","title":"Defining Package Dependencies","text":"<p>We're importing a couple of Python libraries into our node here, which means that our package has two dependencies: <code>rclpy</code> and <code>example_interfaces</code>:</p> <pre><code>import rclpy \nfrom rclpy.node import Node\n\nfrom example_interfaces.msg import String\n</code></pre> <p>Its good practice to add these dependencies to your <code>package.xml</code> file. Locate this file (<code>ros2_ws/src/part1_pubsub/package.xml</code>), open it up and find the following line:</p> <pre><code>&lt;exec_depend&gt;rclpy&lt;/exec_depend&gt;\n</code></pre> <p><code>rclpy</code> is therefore already defined as an execution dependency (which means that our package needs this library in order to execute our code), but we need to add <code>example_interfaces</code> as well, so add the following additional line underneath:</p> <pre><code>&lt;exec_depend&gt;example_interfaces&lt;/exec_depend&gt;\n</code></pre> <p>Job done. Save the file and close it.</p>"},{"location":"labs/assignment1/part1/publisher/#shebang","title":"The Shebang","text":"<p>The very first line of code looks like a comment, but it is actually a very crucial part of the script:</p> <pre><code>#!/usr/bin/env python3\n</code></pre> <p>This is called the Shebang, and it tells the operating system which interpreter to use to execute the code. In our case here, it tells the operating system where to find the right Python interpreter that should be used to actually run the code.</p> <p> \u2190 Back to Part 1 </p>"},{"location":"labs/assignment1/part1/subscriber/","title":"A Simple Subscriber Node","text":""},{"location":"labs/assignment1/part1/subscriber/#the-code","title":"The Code","text":"<p>Copy all the code below into your <code>subscriber.py</code> file and (again) make sure you read the annotations to understand how it all works!</p> subscriber.py<pre><code>#!/usr/bin/env python3\n# A simple ROS2 Subscriber\n\nimport rclpy # (1)!\nfrom rclpy.node import Node\n\nfrom example_interfaces.msg import String\n\nclass SimpleSubscriber(Node): # (2)! \n\n    def __init__(self): \n        super().__init__(\"simple_subscriber\") # (3)!\n\n        self.my_subscriber = self.create_subscription(\n            msg_type=String,\n            topic=\"{BLANK}\",\n            callback=self.msg_callback,\n            qos_profile=10,\n        ) # (4)!\n\n        self.get_logger().info(\n            f\"The '{self.get_name()}' node is initialised.\"\n        ) # (5)!\n\n    def msg_callback(self, topic_message: String): # (6)!\n        # (7)!\n        self.get_logger().info(f\"The '{self.get_name()}' node heard:\") \n        self.get_logger().info(f\"'{topic_message.data}'\")\n\ndef main(args=None): # (8)!\n    rclpy.init(args=args)\n    my_simple_subscriber = SimpleSubscriber()\n    rclpy.spin(my_simple_subscriber)\n    my_simple_subscriber.destroy_node()\n    rclpy.shutdown() \n\nif __name__ == '__main__':\n    main()\n</code></pre> <ol> <li> <p>As with our publisher node, we need to import the <code>rclpy</code> client library and the <code>String</code> message type from the <code>example_interfaces.msg</code> library in order to write a Python ROS Node and use the relevant ROS messages:</p> </li> <li> <p>This time, we create a Python Class called <code>SimpleSubscriber()</code> instead, but which still inherits the <code>Node</code> class from <code>rclpy</code> as we did with the Publisher before.</p> </li> <li> <p>Once again, using the <code>super()</code> method we call the <code>__init__()</code> method from the parent Node class that our <code>SimpleSubscriber</code> class is derived from, and provide a name to use to register in on the network.</p> </li> <li> <p>We're now using the <code>create_subscription()</code> method here, which will allow this node to subscribe to messages on a ROS Topic. When calling this we provide 4 key bits of information:</p> <ol> <li> <p><code>msg_type</code>: The type of message that the topic uses (which we could obtain by running the <code>ros2 topic info</code> command).</p> <p>We know (having just created the publisher), that our topic uses <code>String</code> messages (from <code>example_interfaces</code>).</p> </li> <li> <p><code>topic</code>: The name of the topic that we want to listen (or subscribe) to.</p> <p>Fill in the Blank!</p> <p>Replace the <code>{BLANK}</code> in the code above with the name of the topic that our <code>publisher.py</code> node was set up to publish to!</p> </li> <li> <p><code>callback</code>: When building a subscriber, we need a callback function, which is a function that will execute every time a new message is received from the topic.</p> <p>At this stage, we define what this callback function is called (<code>self.msg_callback</code>), and we'll actually define the function itself further down within the Class.</p> </li> <li> <p><code>qos_profile</code>: As before, a queue size to limit the amount of messages that are queued in a buffer. </p> </li> </ol> </li> <li> <p>Print a Log message to the terminal to indicate that the initialisation process has taken place.</p> </li> <li> <p>Here we're defining what will happen each time our subscriber receives a new message. This callback function must have only one argument (other than <code>self</code>), which will contain the message data that has been received:</p> <p>We're also using a Python Type Annotation here too, which informs the interpreter that the <code>topic_message</code> that is received by the <code>msg_callback</code> function will be of the <code>String</code> data type.</p> <p>(All this really does is allow autocomplete functionality to work within our text editor, so that whenever we want to pull an attribute from the <code>toic_message</code> object it will tell us what attributes actually exist within the object.)</p> </li> <li> <p>In this simple example, all we're going to do on receipt of a message is to print a couple of log messages to the terminal, to include: </p> <ol> <li> <p>The name of this node (using the <code>self.get_name()</code> method)</p> </li> <li> <p>The message that has been received (<code>topic_mesage.data</code>)</p> </li> </ol> </li> <li> <p>The rest of this is exactly the same as before with our publisher.</p> </li> </ol>"},{"location":"labs/assignment1/part1/subscriber/#dfts","title":"Don't Forget the Shebang!","text":"<p>Remember: don't forget the shebang, it's very important!</p> <pre><code>#!/usr/bin/env python3\n</code></pre> <p> \u2190 Back to Part 1 </p>"},{"location":"labs/assignment1/part2/move_circle/","title":"A Simple Velocity Control Node (Move Circle)","text":""},{"location":"labs/assignment1/part2/move_circle/#the-initial-code","title":"The Initial Code","text":"<p>Start by returning to the <code>publisher.py</code> file from your <code>part1_pubsub</code> package (or return here), and copy the contents into your new <code>move_circle.py</code> file. Then, adapt the code as follows.</p>"},{"location":"labs/assignment1/part2/move_circle/#creating-the-move-circle-node","title":"Creating the \"Move Circle\" Node","text":""},{"location":"labs/assignment1/part2/move_circle/#imports","title":"Imports","text":"<p>Once again, <code>rclpy</code> and the <code>Node</code> class from the <code>rclpy.node</code> library are vital for any node we create, so the first two imports will remain the same.</p> <p>We need to import the message type used by the <code>/cmd_vel</code> topic here though, in order to be able to format velocity command messages appropriately. We can find all the necessary information about this message type by using the <code>ros2 topic info</code> command:</p> <pre><code>$ ros2 topic info /cmd_vel\nType: geometry_msgs/msg/Twist\n...\n</code></pre> <p>And so our message import becomes:</p> <pre><code>from geometry_msgs.msg import Twist # (1)!\n</code></pre> <ol> <li>In place of: <code>from example_interfaces.msg import String</code></li> </ol>"},{"location":"labs/assignment1/part2/move_circle/#change-the-class-name","title":"Change the Class Name","text":"<p>Previously our publisher class was called <code>SimplePublisher()</code>, change this to <code>Circle</code>:</p> <pre><code>class Circle(Node):\n</code></pre>"},{"location":"labs/assignment1/part2/move_circle/#initialising-the-class","title":"Initialising the Class","text":"<ol> <li> <p>Initialise the node with an appropriate name:</p> <pre><code>super().__init__(\"move_circle\")\n</code></pre> </li> <li> <p>Change the <code>create_publisher()</code> parameters:</p> <pre><code>self.my_publisher = self.create_publisher(\n    msg_type=??, # (1)!\n    topic=??, # (2)!\n    qos_profile=10,\n)\n</code></pre> <ol> <li>What message type are we using here?</li> <li>What's the topic name?</li> </ol> </li> <li> <p>We'll need to publish velocity commands at a rate of at least 10 Hz, so set this here, and then set up a timer accordingly:</p> <pre><code>publish_rate = 10 # Hz\nself.timer = self.create_timer(\n    timer_period_sec=1/publish_rate, \n    callback=self.timer_callback\n)\n</code></pre> </li> </ol>"},{"location":"labs/assignment1/part2/move_circle/#modifying-the-timer-callback","title":"Modifying the Timer Callback","text":"<p>Here, we'll publish our velocity commands:</p> <pre><code>def timer_callback(self):\n    radius = 0.5 # meters\n    linear_velocity = 0.1 # meters per second [m/s]\n    angular_velocity = ?? # radians per second [rad/s] # (1)!\n\n    topic_msg = Twist() # (2)!\n    topic_msg.linear.x = linear_velocity\n    topic_msg.angular.z = angular_velocity\n    self.my_publisher.publish(topic_msg) # (3)!\n\n    self.get_logger().info( # (4)!\n        f\"Linear Velocity: {topic_msg.linear.x:.2f} [m/s], \"\n        f\"Angular Velocity: {topic_msg.angular.z:.2f} [rad/s].\",\n        throttle_duration_sec=1, # (5)!\n    )\n</code></pre> <ol> <li> <p>Having defined the radius of the circle, and the linear velocity that we want the robot to move at, how would we calculate the angular velocity that should be applied?</p> <p>Consider the equation for angular velocity:</p> <p> </p> \\[ \\omega=\\frac{v}{r} \\] </li> <li> <p><code>/cmd_vel</code> uses <code>Twist</code> messages, so we instantiate one here, and assign the linear and angular velocity values (as set above) to the relevant message fields. Remember, we talked about all this here.</p> </li> <li> <p>Once the appropriate velocity fields have been set, publish the message.</p> </li> <li> <p>Publish a ROS Log Message to inform us (in the terminal) of the velocity control values that are being published by the node.</p> </li> <li> <p>Remember in the Odometry Subscriber how we used a counter (<code>self.counter</code>) and an <code>if()</code> statement to control the rate at which these log messages were generated?</p> <p>We can actually achieve exactly the same thing by simply supplying a <code>throttle_duration_sec</code> argument to the <code>get_logger().info()</code> call. Much easier, right?</p> </li> </ol>"},{"location":"labs/assignment1/part2/move_circle/#updating-main","title":"Updating \"Main\"","text":"<p>Once again, don't forget to update any relevant parts of the <code>main</code> function to ensure that we're instantiating the <code>Circle()</code> class, spinning and shutting it down correctly.</p> <p> \u2190 Back to Part 2 </p>"},{"location":"labs/assignment1/part2/move_square/","title":"Odometry-based Navigation (Move Square)","text":"<p>A combined publisher-subscriber node to achieve odometry-based control...</p> <p>Below you will find a template Python script to show you how you can both publish to <code>/cmd_vel</code> and subscribe to <code>/odom</code> in the same node.  This will help you build a closed-loop controller to make your robot follow a square motion path of size: 1m x 1m. </p> <p>You can publish velocity commands to <code>/cmd_vel</code> to make the robot move, monitor the robot's position and orientation in real-time, determine when the desired movement has been completed, and then update the velocity commands accordingly.  </p>"},{"location":"labs/assignment1/part2/move_square/#suggested-approach","title":"Suggested Approach","text":"<p>Moving in a square can be achieved by switching between two different movement states sequentially: Moving forwards and turning on the spot. At the start of each movement step we can read the robot's current odometry, and then use this as a reference to compare to, and to tell us when the robot's position/orientation has changed by the required amount, e.g.:</p> <ol> <li>With the robot stationary, read the odometry to determine its current X and Y position in the environment.</li> <li>Move forwards until the robot's X and Y position indicate that it has moved linearly by 0.5m.</li> <li>Stop moving forwards.</li> <li>Read the robot's odometry to determine its current orientation (\"yaw\"/<code>\u03b8<sub>z</sub></code>).</li> <li>Turn on the spot until the robot's orientation changes by 90\u00b0.</li> <li>Stop turning.</li> <li>Repeat.  </li> </ol>"},{"location":"labs/assignment1/part2/move_square/#the-code","title":"The Code","text":"move_square.py<pre><code>import rclpy\nfrom rclpy.node import Node\nfrom rclpy.signals import SignalHandlerOptions\n\nfrom geometry_msgs.msg import Twist # (1)!\nfrom nav_msgs.msg import Odometry # (2)!\n\nfrom part2_navigation.tb3_tools import quaternion_to_euler # (3)!\nfrom math import sqrt, pow, pi # (4)!\n\nclass Square(Node):\n\n    def __init__(self):\n        super().__init__(\"move_square\")\n\n        self.first_message = False\n        self.turn = False \n\n        self.vel_msg = Twist() # (5)! \n        # (6)!\n        self.x = 0.0; self.y = 0.0; self.theta_z = 0.0\n        self.xref = 0.0; self.yref = 0.0; self.theta_zref = 0.0\n        # (7)!\n        self.yaw = 0.0 \n        self.displacement = 0.0 \n\n        self.vel_pub = self.create_publisher(\n            msg_type=Twist,\n            topic=\"cmd_vel\",\n            qos_profile=10,\n        )\n\n        self.odom_sub = self.create_subscription(\n            msg_type=Odometry,\n            topic=\"odom\",\n            callback=self.odom_callback,\n            qos_profile=10,\n        )\n\n        ctrl_rate = 10 # hz\n        self.timer = self.create_timer(\n            timer_period_sec=1/ctrl_rate,\n            callback=self.timer_callback,\n        )\n\n        self.shutdown = False\n\n        self.get_logger().info(\n            f\"The '{self.get_name()}' node is initialised.\"\n        )\n\n    def on_shutdown(self):\n        print(\"Stopping the robot...\")\n        self.vel_pub.publish(Twist())\n        self.shutdown = True\n\n    def odom_callback(self, msg_data: Odometry):\n        pose = msg_data.pose.pose \n\n        (roll, pitch, yaw) = quaternion_to_euler(pose.orientation) # (8)!\n\n        self.x = pose.position.x # (9)!\n        self.y = pose.position.y\n        self.theta_z = abs(yaw) # abs(yaw) makes life much easier!!\n\n        if not self.first_message: # (10)!\n            self.first_message = True\n            self.xref = self.x\n            self.yref = self.y\n            self.theta_zref = self.theta_z\n\n    def timer_callback(self):\n        # here is where the code to control the motion of the robot \n        # goes. Add code here to make the robot move in a square of\n        # dimensions 1 x 1m...\n        if self.turn:\n            # turn by 90 degrees...\n\n\n        else:\n            # move forwards by 1m...\n\n\n        # publish whatever velocity command has been set above:\n        self.vel_pub.publish(self.vel_msg)\n\ndef main(args=None):\n    rclpy.init(\n        args=args,\n        signal_handler_options=SignalHandlerOptions.NO,\n    )\n    move_square = Square()\n    try:\n        rclpy.spin(move_square)\n    except KeyboardInterrupt:\n        print(\n            f\"{move_square.get_name()} received a shutdown request (Ctrl+C).\"\n        )\n    finally:\n        move_square.on_shutdown()\n        while not move_square.shutdown:\n            continue\n        move_square.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> <ol> <li>Import the <code>Twist</code> message for publishing velocity commands to <code>/cmd_vel</code>.</li> <li>Import the <code>Odometry</code> message, for use when subscribing to the <code>/odom</code> topic.</li> <li>Import the <code>quaternion_to_euler</code> function from <code>tb3_tools.py</code> to convert orientation from quaternions to Euler angles (about the principal axes).</li> <li> <p>Finally, import some useful mathematical operations (and <code>pi</code>), which may prove useful for this task:</p> <p> Mathematical Operation Python Implementation \\(\\sqrt{a+b}\\) <code>sqrt(a+b)</code> \\(a^{2}+(bc)^{3}\\) <code>pow(a, 2) + pow(b*c, 3)</code> \\(\\pi r^2\\) <code>pi * pow(r, 2)</code> <p></p> <li> <p>Here we establish a <code>Twist</code> message, which we can populate with velocities and then publish to <code>/cmd_vel</code> within the <code>timer_callback()</code> method (in order to make the robot move).</p> </li> <li> <p>Here, we define some variables that we can use to store relevant bits of odometry data while our node is running (and read it back to implement feedback control):</p> <ul> <li><code>self.x</code>, <code>self.y</code> and <code>self.theta_z</code> will be used by the <code>odom_callback()</code> to store the robot's current pose</li> <li><code>self.x0</code>, <code>self.y0</code> and <code>self.theta_z0</code> can be used in the <code>timer_callback()</code> method to keep a record of where the robot was at a given moment in time (and determine how far it has moved since that point)</li> </ul> </li> <li> <p>We'll also need to keep track of how far the robot has travelled (or turned) in order to determine when sufficient movement has taken place to trigger a switch to the alternative state, i.e.:</p> <ul> <li><code>if</code> travelled 1 meter, <code>then</code>: turn</li> <li><code>if</code> turned 90\u00b0, <code>then</code>: move forward</li> </ul> </li> <li> <p>Here we obtain the robot's current orientation (in quaternions) and convert it to Euler angles (in radians) about the principal axes, where:</p> <ul> <li>\"roll\" = <code>\u03b8<sub>x</sub></code></li> <li>\"pitch\" = <code>\u03b8<sub>y</sub></code></li> <li>\"yaw\" = <code>\u03b8<sub>z</sub></code></li> </ul> </li> <li> <p>We're only interested in <code>x</code>, <code>y</code> and <code>\u03b8<sub>z</sub></code>, so we assign these to class variables <code>self.x</code>, <code>self.y</code> and <code>self.theta_z</code>, so that we can access them elsewhere within our <code>Square()</code> class.</p> </li> <li> <p>Sometimes, it can take a few moments for the first topic message to come through, and it's useful to know when that's happened so that you know you are dealing with actual topic data! Here, we're just setting a flag to <code>True</code> once the callback function has executed for the first time (i.e. the first topic message has been received).</p> </li>"},{"location":"labs/assignment1/part2/move_square/#alternative-approach-waypoint-tracking","title":"Alternative Approach: Waypoint Tracking","text":"<p>A square motion path can be fully defined by the coordinates of its four corners, and we can make the robot move to each of these corners one-by-one, using its odometry system to monitor its real-time position, and adapting linear and angular velocities accordingly.</p> <p>This is slightly more complicated, and you might want to wait until you have a bit more experience with ROS before tackling it this way.</p> <p> \u2190 Back to Part 2 </p>"},{"location":"labs/assignment1/part2/odom_subscriber/","title":"An Odometry Subscriber Node","text":""},{"location":"labs/assignment1/part2/odom_subscriber/#the-initial-code","title":"The Initial Code","text":"<p>Having copied the <code>subscriber.py</code> file from your <code>part1_pubsub</code> package, you'll start out with the code discussed here.</p> <p>Let's look at what we need to change now.</p>"},{"location":"labs/assignment1/part2/odom_subscriber/#from-simple-subscriber-to-odom-subscriber","title":"From Simple Subscriber to Odom Subscriber","text":""},{"location":"labs/assignment1/part2/odom_subscriber/#imports","title":"Imports","text":"<p>We will generally rely on <code>rclpy</code> and the <code>Node</code> class from the <code>rclpy.node</code> library, for most nodes that we will create, so our first two imports will remain the same. </p> <p>We won't be working with <code>String</code> type messages any more however, so we need to replace this line in order to import the correct message type. As we know from earlier in Part 2, the <code>/odom</code> topic uses messages of the type <code>nav_msgs/msg/Odometry</code>:</p> <pre><code>$ ros2 topic info /odom\nType: nav_msgs/msg/Odometry\n...\n</code></pre> <p>This tells us everything we need to know to construct the Python import statement correctly:</p> <pre><code>from nav_msgs.msg import Odometry\n</code></pre> <p>We'll also need to import a handy function that should already exist as an importable module in your <code>part2_navigation</code> package called <code>tb3_tools</code>:</p> <pre><code>from part2_navigation.tb3_tools import quaternion_to_euler\n</code></pre> <p>As the name suggests, we'll use this to convert the raw orientation values from <code>/odom</code> into their Euler Angle representation.</p> Info <p>This module can be found here: <code>part2_navigation/part2_navigation/tb3_tools.py</code>, if you want to have a look.</p>"},{"location":"labs/assignment1/part2/odom_subscriber/#change-the-class-name","title":"Change the Class Name","text":"<p>Previously our class was called <code>SimpleSubscriber()</code>, change this to something more appropriate now, e.g.: <code>OdomSubscriber()</code>:</p> <pre><code>class OdomSubscriber(Node):\n</code></pre>"},{"location":"labs/assignment1/part2/odom_subscriber/#initialising-the-class","title":"Initialising the Class","text":"<p>The structure of this remains largely the same, we just need to modify a few things: </p> <ol> <li> <p>Change the name that is used to register the node on the ROS Network:</p> <pre><code>super().__init__(\"odom_subscriber\")\n</code></pre> </li> <li> <p>Change the subscription parameters:</p> <pre><code>self.my_subscriber = self.create_subscription(\n    msg_type=Odometry, # (1)!\n    topic=\"odom\", # (2)!\n    callback=self.msg_callback, \n    qos_profile=10,\n)\n</code></pre> <ol> <li><code>/odom</code> uses the Odometry message type (as imported above)</li> <li>The topic name is <code>\"odom\"</code>, of course!</li> </ol> </li> <li> <p>The final thing we'll do inside our class' <code>__init__</code> method (after we've set up the subscriber) is initialise a counter:</p> <pre><code>self.counter = 0 \n</code></pre> <p>The reason for this will be explained shortly...</p> </li> </ol>"},{"location":"labs/assignment1/part2/odom_subscriber/#modifying-the-message-callback","title":"Modifying the Message Callback","text":"<p>This is where the changes are a bit more significant:</p> <pre><code>def msg_subscriber(self, topic_message: Odometry): # (1)!\n\n    pose = topic_data.pose.pose # (2)!\n\n    # (3)!\n    pos_x = pose.position.x\n    pos_y = pose.position.y\n    pos_z = pose.position.z\n\n    roll, pitch, yaw = quaternion_to_euler(pose.orientation) # (4)!\n\n    if self.counter &gt; 10: # (5)!\n        self.counter = 0\n        self.get_logger().info(\n            f\"x = {pos_x:.3f} (m), y = ? (m), theta_z = ? (radians)\"\n        ) # (6)!\n    else:\n        self.counter += 1\n</code></pre> <ol> <li>When defining the message callback, modify the type annotation for the <code>topic_message</code> input.</li> <li> <p>There are two key parts to an odometry message: Pose and Twist.</p> <p>We're only really interested in the Pose part of the message here, so grab this first.</p> </li> <li> <p>As we know by now, Pose contains information about both the \"position\" and \"orientation\" of the robot, we extract the position values first and assign them to the variables <code>pos_x</code>, <code>pos_y</code> and <code>pos_z</code>.</p> <p>Position data is provided in meters, so we don't need to do any conversion on this and can use the data directly.</p> </li> <li> <p>Orientation data is in quaternions, so we convert this by passing it to the <code>quaternion_to_euler</code> function that we imported from <code>tb3_tools</code> earlier.</p> <p>This function provides us with the orientation of the robot about its 3 principal axes:</p> <ul> <li><code>\u03b8<sub>x</sub></code>: \"Roll\"</li> <li><code>\u03b8<sub>y</sub></code>: \"Pitch\"</li> <li><code>\u03b8<sub>z</sub></code>: \"Yaw\"</li> </ul> </li> <li> <p>Here we print out the values that we're interested in to the terminal.</p> <p>This callback function will execute every time a new message is published to the <code>odom</code> topic, which occurs at a rate of around 20 times per second (20 Hz).</p> Tip <p>We can use he <code>ros2 topic hz</code> function to tell us this:</p> <pre><code>$ ros2 topic hz /odom\naverage rate: 18.358\nmin: 0.037s max: 0.088s std dev: 0.01444s window: 20\n</code></pre> <p>That's a lot of messages to be printed to the terminal every second! We therefore use an <code>if</code> statement and a <code>counter</code> to ensure that our <code>print</code> statement only executes for 1 in every 10 topic messages instead.</p> </li> <li> <p>Task: Continue formatting the <code>print</code> message to display the three odometry values that are relevant to our robot!  </p> </li> </ol>"},{"location":"labs/assignment1/part2/odom_subscriber/#updating-main","title":"Updating \"Main\"","text":"<p>The only thing left to do now is update any relevant parts of the <code>main</code> function to ensure that you are instantiating, spinning and shutting down your node correctly.</p> <p> \u2190 Back to Part 2 </p>"},{"location":"labs/assignment1/part4/move_client/","title":"Part 4 Move Service-Client","text":"<p>Copy all the code below into your <code>move_client.py</code> file and review the annotations to understand how it all works.</p> <p>DFTS!!</p> <p>(Don't forget the shebang!) <pre><code>#!/usr/bin/env python3\n</code></pre></p> move_client.py<pre><code>#!/usr/bin/env python3\n\nimport rclpy\nfrom rclpy.node import Node\nfrom std_srv.srv import SetBool  # Import the standard SetBool service\n\nclass MoveServiceClient(Node):\n    def _init_(self):\n        super()._init_('move_service_client')  # Initialize the node with a name\n        self.client = self.create_client(SetBool, 'setbool')  # Create a service client\n\n        while not self.client.wait_for_service(timeout_sec=1.0):\n            print('Waiting for the move_service to be available...')\n        self.request= SetBool.Request()\n\n    def send_request(self):\n        request = SetBool.Request()  # Create a request object\n        request.data = True  # Set the request data\n\n        future = self.client.call_async(request)  # Call the service asynchronously\n        rclpy.spin_until_future_complete(self, future)  # Wait until the future completes\n\n        if future.result() is not None:\n            print (f'Response: {future.result().success}, {future.result().message}')\n        else:\n            print ('Service call failed')\n\ndef main(args=None):\n    rclpy.init(args=args)  # Initialize the rclpy library\n    client = MoveServiceClient()  # Create a client node\n    client.send_request()  # Send the request to the service\n    client.destroy_node()  # Clean up the node\n    rclpy.shutdown()  # Shutdown rclpy\n\nif _name_ == '_main_':\n    main()\n</code></pre>"},{"location":"labs/assignment1/part4/move_server/","title":"Part 4 Move Service-Server","text":"<p>Copy all the code below into your <code>move_server.py</code> file and review the annotations to understand how it all works.</p> <p>Remember</p> <p>Don't forget the shebang!</p> <pre><code>#!/usr/bin/env python3\n</code></pre> move_server.py<pre><code>#!/usr/bin/env python3\n\nimport rclpy\nfrom rclpy.node import Node\nfrom geometry_msgs.msg import Twist\nfrom std_srvs.srv import SetBool\n\nclass MoveService(Node):\n\n    def _init_(self):\n        super()._init_('move_service_server')\n        self.service = self.create_service(SetBool, 'move_service', self.srv_callback)\n        self.pub = self.create_publisher(Twist, '/cmd_vel', 10)\n\n        print(\"The 'move_service' server is ready to be called...\")\n\n    def srv_callback(self, request_from_client, response_from_server):\n        vel = Twist()\n\n        if request_from_client.data:  # request_signal is now .data in ROS2\n            print(\"Server received a 'true' request and the robot will now move for 5 seconds...\")\n\n            start_time = self.get_clock().now()\n\n            vel.linear.x = 0.1\n            self.pub.publish(vel)\n\n            print('Published the velocity command to /cmd_vel')\n            while (self.get_clock().now() - start_time).seconds &lt; 5:\n                rclpy.spin_once(self, timeout_sec=0.1)  # Allows callbacks to be processed while waiting\n\n            print ('5 seconds have elapsed, stopping the robot...')\n\n            vel.linear.x = 0.0\n            self.pub.publish(vel)\n\n            response_from_server.success = True  # response_signal is now .success in ROS2\n            response_from_server.message = \"Request complete.\"\n        else:\n            response_from_server.success = False\n            response_from_server.message = \"Nothing happened, set request_signal to 'true' next time.\"\n        return response_from_server\n\ndef main(args=None):\n    rclpy.init(args=args)\n    server = MoveService()\n    rclpy.spin(server)\n\n    # Clean up on shutdown\n    server.destroy_node()\n    rclpy.shutdown()\n\nif _name_ == '_main_':\n    main()\n</code></pre>"},{"location":"labs/assignment2/","title":"Assignment #2: Team Robotics Project","text":""},{"location":"labs/assignment2/#overview","title":"Overview","text":"<p>In Assignment #2 you will put into practice everything that you learn about ROS in Assignment #1, and explore the capabilities of the framework further.</p> <p>You will attend a 2-hour lab session per week in Diamond Computer Room 5 for the full 12-week semester. You will work in teams to develop ROS Nodes for our TurtleBot3 Waffles that allow them to successfully complete a series of robotics tasks, most of which in a real-world environment. There are XXX tasks to complete in total, all of which will be assessed as part of Assignment #2.</p> <p>TODO...</p>"},{"location":"ros/","title":"Installing ROS","text":"<p>Details on the ROS2 Simulation environment (TODO)</p>"},{"location":"waffles/","title":"The Waffles","text":"<p>Details on the robot's and how to work with them.</p> <p>Based on this from 2023/24</p>"}]}